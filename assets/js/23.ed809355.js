(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{432:function(e,i,t){"use strict";t.r(i);var n=t(5),s=Object(n.a)({},(function(){var e=this,i=e._self._c;return i("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[i("h4",{attrs:{id:"_1-difference-between-iseldagtodag-and-isellowering"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_1-difference-between-iseldagtodag-and-isellowering"}},[e._v("#")]),e._v(" 1. Difference between ISelDAGToDAG and ISelLowering")]),e._v(" "),i("p",[e._v("In LLVM's backend, ISelLowering and ISelDAGToDAG are two important classes that play different roles in the instruction selection process. Here's the difference between them and the phases in which they are called:")]),e._v(" "),i("p",[i("em",[i("strong",[e._v("ISelDAGToDAG")])])]),e._v(" "),i("ul",[i("li",[i("p",[e._v('Role: ISelDAGToDAG stands for "Instruction Selection DAG to DAG". This class is responsible for translating the Selection DAG (Directed Acyclic Graph) into a sequence of target-specific instructions.')])]),e._v(" "),i("li",[i("p",[e._v('Phase: ISelDAGToDAG is called during the "Instruction Selection" phase of the compiler backend. This phase comes after the DAG Legalization phase and before Register Allocation.')])]),e._v(" "),i("li",[i("p",[e._v("Functions: In ISelDAGToDAG, you will find functions like Select, which is responsible for selecting target instructions for each node in the DAG.")])])]),e._v(" "),i("p",[e._v("Typical Functions:")]),e._v(" "),i("div",{staticClass:"language- line-numbers-mode"},[i("pre",{pre:!0,attrs:{class:"language-text"}},[i("code",[e._v("Select: Select target instructions for nodes in the DAG.\nSelectNode: Implement target-specific node selection.\nPreprocessISelDAG: Prepare for instruction selection.\nPostprocessISelDAG: Clean up after instruction selection.\n")])]),e._v(" "),i("div",{staticClass:"line-numbers-wrapper"},[i("span",{staticClass:"line-number"},[e._v("1")]),i("br"),i("span",{staticClass:"line-number"},[e._v("2")]),i("br"),i("span",{staticClass:"line-number"},[e._v("3")]),i("br"),i("span",{staticClass:"line-number"},[e._v("4")]),i("br")])]),i("p",[i("em",[i("strong",[e._v("ISelLowering")])])]),e._v(" "),i("ul",[i("li",[i("p",[e._v('Role: ISelLowering stands for "Instruction Selection Lowering". This class provides target-specific information and handling for aspects of instruction selection during the Selection DAG Construction phase.')])]),e._v(" "),i("li",[i("p",[e._v('Phase: ISelLowering is called during the "Selection DAG Construction" phase of the compiler backend. This phase transforms the generic LLVM IR into a machine-independent representation, the Selection DAG.')])]),e._v(" "),i("li",[i("p",[e._v("Functions: In ISelLowering, you will find functions that define how LLVM IR operations are translated into target-specific instructions. This includes custom lowering of specific LLVM IR operations, defining patterns for converting LLVM IR to target nodes, and providing information about target-specific features and constraints.")])])]),e._v(" "),i("p",[e._v("Typical Functions:")]),e._v(" "),i("div",{staticClass:"language- line-numbers-mode"},[i("pre",{pre:!0,attrs:{class:"language-text"}},[i("code",[e._v("LowerCall: Lower calls to target-specific calling conventions.\nLowerReturn: Lower return instructions to target-specific sequences.\nEmitInstrWithCustomInserter: Handle target-specific instructions with custom insertion logic.\ngetTargetNodeName: Provide human-readable names for target nodes.\n")])]),e._v(" "),i("div",{staticClass:"line-numbers-wrapper"},[i("span",{staticClass:"line-number"},[e._v("1")]),i("br"),i("span",{staticClass:"line-number"},[e._v("2")]),i("br"),i("span",{staticClass:"line-number"},[e._v("3")]),i("br"),i("span",{staticClass:"line-number"},[e._v("4")]),i("br")])]),i("p",[i("em",[i("strong",[e._v("Phases in Summary")])])]),e._v(" "),i("ul",[i("li",[i("p",[e._v("Selection DAG Construction:")]),e._v(" "),i("ul",[i("li",[e._v("ISelLowering is called during this phase.")]),e._v(" "),i("li",[e._v("This phase transforms the generic LLVM IR into a machine-independent representation (the Selection DAG).")]),e._v(" "),i("li",[e._v("Functions in ISelLowering handle how LLVM IR operations are translated into target-specific instructions.")])])]),e._v(" "),i("li",[i("p",[e._v("DAG Legalization:")]),e._v(" "),i("ul",[i("li",[e._v("Various transformations to ensure DAG conforms to target-specific constraints.")]),e._v(" "),i("li",[e._v("Typically, no specific user-defined classes are involved in this phase.")])])]),e._v(" "),i("li",[i("p",[e._v("Instruction Selection (ISelDAGToDAG):")]),e._v(" "),i("ul",[i("li",[e._v("ISelDAGToDAG is called during this phase.")]),e._v(" "),i("li",[e._v("Translates the Selection DAG into a sequence of target-specific instructions.")]),e._v(" "),i("li",[e._v("Functions in ISelDAGToDAG handle how DAG nodes are selected and transformed into machine instructions.")])])]),e._v(" "),i("li",[i("p",[e._v("Register Allocation:")]),e._v(" "),i("ul",[i("li",[e._v("Assigns virtual registers to physical registers.")]),e._v(" "),i("li",[e._v("Ensures that the generated code does not use more registers than available.")])])]),e._v(" "),i("li",[i("p",[e._v("Frame Lowering:")]),e._v(" "),i("ul",[i("li",[e._v("Manages the function's stack frame.")]),e._v(" "),i("li",[e._v("Sets up the stack frame, manages the frame pointer, and handles stack frame operations.")])])]),e._v(" "),i("li",[i("p",[e._v("Prologue and Epilogue Emission:")]),e._v(" "),i("ul",[i("li",[e._v("Generates the machine code for the function's entry and exit sequences.")]),e._v(" "),i("li",[e._v("Includes setting up the stack frame, saving/restoring callee-saved registers, etc.")])])])]),e._v(" "),i("p",[e._v("In summary, ISelLowering is called during the Selection DAG Construction phase to handle translation of LLVM IR to target-specific instructions. ISelDAGToDAG is called during the Instruction Selection phase to translate the Selection DAG to a sequence of target-specific instructions. These phases work together to convert the LLVM IR into machine code for the target architecture.")]),e._v(" "),i("hr"),e._v(" "),i("h4",{attrs:{id:"_2-analysis-pass-and-tranform-pass"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_2-analysis-pass-and-tranform-pass"}},[e._v("#")]),e._v(" 2. Analysis Pass and Tranform Pass")]),e._v(" "),i("p",[i("em",[i("strong",[e._v("Analysis Passes in LLVM:")])])]),e._v(" "),i("ul",[i("li",[e._v("Purpose:")])]),e._v(" "),i("ul",[i("li",[e._v("Analysis passes in LLVM are used to gather information about the program without modifying it.")]),e._v(" "),i("li",[e._v("They analyze the program's code structure, control flow, data flow, and other properties.")]),e._v(" "),i("li",[e._v("This information is used by subsequent optimization passes to make informed decisions.")])]),e._v(" "),i("ul",[i("li",[i("p",[e._v("Characteristics:")]),e._v(" "),i("ul",[i("li",[e._v("Do not modify the program.")]),e._v(" "),i("li",[e._v("Collect information about the program.")]),e._v(" "),i("li",[e._v("Used by other passes to guide optimizations.")]),e._v(" "),i("li",[e._v("Typically run early in the optimization pipeline.")])])]),e._v(" "),i("li",[i("p",[e._v("Major Analysis Passes:")]),e._v(" "),i("ul",[i("li",[i("p",[e._v("DominatorTree Analysis:")]),e._v(" "),i("ul",[i("li",[e._v("Computes the dominator tree for a function.")]),e._v(" "),i("li",[e._v("Helps in various optimizations such as loop optimization, control flow analysis, etc.")])])]),e._v(" "),i("li",[i("p",[e._v("LoopInfo Analysis:")]),e._v(" "),i("ul",[i("li",[e._v("Provides information about loops in a function.")]),e._v(" "),i("li",[e._v("Used by loop optimization passes for loop transformations.")])])]),e._v(" "),i("li",[i("p",[e._v("ScalarEvolution Analysis:")]),e._v(" "),i("ul",[i("li",[e._v("Analyzes and characterizes scalar expressions in loops.")]),e._v(" "),i("li",[e._v("Helps in loop transformations like loop unrolling, loop vectorization, etc.")])])]),e._v(" "),i("li",[i("p",[e._v("MemorySSA Analysis:")]),e._v(" "),i("ul",[i("li",[e._v("Provides a memory SSA representation of the program.")]),e._v(" "),i("li",[e._v("Used in optimizations related to memory access analysis, alias analysis, etc.")])])]),e._v(" "),i("li",[i("p",[e._v("AliasAnalysis Analysis:")]),e._v(" "),i("ul",[i("li",[e._v("Determines the aliasing relationship between memory accesses.")]),e._v(" "),i("li",[e._v("Helps in optimizations that depend on memory aliasing information.")])])])])])]),e._v(" "),i("p",[i("em",[i("strong",[e._v("Transform Passes in LLVM:")])])]),e._v(" "),i("ul",[i("li",[i("p",[e._v("Purpose:\nTransform passes in LLVM modify the program's IR to improve its performance or reduce its size.\nThey apply optimizations and transformations to the code.")])]),e._v(" "),i("li",[i("p",[e._v("Characteristics:")]),e._v(" "),i("ul",[i("li",[e._v("Modify the program's IR.")]),e._v(" "),i("li",[e._v("Apply optimizations and transformations.")]),e._v(" "),i("li",[e._v("Can introduce new code or modify existing code.")]),e._v(" "),i("li",[e._v("Typically run after analysis passes.")])])]),e._v(" "),i("li",[i("p",[e._v("Major Transform Passes:")]),e._v(" "),i("ul",[i("li",[i("p",[e._v("Instruction Combining:")]),e._v(" "),i("ul",[i("li",[e._v("Combines multiple instructions into simpler forms.")]),e._v(" "),i("li",[e._v("Reduces the number of instructions and improves code readability.")])])]),e._v(" "),i("li",[i("p",[e._v("Dead Code Elimination:")]),e._v(" "),i("ul",[i("li",[e._v("Removes code that is guaranteed to have no effect on program output.")]),e._v(" "),i("li",[e._v("Improves code size and execution speed.")])])]),e._v(" "),i("li",[i("p",[e._v("Loop Unrolling:")]),e._v(" "),i("ul",[i("li",[e._v("Duplicates the loop body multiple times to reduce loop overhead.")]),e._v(" "),i("li",[e._v("Improves instruction-level parallelism.")])])]),e._v(" "),i("li",[i("p",[e._v("Function Inlining:")]),e._v(" "),i("ul",[i("li",[e._v("Replaces a function call with the body of the called function.")]),e._v(" "),i("li",[e._v("Reduces function call overhead and enables further optimizations.")])])]),e._v(" "),i("li",[i("p",[e._v("Constant Propagation:")]),e._v(" "),i("ul",[i("li",[e._v("Propagates constant values through the program.")]),e._v(" "),i("li",[e._v("Enables further optimizations by replacing variables with constants.")])])]),e._v(" "),i("li",[i("p",[e._v("Vectorization (Loop Vectorization):")]),e._v(" "),i("ul",[i("li",[e._v("Converts scalar operations in loops into SIMD (Single Instruction, Multiple Data) operations.")]),e._v(" "),i("li",[e._v("Improves performance by exploiting parallelism in hardware.")])])]),e._v(" "),i("li",[i("p",[e._v("SROA (Scalar Replacement of Aggregates):")]),e._v(" "),i("ul",[i("li",[e._v("Breaks down aggregates (like structs) into individual scalar variables.")]),e._v(" "),i("li",[e._v("Improves optimization opportunities by working on individual scalar variables.")])])])])])]),e._v(" "),i("p",[i("em",[i("strong",[e._v("Summary:")])])]),e._v(" "),i("ul",[i("li",[e._v("Analysis Passes:\n"),i("ul",[i("li",[e._v("Gather information about the program.")]),e._v(" "),i("li",[e._v("Do not modify the program.")]),e._v(" "),i("li",[e._v("Used by other passes for optimizations.")]),e._v(" "),i("li",[e._v("Examples: DominatorTree, LoopInfo, ScalarEvolution, MemorySSA, AliasAnalysis.")])])]),e._v(" "),i("li",[e._v("Transform Passes:\n"),i("ul",[i("li",[e._v("Modify the program's IR.")]),e._v(" "),i("li",[e._v("Apply optimizations and transformations.")]),e._v(" "),i("li",[e._v("Examples: Instruction Combining, Dead Code Elimination, Loop Unrolling, Function Inlining, Constant Propagation, Vectorization, SROA (Scalar Replacement of Aggregates).\nThese are just a few examples of major analysis and transform passes in LLVM. The LLVM infrastructure provides a wide range of passes for various optimizations and analyses, allowing users to construct custom optimization pipelines tailored to their specific needs.")])])])]),e._v(" "),i("hr"),e._v(" "),i("h3",{attrs:{id:"_3-knowledge-fragments"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_3-knowledge-fragments"}},[e._v("#")]),e._v(" 3. Knowledge Fragments")]),e._v(" "),i("ol",[i("li",[i("p",[i("em",[i("strong",[e._v("SROA is claimed to replace mem2reg.")])]),e._v(" "),i("br"),e._v(" "),i("a",{attrs:{href:"https://discourse.llvm.org/t/llvm-ir-after-mem2reg-optimisation/63682",target:"_blank",rel:"noopener noreferrer"}},[e._v("discourse.llvm"),i("OutboundLink")],1)])]),e._v(" "),i("li",[i("p",[i("em",[i("strong",[e._v("Alias Analysis")])]),e._v(" "),i("br"),e._v("\nAlias Analysis (aka Pointer Analysis) is a class of techniques which attempt to determine whether or not two pointers ever can point to the same object in memory."),i("br"),e._v("\nTraditionally, alias analyses respond to a query with a Must, May, or No alias response, indicating that two pointers always point to the same object, might point to the same object, or are known to never point to the same object."),i("br")])]),e._v(" "),i("li",[i("p",[i("em",[i("strong",[e._v("RISCV Instruction Set Might deserves further explore.")])]),e._v(" "),i("br"),e._v(" "),i("a",{attrs:{href:"https://www2.eecs.berkeley.edu/Pubs/TechRpts/2015/EECS-2015-209.pdf",target:"_blank",rel:"noopener noreferrer"}},[e._v("Berkely RISCV Instruction Set Manual"),i("OutboundLink")],1),e._v(" "),i("br")])]),e._v(" "),i("li",[i("p",[i("em",[i("strong",[e._v("How LLVM Optimizes a Function")])]),e._v(" "),i("br"),e._v(" "),i("a",{attrs:{href:"https://blog.regehr.org/archives/1603",target:"_blank",rel:"noopener noreferrer"}},[e._v("How LLVM Optimizes a Function"),i("OutboundLink")],1),e._v(" "),i("br"),e._v("\nThis blog trace through different passes in llvm IR."),i("br")])]),e._v(" "),i("li",[i("p",[i("em",[i("strong",[e._v("CambridgeSlides")])]),e._v(" "),i("br"),e._v(" "),i("a",{attrs:{href:"https://www.cl.cam.ac.uk/teaching/1617/L25/materials.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("Cambridge Modern Compiler Design"),i("OutboundLink")],1)]),e._v(" "),i("ul",[i("li",[e._v("Introduction")]),e._v(" "),i("li",[e._v("Modern intermediate representations")]),e._v(" "),i("li",[e._v("LLVM IR and transform pipeline")]),e._v(" "),i("li",[e._v("Modern processor architectures")]),e._v(" "),i("li",[e._v("Dynamic dispatch and duck typing")]),e._v(" "),i("li",[e._v("Autovectorisation")]),e._v(" "),i("li",[e._v("Garbage collection")]),e._v(" "),i("li",[e._v("JIT Compilation")])])])])])}),[],!1,null,null,null);i.default=s.exports}}]);
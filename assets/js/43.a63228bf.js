(window.webpackJsonp=window.webpackJsonp||[]).push([[43],{453:function(s,n,e){"use strict";e.r(n);var t=e(5),a=Object(t.a)({},(function(){var s=this,n=s._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[n("ul",[n("li",[s._v("libcuda\n"),n("ul",[n("li",[s._v("cuda_runtime_api.cc")])])]),s._v(" "),n("li",[s._v("src\n"),n("ul",[n("li",[s._v("abstract_hardware_model.h/cpp")]),s._v(" "),n("li",[s._v("gpgpusim_entrypoint.h/cpp")]),s._v(" "),n("li",[s._v("stream_manager.h/cpp")]),s._v(" "),n("li",[s._v("cuda-sim\n"),n("ul",[n("li",[s._v("cuda-sim.h/cc")]),s._v(" "),n("li",[s._v("memory.h/cc")]),s._v(" "),n("li",[s._v("opcode.h/def")]),s._v(" "),n("li",[s._v("ptx_loader.h/cc")]),s._v(" "),n("li",[s._v("ptx.y\\")]),s._v(" "),n("li",[s._v("ptx_parser.h/cc")]),s._v(" "),n("li",[s._v("ptx_ir.h/cc")]),s._v(" "),n("li",[s._v("ptx_sim.h/cc")])])]),s._v(" "),n("li",[s._v("gpgpu-sim\n"),n("ul",[n("li",[s._v("gpgpu-sim.h/cc")]),s._v(" "),n("li",[s._v("shader.h/shader.cc")]),s._v(" "),n("li",[s._v("mem_fetch.h/cc")]),s._v(" "),n("li",[s._v("stack.h/cc")]),s._v(" "),n("li",[s._v("addrdec.h/cc")]),s._v(" "),n("li",[s._v("dram.h/cc")]),s._v(" "),n("li",[s._v("traffic_breakdown.h/cc")])])])])])]),s._v(" "),n("h3",{attrs:{id:"how-do-cuda-instructions-get-executed"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#how-do-cuda-instructions-get-executed"}},[s._v("#")]),s._v(" How do CUDA instructions get executed ?")]),s._v(" "),n("h4",{attrs:{id:"instruction-level"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#instruction-level"}},[s._v("#")]),s._v(" Instruction Level")]),s._v(" "),n("p",[s._v("In opcodes.def, it defines hook for each type of instruction.")]),s._v(" "),n("p",[s._v("In instruction.cc, it implements the detail of each function.\nIf this is a Load instruction, mem->read() is exectued.")]),s._v(" "),n("details",[n("summary",[s._v("Code")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v('// @@@@@@ opcodes.def\nOP_DEF(LD_OP,ld_impl,"ld",1,5)\nOP_DEF(ST_OP,st_impl,"st",0,5)\n\n// @@@@@@ instructions.cc\nvoid ld_exec( const ptx_instruction *pI, ptx_thread_info *thread ) \n{ \n   const operand_info &dst = pI->dst();\n   const operand_info &src1 = pI->src1();\n   ...\n   mem->read(addr,size/8,&data.s64);\n}\n\nvoid ld_impl( const ptx_instruction *pI, ptx_thread_info *thread ) \n{\n   ld_exec(pI,thread);\n}\n')])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br")])])]),s._v(" "),n("h4",{attrs:{id:"abstract-level"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#abstract-level"}},[s._v("#")]),s._v(" Abstract Level")]),s._v(" "),n("p",[s._v("The abstract core calls execute_warp_inst_t, which will execute each thread in the warp.")]),s._v(" "),n("p",[s._v('As to each instruction, it will call a "DEFINE" macro, which will invoke function, described in previous Section.')]),s._v(" "),n("details",[n("summary",[s._v("Code")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v('// @@@@@@ abstract_hardware_model.cc\n\nvoid core_t::execute_warp_inst_t(warp_inst_t &inst, unsigned warpId)\n{\n    for ( unsigned t=0; t < m_warp_size; t++ ) {\n        if( inst.active(t) ) {\n            if(warpId==(unsigned (-1)))\n                warpId = inst.warp_id();\n            unsigned tid=m_warp_size*warpId+t;\n            m_thread[tid]->ptx_exec_inst(inst,t);\n            \n            //virtual function\n            checkExecutionStatusAndUpdate(inst,t,tid);\n        }\n    } \n}\n\n// @@@@@@ cuda-sim.cc\nvoid ptx_thread_info::ptx_exec_inst( warp_inst_t &inst, unsigned lane_id)\n{\n      ...\n      switch ( pI->get_opcode() ) {\n      #define OP_DEF(OP,FUNC,STR,DST,CLASSIFICATION) case OP: FUNC(pI,this); op_classification = CLASSIFICATION; break;\n      ...\n      #include "opcodes.def"\n      #undef OP_DEF\n      default: printf( "Execution error: Invalid opcode (0x%x)\\n", pI->get_opcode() ); break;\n      }\n}\n\n')])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br"),n("span",{staticClass:"line-number"},[s._v("22")]),n("br"),n("span",{staticClass:"line-number"},[s._v("23")]),n("br"),n("span",{staticClass:"line-number"},[s._v("24")]),n("br"),n("span",{staticClass:"line-number"},[s._v("25")]),n("br"),n("span",{staticClass:"line-number"},[s._v("26")]),n("br"),n("span",{staticClass:"line-number"},[s._v("27")]),n("br"),n("span",{staticClass:"line-number"},[s._v("28")]),n("br"),n("span",{staticClass:"line-number"},[s._v("29")]),n("br"),n("span",{staticClass:"line-number"},[s._v("30")]),n("br")])])]),s._v(" "),n("h4",{attrs:{id:"detail-gpu-mode"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#detail-gpu-mode"}},[s._v("#")]),s._v(" Detail GPU Mode")]),s._v(" "),n("p",[s._v("In detail GPU, programmed in shader.cc, instruction is executed at issue time.")]),s._v(" "),n("p",[s._v("This is reasonable, as long as the latency and bandwidth is modeled correctly, it is accurate.")]),s._v(" "),n("details",[n("summary",[s._v("Code")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("// @@@@@@ shader.cc\nvoid shader_core_ctx::issue_warp( register_set& pipe_reg_set, const warp_inst_t* next_inst, const active_mask_t &active_mask, unsigned warp_id )\n{\n    ...\n    func_exec_inst( **pipe_reg );\n}\n\nvoid shader_core_ctx::func_exec_inst( warp_inst_t &inst )\n{\n    execute_warp_inst_t(inst);\n    // !!!!!! Notice that as to memory access instruction, it will generate memory access\n    if( inst.is_load() || inst.is_store() )\n        inst.generate_mem_accesses();\n}\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br")])])]),s._v(" "),n("p",[s._v("Then we can go further, how is "),n("em",[s._v("issue_warp")]),s._v(" called?")]),s._v(" "),n("p",[s._v("In shader.cc, for each cycle, it will check is the status of for each warp.")]),s._v(" "),n("p",[s._v("As to each warp, it will check whether the first instruction in the instruction buffer, after checking scoreboard, if this is no hazard and issue width is not saturated, the warp could be issued.")]),s._v(" "),n("details",[n("summary",[s._v("Code")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("// @@@@@@ shader.cc\nvoid scheduler_unit::cycle()\n{\n    SCHED_DPRINTF( \"scheduler_unit::cycle()\\n\" );\n    bool valid_inst = false;  // there was one warp with a valid instruction to issue (didn't require flush due to control hazard)\n    bool ready_inst = false;  // of the valid instructions, there was one not waiting for pending register writes\n    bool issued_inst = false; // of these we issued one\n\n    for ( std::vector< shd_warp_t* >::const_iterator iter = m_next_cycle_prioritized_warps.begin();\n          iter != m_next_cycle_prioritized_warps.end();\n          iter++ ) {\n        // Don't consider warps that are not yet valid\n        if ( (*iter) == NULL || (*iter)->done_exit() ) {\n            continue;\n        }\n        while( !warp(warp_id).waiting() && !warp(warp_id).ibuffer_empty() ... && (checked <= issued) && (issued < max_issue) ) {\n         const warp_inst_t *pI = warp(warp_id).ibuffer_next_inst();\n         ...\n         if ( (pI->op == LOAD_OP) || (pI->op == STORE_OP) || (pI->op == MEMORY_BARRIER_OP) ) {\n             if( m_mem_out->has_free() ) {\n                 m_shader->issue_warp(*m_mem_out,pI,active_mask,warp_id);\n             }\n         } else {\n             \n         }\n    }\n}\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br"),n("span",{staticClass:"line-number"},[s._v("22")]),n("br"),n("span",{staticClass:"line-number"},[s._v("23")]),n("br"),n("span",{staticClass:"line-number"},[s._v("24")]),n("br"),n("span",{staticClass:"line-number"},[s._v("25")]),n("br"),n("span",{staticClass:"line-number"},[s._v("26")]),n("br"),n("span",{staticClass:"line-number"},[s._v("27")]),n("br")])])]),s._v(" "),n("p",[s._v("In the above code, u can see the "),n("em",[s._v("m_shader->issue_warp()")]),s._v(" .\nUnderneath the "),n("em",[s._v("issue_warp")]),s._v(", it is "),n("em",[s._v("func_exec_inst")]),s._v(", as shown in the following code.")]),s._v(" "),n("details",[n("summary",[s._v("Code")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("// @@@@@@ shader.cc\n\nvoid shader_core_ctx::func_exec_inst( warp_inst_t &inst )\n{\n    execute_warp_inst_t(inst);\n    if( inst.is_load() || inst.is_store() )\n        inst.generate_mem_accesses();\n}\n\nvoid shader_core_ctx::issue_warp( register_set& pipe_reg_set, const warp_inst_t* next_inst, const active_mask_t &active_mask, unsigned warp_id )\n{\n    warp_inst_t** pipe_reg = pipe_reg_set.get_free();\n    assert(pipe_reg);\n\n    m_warp[warp_id].ibuffer_free();\n    assert(next_inst->valid());\n    **pipe_reg = *next_inst; // static instruction information\n    (*pipe_reg)->issue( active_mask, warp_id, gpu_tot_sim_cycle + gpu_sim_cycle, m_warp[warp_id].get_dynamic_warp_id() ); // dynamic instruction information\n    m_stats->shader_cycle_distro[2+(*pipe_reg)->active_count()]++;\n    func_exec_inst( **pipe_reg );\n    if( next_inst->op == BARRIER_OP ){\n        m_warp[warp_id].store_info_of_last_inst_at_barrier(*pipe_reg);\n        m_barriers.warp_reaches_barrier(m_warp[warp_id].get_cta_id(),warp_id,const_cast<warp_inst_t*> (next_inst));\n\n    }else if( next_inst->op == MEMORY_BARRIER_OP ){\n        m_warp[warp_id].set_membar();\n    }\n\n    updateSIMTStack(warp_id,*pipe_reg);\n    m_scoreboard->reserveRegisters(*pipe_reg);\n    m_warp[warp_id].set_next_pc(next_inst->pc + next_inst->isize);\n}\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br"),n("span",{staticClass:"line-number"},[s._v("22")]),n("br"),n("span",{staticClass:"line-number"},[s._v("23")]),n("br"),n("span",{staticClass:"line-number"},[s._v("24")]),n("br"),n("span",{staticClass:"line-number"},[s._v("25")]),n("br"),n("span",{staticClass:"line-number"},[s._v("26")]),n("br"),n("span",{staticClass:"line-number"},[s._v("27")]),n("br"),n("span",{staticClass:"line-number"},[s._v("28")]),n("br"),n("span",{staticClass:"line-number"},[s._v("29")]),n("br"),n("span",{staticClass:"line-number"},[s._v("30")]),n("br"),n("span",{staticClass:"line-number"},[s._v("31")]),n("br"),n("span",{staticClass:"line-number"},[s._v("32")]),n("br")])])]),s._v(" "),n("h4",{attrs:{id:"register-hazard"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#register-hazard"}},[s._v("#")]),s._v(" Register Hazard")]),s._v(" "),n("p",[s._v("It seems like gpgpu-sim does not use register dependency wakeup, like ROB, which contains a register ID that if dependency instruction has executed, the result transfer through bypassnet work and wakeup pending instructions.")]),s._v(" "),n("p",[s._v("In gpgpu-sim, in the writeback stage, it will release its target registers in scoreboard.\n")]),n("details",[n("summary",[s._v("Code")]),n("p"),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("// @@@@@@ shader.cc\nvoid shader_core_ctx::writeback()\n{\n    warp_inst_t** preg = m_pipeline_reg[EX_WB].get_ready();\n    warp_inst_t* pipe_reg = (preg==NULL)? NULL:*preg;\n    while( preg and !pipe_reg->empty()) {\n        m_scoreboard->releaseRegisters( pipe_reg );\n        warp_inst_complete(*pipe_reg);\n    }\n}\n\n// @@@@@@ scoreboard.cc\n// Release target registers for an instruction\nvoid Scoreboard::releaseRegisters(const class warp_inst_t *inst) \n{\n    for( unsigned r=0; r < 4; r++) {\n        if(inst->out[r] > 0) {\n            releaseRegister(inst->warp_id(), inst->out[r]);\n        }\n    }\n}\n\n// It can be seen that in this function, there is no ready or pending status. Only bookkeeping.\n// Unmark register as write-pending\nvoid Scoreboard::releaseRegister(unsigned wid, unsigned regnum) \n{\n      reg_table[wid].erase(regnum);\n}\n\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br"),n("span",{staticClass:"line-number"},[s._v("22")]),n("br"),n("span",{staticClass:"line-number"},[s._v("23")]),n("br"),n("span",{staticClass:"line-number"},[s._v("24")]),n("br"),n("span",{staticClass:"line-number"},[s._v("25")]),n("br"),n("span",{staticClass:"line-number"},[s._v("26")]),n("br"),n("span",{staticClass:"line-number"},[s._v("27")]),n("br"),n("span",{staticClass:"line-number"},[s._v("28")]),n("br"),n("span",{staticClass:"line-number"},[s._v("29")]),n("br")])])]),s._v(" "),n("p",[s._v("So the scoreboard will maintains all pending registers. Once it is written back, the register will be released.")]),s._v(" "),n("p",[s._v("If another instruction is about to issue, it will check whether the register it reads or writes matches with any of the registes.\n")]),n("details",[n("summary",[s._v("Code")]),n("p"),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("/** \n * Checks to see if registers used by an instruction are reserved in the scoreboard\n *  \n * @return \n * true if WAW or RAW hazard (no WAR since in-order issue)\n **/ \nbool Scoreboard::checkCollision( unsigned wid, const class inst_t *inst ) const\n{\n\t// Get list of all input and output registers\n\tstd::set<int> inst_regs;\n\n\t// from 0 to 3\n\tif(inst->out[0] > 0) inst_regs.insert(inst->out[0]);\n\n\t// from 0 to 3\n\tif(inst->in[0] > 0) inst_regs.insert(inst->in[0]);\n\n\tif(inst->pred > 0) inst_regs.insert(inst->pred);\n\tif(inst->ar1 > 0) inst_regs.insert(inst->ar1);\n\tif(inst->ar2 > 0) inst_regs.insert(inst->ar2);\n\n\t// Check for collision, get the intersection of reserved registers and instruction registers\n\tstd::set<int>::const_iterator it2;\n\tfor ( it2=inst_regs.begin() ; it2 != inst_regs.end(); it2++ )\n\t\tif(reg_table[wid].find(*it2) != reg_table[wid].end()) {\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br"),n("span",{staticClass:"line-number"},[s._v("22")]),n("br"),n("span",{staticClass:"line-number"},[s._v("23")]),n("br"),n("span",{staticClass:"line-number"},[s._v("24")]),n("br"),n("span",{staticClass:"line-number"},[s._v("25")]),n("br"),n("span",{staticClass:"line-number"},[s._v("26")]),n("br"),n("span",{staticClass:"line-number"},[s._v("27")]),n("br"),n("span",{staticClass:"line-number"},[s._v("28")]),n("br"),n("span",{staticClass:"line-number"},[s._v("29")]),n("br"),n("span",{staticClass:"line-number"},[s._v("30")]),n("br")])])]),s._v(" "),n("h4",{attrs:{id:"function-gpu-mode"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#function-gpu-mode"}},[s._v("#")]),s._v(" Function GPU Mode")]),s._v(" "),n("p",[n("a",{attrs:{href:"https://hitqshao.github.io/qishao-notes/pages/458725/",target:"_blank",rel:"noopener noreferrer"}},[s._v("function mode"),n("OutboundLink")],1),s._v(" is described in previous blog.")])])}),[],!1,null,null,null);n.default=a.exports}}]);
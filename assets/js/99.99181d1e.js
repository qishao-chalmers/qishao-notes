(window.webpackJsonp=window.webpackJsonp||[]).push([[99],{554:function(e,t,i){"use strict";i.r(t);var a=i(8),n=Object(a.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("ol",[t("li",[e._v("[UnRead 2] A Comprehensive Study on Quantization Techniques for Large Language Models :+1Ôºö")]),e._v(" "),t("li",[e._v("[UnRead 11] A Comprehensive Evaluation of Quantization Strategies for Large Language Models üëç üëç")]),e._v(" "),t("li",[e._v("[139] Understanding and Overcoming the Challenges of Efficient Transformer Quantization")]),e._v(" "),t("li",[e._v("[43] Integer or Floating Point? New Outlooks for Low-Bit Quantization on Large Language Models")]),e._v(" "),t("li",[e._v("[26] FP8-LM: Training FP8 Large Language Models üëç üëç üëç from Microsoft "),t("br"),e._v(" "),t("em",[e._v("This is discussed that first order in adam could be FP8, but second order in adam should be FP16. and the weight should be reserved a copy of FP32 full-precision or FP16 with tensor scaling..")])]),e._v(" "),t("li",[e._v("[139] FP8 Formats for Deep Learning")]),e._v(" "),t("li",[e._v("[41] With Shared Microexponents, A Little Shifting Goes a Long Way üëç from Meta, Microsoft üëç")]),e._v(" "),t("li",[e._v("[34] Stable and low-precision training for large-scale vision-language models üëç "),t("br"),e._v(" "),t("em",[e._v("mentioned in Deepseek paper mixed precision training section. Not read yet.")])]),e._v(" "),t("li",[e._v("[Y2025] ParetoQ: Scaling Laws in Extremely Low-bit LLM Quantization")]),e._v(" "),t("li",[e._v("[47] Microscaling Data Formats for Deep Learning")]),e._v(" "),t("li",[e._v("[Unread 2 Y2024] To FP8 and Back Again: Quantifying the Effects of Reducing Precision on LLM Training Stability")]),e._v(" "),t("li",[e._v("[145] Efficient 8-Bit Quantization of Transformer Neural Machine Language Translation Model")]),e._v(" "),t("li",[e._v("[Unread 27]Dynamic Memory Compression: Retrofitting LLMs for Accelerated Inference")]),e._v(" "),t("li",[e._v("[45] PB-LLM: Partially Binarized Large Language Models")]),e._v(" "),t("li",[e._v("[55] QLLM: Accurate and Efficient Low-Bitwidth Quantization for Large Language Models")]),e._v(" "),t("li",[e._v("[33] SpinQuant: LLM quantization with learned rotations")]),e._v(" "),t("li",[e._v("[35] FP8 versus INT8 for efficient deep learning inference")]),e._v(" "),t("li",[e._v("[Y2024]Integer Scale: A Free Lunch for Faster Fine-grained Quantization of LLMs")]),e._v(" "),t("li",[e._v("[434] Integer Quantization for Deep Learning Inference: Principles and Empirical Evaluation")]),e._v(" "),t("li",[e._v("[73] FP8 Quantization: The Power of the Exponent")]),e._v(" "),t("li",[e._v("[UnRead 121] Training High-Performance and Large-Scale Deep Neural Networks with Full 8-bit Integers")]),e._v(" "),t("li",[e._v("[381] I-BERT: Integer-only BERT Quantization")]),e._v(" "),t("li",[e._v("[637] Training Deep Neural Networks with 8-bit Floating Point Numbers")]),e._v(" "),t("li",[e._v("[904] LLM.int8(): 8-bit Matrix Multiplication for Transformers at Scale")]),e._v(" "),t("li",[e._v("[UnRead 2568] DoReFa-Net: Training Low Bitwidth Convolutional Neural Networks with Low Bitwidth Gradients üëç")]),e._v(" "),t("li",[e._v("[239] Model Accuracy and Runtime Tradeoff in Distributed Deep Learning: A Systematic Study üëç")]),e._v(" "),t("li",[e._v("[270] Hybrid 8-bit Floating Point (HFP8) Training and Inference for Deep Neural Networks "),t("br"),e._v(" "),t("em",[e._v("This is the paper where E5M2 and E4M3")])]),e._v(" "),t("li",[e._v("[Read Y2025 NVIDIA] Coat: Compressing Optimizer States and Activation for Memory-Efficient FP8 Training  üëç  üëç  üëç  üëç  üëç "),t("br"),e._v(" "),t("em",[e._v("Source code: https://github.com/NVlabs/COAT")])])]),e._v(" "),t("p",[t("strong",[e._v("Outlier")])]),e._v(" "),t("p",[e._v("1.[106] Outlier Suppression+: Accurate quantization of large language models by equivalent and effective shifting and scaling")]),e._v(" "),t("hr"),e._v(" "),t("h2",{attrs:{id:"_1-139-understanding-and-overcoming-the-challenges-of-efficient-transformer-quantization"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-139-understanding-and-overcoming-the-challenges-of-efficient-transformer-quantization"}},[e._v("#")]),e._v(" 1. [139] Understanding and Overcoming the Challenges of Efficient Transformer Quantization")]),e._v(" "),t("h3",{attrs:{id:"problems"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#problems"}},[e._v("#")]),e._v(" Problems")]),e._v(" "),t("p",[e._v("The problems encountered when attempting to quantize transformer models like BERT, as highlighted in the paper:")]),e._v(" "),t("ul",[t("li",[e._v("High Dynamic Range of Activations\n"),t("ul",[t("li",[e._v("The authors observed that the activation tensors in transformer models, particularly in the residual connections, exhibit a very high dynamic range.")]),e._v(" "),t("li",[e._v("This means that the values within these tensors vary significantly in magnitude.")]),e._v(" "),t("li",[e._v("Quantization, especially when using low-bit fixed-point formats (like 8-bit integer), struggles to accurately represent such a wide range of values.")]),e._v(" "),t("li",[e._v("Trying to capture both very small and very large values within the limited range of a low-bit format inevitably leads to significant quantization errors.")])])]),e._v(" "),t("li",[e._v("Presence of Structured Outliers\n"),t("ul",[t("li",[e._v("The authors identified the presence of structured outliers within the activation tensors, particularly in the residual connections after the feed-forward network (FFN).")]),e._v(" "),t("li",[e._v("These outliers are not random; "),t("strong",[e._v("they appear to be correlated with specific input tokens and embedding dimensions")]),e._v(".")]),e._v(" "),t("li",[e._v("Further analysis revealed that "),t("strong",[e._v("these outliers influence the attention mechanism in the subsequent layers, encouraging the model to attend to specific tokens like the separator token ([SEP])")]),e._v(".")])])])]),e._v(" "),t("blockquote",[t("p",[e._v("In BERT-like models, an intermediate hidden activation tensor x has a shape (B, T, d), where B is the batch size, T is the sequence length, and d is the number of embedding dimensions (d = 768 for BERT-base, Devlin et al. 2019).\nIn the following figure, you could tell the x-axis is in dimension of 768.")])]),e._v(" "),t("p",[t("img",{attrs:{src:"https://github.com/user-attachments/assets/2d6e801d-8e6a-4ebd-8237-a67bb5b7ca95",alt:"image"}})]),e._v(" "),t("ul",[t("li",[e._v("While this attention behavior might be beneficial for the model's performance, the outliers that cause it also create challenges for quantization.")]),e._v(" "),t("li",[e._v("Sensitivity to Quantization Noise\n"),t("ul",[t("li",[e._v("Different parts of the transformer model exhibit varying sensitivities to the noise introduced by quantization.")]),e._v(" "),t("li",[e._v("Some components, like the residual connections and certain attention heads, are particularly sensitive, and quantizing them aggressively can lead to a significant drop in accuracy.")]),e._v(" "),t("li",[e._v("This sensitivity necessitates careful consideration of which parts of the model to quantize and at what bit-width.")])])])]),e._v(" "),t("p",[t("img",{attrs:{src:"https://github.com/user-attachments/assets/520b9b0c-c112-4c49-92a1-03842f41b92d",alt:"image"}})]),e._v(" "),t("h3",{attrs:{id:"solutions"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#solutions"}},[e._v("#")]),e._v(" Solutions")]),e._v(" "),t("p",[e._v("solutions proposed in the paper:")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("Mixed-precision PTQ")]),e._v(" "),t("ul",[t("li",[e._v("The authors observed that different parts of the BERT model have varying sensitivities to quantization noise.")]),e._v(" "),t("li",[e._v("To address this, they proposed using a higher "),t("strong",[e._v("bit-width (16-bit) for the more sensitive activation tensors")]),e._v(", "),t("strong",[e._v("particularly the residual sum after the feed-forward network (FFN)")]),e._v(".")]),e._v(" "),t("li",[e._v("This higher bit-width allows for more accurate representation of both the FFN's input and output, minimizing potential errors.")]),e._v(" "),t("li",[e._v("Additionally, they explored "),t("strong",[e._v("using low-bit (2-4) quantization for weights and token embeddings")]),e._v(", which can significantly reduce model size without much accuracy loss.")])])]),e._v(" "),t("li",[t("p",[e._v("Per-embedding-group PTQ")]),e._v(" "),t("ul",[t("li",[e._v("The authors identified that outliers in the activation tensors "),t("strong",[e._v("primarily reside in a few specific embedding dimensions")]),e._v(".")]),e._v(" "),t("li",[e._v("To address this, they proposed a novel per-embedding-group (PEG) quantization scheme, where distinct quantization parameters are used for different embedding dimensions or groups of dimensions.")]),e._v(" "),t("li",[e._v("This method involves "),t("strong",[e._v("splitting the activation tensor into groups along the embedding dimension and applying separate quantization parameters to each group")]),e._v(".")]),e._v(" "),t("li",[e._v("To optimize this process, they introduced a range-based permutation step to ensure that all outliers are grouped together.")]),e._v(" "),t("li",[e._v("This approach effectively handles outliers without significantly increasing computational overhead.")])])]),e._v(" "),t("li",[t("p",[e._v("Quantization-aware training (QAT)")]),e._v(" "),t("ul",[t("li",[e._v("The authors also explored QAT, where the model is trained with simulated quantization operations.")]),e._v(" "),t("li",[e._v("This allows the model to adapt to the quantization noise, leading to improved performance compared to post-training quantization.")]),e._v(" "),t("li",[e._v("During QAT, they used "),t("strong",[e._v("learnable ranges for both weights and activations")]),e._v(", further enhancing the model's adaptability to quantization.")])])])]),e._v(" "),t("hr"),e._v(" "),t("h2",{attrs:{id:"_2-43-integer-or-floating-point-new-outlooks-for-low-bit-quantization-on-large-language-models"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-43-integer-or-floating-point-new-outlooks-for-low-bit-quantization-on-large-language-models"}},[e._v("#")]),e._v(" 2.[43] Integer or Floating Point? New Outlooks for Low-Bit Quantization on Large Language Models")]),e._v(" "),t("h3",{attrs:{id:"key-takeaways-in-three-sentences"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#key-takeaways-in-three-sentences"}},[e._v("#")]),e._v(" "),t("strong",[e._v("Key Takeaways in Three Sentences")])]),e._v(" "),t("ol",[t("li",[e._v("The study demonstrates that "),t("strong",[e._v("low-bit floating-point formats, particularly FP8, provide superior quantization accuracy for LLMs compared to INT8")]),e._v(" , with comparable hardware efficiency at 8-bit precision.")]),e._v(" "),t("li",[e._v("The "),t("strong",[e._v("Mixture of Formats Quantization (MoFQ) approach optimally selects between INT and FP per layer")]),e._v(" , improving accuracy without increasing computational overhead.")]),e._v(" "),t("li",[e._v("MoFQ achieves "),t("strong",[e._v("state-of-the-art results in both W4-only and W8A8 quantization")]),e._v(" , outperforming existing methods like GPTQ, AWQ, LLM.int8(), and SmoothQuant while maintaining "),t("strong",[e._v("efficient inference speed")]),e._v(" .")])]),e._v(" "),t("h3",{attrs:{id:"abstract"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#abstract"}},[e._v("#")]),e._v(" "),t("strong",[e._v("Abstract")])]),e._v(" "),t("p",[e._v("The study finds that optimal quantization formats vary across layers in LLMs, leading to the "),t("strong",[e._v("Mixture of Formats Quantization (MoFQ)")]),e._v("  approach, which selects the best format per layer."),t("br"),e._v("\nMoFQ achieves superior or comparable performance to current quantization methods for weight-only (W-only) and weight-activation (WA) quantization without additional hardware overhead.")]),e._v(" "),t("h3",{attrs:{id:"introduction"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#introduction"}},[e._v("#")]),e._v(" "),t("strong",[e._v("Introduction")])]),e._v(" "),t("p",[e._v("Quantization minimizes LLMs' size and inference costs, with prior work focusing on low-bit integer formats."),t("br"),e._v("\nHowever, as LLMs grow, integer quantization becomes less effective, requiring optimizations or alternatives. Low-bit floating-point formats have emerged as viable alternatives, with FP8 already supported in NVIDIA‚Äôs H100 GPUs.")]),e._v(" "),t("p",[e._v("The study:")]),e._v(" "),t("ol",[t("li",[e._v("Compares INT and FP formats in terms of hardware efficiency and quantization error.")]),e._v(" "),t("li",[e._v("Proposes "),t("strong",[e._v("Mixture of Formats Quantization (MoFQ)")]),e._v(" , selecting the best format per layer.")]),e._v(" "),t("li",[e._v("Implements an inference system for W-only quantization, maintaining performance parity with INT-based systems.")])]),e._v(" "),t("h3",{attrs:{id:"background-and-related-works"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#background-and-related-works"}},[e._v("#")]),e._v(" "),t("strong",[e._v("Background and Related Works")])]),e._v(" "),t("p",[t("strong",[e._v("Integer vs. Floating-Point Formats")])]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("Integer (INT)")]),e._v(" : Uniformly distributed values.")]),e._v(" "),t("li",[t("strong",[e._v("Floating-Point (FP)")]),e._v(" : Non-uniform distribution, allowing higher precision for small values but reduced precision for large values.")]),e._v(" "),t("li",[t("strong",[e._v("Hardware efficiency")]),e._v(" : FP operations typically cost more than INT, but at 8-bit, FP8 and INT8 MAC (Multiply-Accumulate) units have nearly identical area costs.")])]),e._v(" "),t("p",[t("strong",[e._v("Post-Training Quantization (PTQ) for LLMs")])]),e._v(" "),t("p",[e._v("Two main PTQ strategies:")]),e._v(" "),t("ol",[t("li",[t("strong",[e._v("Weight-Only (W-only) Quantization:")]),e._v("  Applies to weights only, e.g., W4A16.")]),e._v(" "),t("li",[t("strong",[e._v("Weight-Activation (WA) Quantization:")]),e._v("  Quantizes both weights and activations, e.g., W8A8.")])]),e._v(" "),t("p",[e._v("State-of-the-art (SOTA) methods:")]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("LLM.int8()")]),e._v(" : Uses mixed precision (INT8+FP16).")]),e._v(" "),t("li",[t("strong",[e._v("SmoothQuant")]),e._v(" : Redistributes quantization difficulty from activations to weights.")]),e._v(" "),t("li",[t("strong",[e._v("GPTQ & AWQ")]),e._v(" : Use second-order information and pre-scaling techniques to improve quantization.")])]),e._v(" "),t("h3",{attrs:{id:"comparative-analysis-of-int-and-fp-formats"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#comparative-analysis-of-int-and-fp-formats"}},[e._v("#")]),e._v(" "),t("strong",[e._v("Comparative Analysis of INT and FP Formats")])]),e._v(" "),t("p",[t("strong",[e._v("A. Hardware Cost of INT vs. FP MAC Units")])]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("At 8-bit precision, FP8 and INT8 MACs require nearly the same hardware area")]),e._v(" , aligning with H100 GPU capabilities.")])]),e._v(" "),t("p",[t("strong",[e._v("B. Quantization Error Comparison")])]),e._v(" "),t("ol",[t("li",[t("strong",[e._v("4-bit Weight-Only (W4) Quantization")]),e._v("  (LLaMA-65B model):")])]),e._v(" "),t("ul",[t("li",[e._v("üî• Some layers perform better with INT4, while others favor FP4, indicating "),t("strong",[e._v("layer-dependent format preference")]),e._v(" .")])]),e._v(" "),t("p",[t("img",{attrs:{src:"https://github.com/user-attachments/assets/97be028e-fdb3-4883-a92e-b784d1ff1f87",alt:"image"}})]),e._v(" "),t("ol",{attrs:{start:"2"}},[t("li",[t("strong",[e._v("8-bit Weight-Activation (W8A8) Quantization")]),e._v(" :")])]),e._v(" "),t("ul",[t("li",[e._v("üî•"),t("strong",[e._v("Weights")]),e._v(" : INT8 generally has lower quantization error.")]),e._v(" "),t("li",[e._v("üî•"),t("strong",[e._v("Activations")]),e._v(" : FP8 shows "),t("strong",[e._v("better robustness")]),e._v("  for dynamic activation tensors.")]),e._v(" "),t("li",[e._v("Best choice: INT8 for weights, FP8 for activations‚Äîbut hardware constraints necessitate using the same format per layer.")])]),e._v(" "),t("p",[t("img",{attrs:{src:"https://github.com/user-attachments/assets/7af41adf-5821-4c0b-8599-1385c1982c87",alt:"image"}})]),e._v(" "),t("h3",{attrs:{id:"exploiting-int-and-fp-complementarity"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#exploiting-int-and-fp-complementarity"}},[e._v("#")]),e._v(" "),t("strong",[e._v("Exploiting INT and FP Complementarity")])]),e._v(" "),t("p",[t("strong",[e._v("A. Improved Low-Bit FP4 Format")])]),e._v(" "),t("ul",[t("li",[e._v("IEEE floating-point format reserves exponent values for NaN and Inf.")]),e._v(" "),t("li",[t("strong",[e._v("Reallocating NaN & Inf to normalized numbers improves FP4 precision")]),e._v("  by 35%.")])]),e._v(" "),t("p",[t("strong",[e._v("B. Mixture of Formats Quantization (MoFQ)")])]),e._v(" "),t("ul",[t("li",[e._v("Selects the best quantization format (INT or FP) "),t("strong",[e._v("per layer")]),e._v("  based on quantization error.")]),e._v(" "),t("li",[e._v("Works for both "),t("strong",[e._v("W-only and WA quantization")]),e._v(" .")]),e._v(" "),t("li",[t("strong",[e._v("Algorithm")]),e._v(" : Iterates through layers, computes quantization error for INT and FP, and selects the lower-error format.")])]),e._v(" "),t("p",[t("strong",[e._v("C. Low-Bit W-Only Inference System")])]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("INT4 and FP4 require conversion to FP16 before computation")]),e._v("  due to FP16 activations.")]),e._v(" "),t("li",[t("strong",[e._v("W8A8 quantization")]),e._v(" : FP16 activations are converted to FP8 or INT8 based on next-layer format selection.")]),e._v(" "),t("li",[t("strong",[e._v("No additional hardware overhead for FP-based or MoFQ-based inference")]),e._v("  compared to INT-based quantization.")])]),e._v(" "),t("p",[t("img",{attrs:{src:"https://github.com/user-attachments/assets/7d5e0e92-deda-4e40-8775-b428fff2ca0c",alt:"image"}})]),e._v(" "),t("h3",{attrs:{id:"conclusion"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#conclusion"}},[e._v("#")]),e._v(" "),t("strong",[e._v("Conclusion")])]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("Comparative study")]),e._v(" : INT and FP formats have complementary strengths.")]),e._v(" "),t("li",[t("strong",[e._v("Key finding")]),e._v(" : "),t("strong",[e._v("FP8 and INT8 MAC units have similar hardware costs at low-bit quantization")]),e._v(" .")]),e._v(" "),t("li",[t("strong",[e._v("MoFQ method")]),e._v(" :\n"),t("ul",[t("li",[e._v("Selects the best quantization format "),t("strong",[e._v("per layer")]),e._v(" .")]),e._v(" "),t("li",[t("strong",[e._v("Achieves state-of-the-art accuracy")]),e._v("  in W4-only and W8A8 quantization.")]),e._v(" "),t("li",[t("strong",[e._v("No additional inference latency or hardware overhead")]),e._v(" .")])])])]),e._v(" "),t("hr"),e._v(" "),t("h2",{attrs:{id:"_5-26-fp8-lm-training-fp8-large-language-models"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-26-fp8-lm-training-fp8-large-language-models"}},[e._v("#")]),e._v(" 5. [26] FP8-LM: Training FP8 Large Language Models")]),e._v(" "),t("h3",{attrs:{id:"abstract-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#abstract-2"}},[e._v("#")]),e._v(" "),t("strong",[e._v("Abstract")])]),e._v(" "),t("p",[e._v("The paper explores "),t("strong",[e._v("FP8 low-bit data formats")]),e._v("  for training large language models (LLMs), significantly reducing "),t("strong",[e._v("memory usage and computation costs")]),e._v("  while maintaining accuracy.")]),e._v(" "),t("p",[e._v("The authors introduce an "),t("strong",[e._v("FP8 automatic mixed-precision training framework")]),e._v("  with three levels of FP8 utilization, improving mixed-precision and distributed parallel training.")]),e._v(" "),t("p",[t("strong",[e._v("Key results")]),e._v("  show that training the "),t("strong",[e._v("GPT-175B model on an H100 GPU platform")]),e._v("  using FP8:")]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("Reduces memory usage by 39%")])]),e._v(" "),t("li",[t("strong",[e._v("Speeds up training by 75% compared to BF16 (Megatron-LM)")])]),e._v(" "),t("li",[t("strong",[e._v("Outperforms Nvidia Transformer Engine by 37%")])])]),e._v(" "),t("p",[e._v("The "),t("strong",[e._v("FP8 training methodology is generalizable")]),e._v("  to fine-tuning, instruction tuning, and reinforcement learning with human feedback (RLHF). The framework is "),t("strong",[e._v("open-sourced")]),e._v("  at "),t("a",{attrs:{href:"https://github.com/Azure/MS-AMP",target:"_blank",rel:"noopener noreferrer"}},[e._v("aka.ms/MS.AMP"),t("OutboundLink")],1),e._v(" .")]),e._v(" "),t("h3",{attrs:{id:"_1-introduction"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-introduction"}},[e._v("#")]),e._v(" "),t("strong",[e._v("1. Introduction")])]),e._v(" "),t("p",[e._v("LLMs have demonstrated exceptional performance in various domains but are extremely expensive to train."),t("br"),e._v("\nThe cost of training models like "),t("strong",[e._v("GPT-3 (175B) or PaLM (540B)")]),e._v("  is enormous, requiring "),t("strong",[e._v("thousands of GPUs or TPUs")]),e._v(" ."),t("br"),e._v("\nLow-precision training is a "),t("strong",[e._v("promising solution")]),e._v("  as it:")]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("Increases speed")])]),e._v(" "),t("li",[t("strong",[e._v("Reduces memory usage")])]),e._v(" "),t("li",[t("strong",[e._v("Minimizes communication overhead")])])]),e._v(" "),t("p",[e._v("Most existing frameworks, such as "),t("strong",[e._v("Megatron-LM, MetaSeq, and Colossal-AI")]),e._v(" , use "),t("strong",[e._v("FP32, FP16, or BF16 mixed-precision training")]),e._v(" , but "),t("strong",[e._v("FP8 offers significant efficiency gains")]),e._v(" :")]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("2√ó speed-up")])]),e._v(" "),t("li",[t("strong",[e._v("50%-75% memory and communication savings")])])]),e._v(" "),t("h4",{attrs:{id:"challenges-of-fp8-training"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#challenges-of-fp8-training"}},[e._v("#")]),e._v(" "),t("strong",[e._v("Challenges of FP8 Training")])]),e._v(" "),t("ol",[t("li",[t("strong",[e._v("Data underflow/overflow issues")]),e._v("  due to FP8‚Äôs limited dynamic range.")]),e._v(" "),t("li",[t("strong",[e._v("Numerical instabilities and divergence")]),e._v("  during training.")])]),e._v(" "),t("h4",{attrs:{id:"proposed-fp8-mixed-precision-framework"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#proposed-fp8-mixed-precision-framework"}},[e._v("#")]),e._v(" "),t("strong",[e._v("Proposed FP8 Mixed-Precision Framework")])]),e._v(" "),t("ul",[t("li",[e._v("Introduces "),t("strong",[e._v("three levels of FP8 utilization")]),e._v("  (gradients, optimizer states, and distributed learning).")]),e._v(" "),t("li",[e._v("Uses "),t("strong",[e._v("precision decoupling")]),e._v("  and "),t("strong",[e._v("automatic scaling")]),e._v("  to mitigate numerical instability.")]),e._v(" "),t("li",[e._v("Achieves "),t("strong",[e._v("29%-39% memory savings")]),e._v("  and "),t("strong",[e._v("63%-65% communication cost reductions")]),e._v(" .")])]),e._v(" "),t("blockquote",[t("p",[e._v("The resulting FP8 mixed-precision networks are more efficient than their pure FP16 counterparts, but a network that is in full INT8 is expected to be significantly more efficient yet.")])]),e._v(" "),t("h3",{attrs:{id:"_2-fp8-llm-training"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-fp8-llm-training"}},[e._v("#")]),e._v(" "),t("strong",[e._v("2. FP8 LLM Training")])]),e._v(" "),t("h4",{attrs:{id:"_2-1-fp8-gradient-and-all-reduce-communication"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-fp8-gradient-and-all-reduce-communication"}},[e._v("#")]),e._v(" "),t("strong",[e._v("2.1 FP8 Gradient and All-Reduce Communication")])]),e._v(" "),t("ul",[t("li",[e._v("Traditional mixed-precision training uses "),t("strong",[e._v("FP16/FP32 for gradients")]),e._v(" , leading to high communication costs.")]),e._v(" "),t("li",[e._v("Applying "),t("strong",[e._v("FP8 directly to gradients")]),e._v("  results in "),t("strong",[e._v("loss of accuracy")]),e._v("  due to underflow/overflow.")]),e._v(" "),t("li",[e._v("The paper proposes an "),t("strong",[e._v("automatic scaling technique")]),e._v("  to adapt scaling factors dynamically, preventing numerical instability.")])]),e._v(" "),t("h4",{attrs:{id:"_2-2-fp8-optimizer"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-fp8-optimizer"}},[e._v("#")]),e._v(" "),t("strong",[e._v("2.2 FP8 Optimizer")])]),e._v(" "),t("ul",[t("li",[e._v("The "),t("strong",[e._v("Adam optimizer")]),e._v("  typically consumes "),t("strong",[e._v("16 bytes per parameter")]),e._v("  due to high-precision storage of gradients and optimizer states.")]),e._v(" "),t("li",[e._v("The proposed "),t("strong",[e._v("FP8 optimizer")]),e._v("  stores:\n"),t("ul",[t("li",[e._v("FP8 first-order moment")]),e._v(" "),t("li",[e._v("FP16 master weights (with tensor scaling)")]),e._v(" "),t("li",[e._v("FP16 second-order moment")])])]),e._v(" "),t("li",[e._v("This reduces "),t("strong",[e._v("memory consumption from 16 bytes to 6 bytes per parameter")]),e._v("  (2.6√ó savings).")])]),e._v(" "),t("blockquote",[t("p",[e._v("My main takeaway is that direction of gradient matters, instead of magnitude.")])]),e._v(" "),t("p",[t("img",{attrs:{src:"https://github.com/user-attachments/assets/aa8bdd9a-c5ea-4910-bfdf-836eca32f9b5",alt:"image"}})]),e._v(" "),t("ol",[t("li",[e._v("FP8 master weight induces performance degradation (see the #2a vs. #3 lines in Fig. 8), while FP16 can maintain accuracy as FP32 (see #2a vs. #0 and #1) but requiring using tensor scaling.\nIt reveals that the master weight is precision-sensitive.\nThis can be attributed to "),t("strong",[e._v("the master weight‚Äôs")]),e._v(" role in updating weights, which tend to exhibit small magnitudes, necessitating high precision to maintain accuracy.")]),e._v(" "),t("li",[e._v("The training loss of "),t("strong",[e._v("BF16")]),e._v(" master weight is "),t("strong",[e._v("slightly higher")]),e._v(" than that of FP16 with a scaling factor because BF16 has fewer mantissa bits, resulting in lower precision (see #2a vs. #2b).")]),e._v(" "),t("li",[e._v("‚ùó The second-order gradient moment is more precision-sensitive than the first-order one, because the ‚ùósquare calculation is easy to cause underflow and leads to accuracy degradation.\nUtilizing FP8 for the second-order gradient moment can lead to divergent training loss (see the #4 dot in Fig. 8).")])]),e._v(" "),t("p",[e._v("Please Notice that FP8 #4 is diverged, not shown in the figure.")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://github.com/user-attachments/assets/127e6274-629c-4f40-81f7-57cbb1ce9d98",alt:"image"}})]),e._v(" "),t("h4",{attrs:{id:"_2-3-fp8-distributed-parallel-training"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-fp8-distributed-parallel-training"}},[e._v("#")]),e._v(" "),t("strong",[e._v("2.3 FP8 Distributed Parallel Training")])]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("Tensor Parallelism")]),e._v(" : Uses "),t("strong",[e._v("FP8 for weight and activation tensors")]),e._v(" , reducing compute and communication overhead.")]),e._v(" "),t("li",[t("strong",[e._v("Sequence Parallelism")]),e._v(" : Converts activation tensors to "),t("strong",[e._v("FP8 before communication")]),e._v(" , reducing costs.")]),e._v(" "),t("li",[t("strong",[e._v("ZeRO (Zero Redundancy Optimizer) Support")]),e._v(" : Distributes "),t("strong",[e._v("full tensors")]),e._v("  across devices while preserving "),t("strong",[e._v("FP8 scaling factors")]),e._v(" .")])]),e._v(" "),t("h3",{attrs:{id:"_3-experimentation"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-experimentation"}},[e._v("#")]),e._v(" "),t("strong",[e._v("3. Experimentation")])]),e._v(" "),t("h4",{attrs:{id:"_3-1-experimental-setup"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-experimental-setup"}},[e._v("#")]),e._v(" "),t("strong",[e._v("3.1 Experimental Setup")])]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("Training Dataset")]),e._v(" : Collected from "),t("strong",[e._v("CommonCrawl, The Pile, C4, OpenWebText, Wikipedia, RedPajama")]),e._v(" , and other curated sources.")]),e._v(" "),t("li",[t("strong",[e._v("Model Configuration")]),e._v(" : Uses a "),t("strong",[e._v("decoder-only Transformer")]),e._v("  architecture (like GPT-3), with "),t("strong",[e._v("RoPE embeddings and Flash Attention")]),e._v(" .")])]),e._v(" "),t("h4",{attrs:{id:"_3-2-main-results"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-main-results"}},[e._v("#")]),e._v(" "),t("strong",[e._v("3.2 Main Results")])]),e._v(" "),t("h5",{attrs:{id:"model-performance"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#model-performance"}},[e._v("#")]),e._v(" "),t("strong",[e._v("Model Performance")])]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("Loss curves of FP8 models match BF16 models")]),e._v(" , confirming "),t("strong",[e._v("accuracy preservation")])]),e._v(" "),t("li",[t("strong",[e._v("Zero-shot evaluations")]),e._v("  on "),t("strong",[e._v("Lambada, HellaSwag, BoolQ, PIQA, COPA")]),e._v("  show "),t("strong",[e._v("comparable performance between FP8 and BF16")]),e._v(" .")]),e._v(" "),t("li",[t("strong",[e._v("Fine-tuning (SFT & RLHF)")]),e._v(" : FP8 achieves:\n"),t("ul",[t("li",[e._v("27% faster fine-tuning")]),e._v(" "),t("li",[e._v("32% reduction in model weight memory")]),e._v(" "),t("li",[e._v("62% optimizer state memory savings")])])])]),e._v(" "),t("p",[t("strong",[e._v("System Performance")])]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("Memory reduction")]),e._v(" : FP8 achieves "),t("strong",[e._v("28%-39% lower memory usage")]),e._v("  than BF16.")]),e._v(" "),t("li",[t("strong",[e._v("Training speed improvement")]),e._v(" :\n"),t("ul",[t("li",[e._v("75% faster training for GPT-175B")]),e._v(" "),t("li",[e._v("37% faster than Nvidia Transformer Engine")])])]),e._v(" "),t("li",[t("strong",[e._v("Communication efficiency")]),e._v(" :\n"),t("ul",[t("li",[e._v("63%-65% reduction in weight gradient communication")]),e._v(" "),t("li",[e._v("34% lower activation-related communication costs")])])])]),e._v(" "),t("h4",{attrs:{id:"_3-3-ablation-study"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-ablation-study"}},[e._v("#")]),e._v(" "),t("strong",[e._v("3.3 Ablation Study")])]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("Gradient Scaling")]),e._v(" : "),t("strong",[e._v("Automatic scaling")]),e._v("  reduces "),t("strong",[e._v("underflow/overflow errors")]),e._v(" , improving training stability.")]),e._v(" "),t("li",[t("strong",[e._v("Optimizer Precision")]),e._v(" :\n"),t("ul",[t("li",[e._v("FP16 master weights outperform FP8 master weights in accuracy preservation.")]),e._v(" "),t("li",[e._v("FP8 first-order gradient moment is viable, but FP8 second-order moment leads to divergence.")])])]),e._v(" "),t("li",[t("strong",[e._v("Parallelism Optimization")]),e._v(" :\n"),t("ul",[t("li",[t("strong",[e._v("FP8 sequence and tensor parallelism")]),e._v("  reduce communication costs by "),t("strong",[e._v("34%")]),e._v(" .")]),e._v(" "),t("li",[t("strong",[e._v("FP8 ZeRO")]),e._v("  maintains a balanced GPU memory load while saving memory.")])])])]),e._v(" "),t("h3",{attrs:{id:"_4-related-work"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-related-work"}},[e._v("#")]),e._v(" "),t("strong",[e._v("4. Related Work")])]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("Mixed-Precision Training")]),e._v(" : Prior work focused on "),t("strong",[e._v("FP16/BF16")]),e._v(" , but "),t("strong",[e._v("FP8 remains underexplored")]),e._v(" .")]),e._v(" "),t("li",[t("strong",[e._v("Low-Precision LLM Training")]),e._v(" :\n"),t("ul",[t("li",[t("strong",[e._v("OPT, Bloom, Gopher, Chinchilla")]),e._v("  used "),t("strong",[e._v("BF16")]),e._v("  for better numerical stability.")]),e._v(" "),t("li",[e._v("FP8 support was limited before Nvidia Hopper GPUs.")]),e._v(" "),t("li",[e._v("This work provides the "),t("strong",[e._v("first systematic FP8 training framework")]),e._v("  for "),t("strong",[e._v("pre-training and fine-tuning LLMs")]),e._v(" .")])])])]),e._v(" "),t("h3",{attrs:{id:"_5-conclusion"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-conclusion"}},[e._v("#")]),e._v(" "),t("strong",[e._v("5. Conclusion")])]),e._v(" "),t("ul",[t("li",[e._v("Introduces a "),t("strong",[e._v("new FP8 mixed-precision training framework")]),e._v("  with "),t("strong",[e._v("automatic scaling")]),e._v("  and "),t("strong",[e._v("precision decoupling")]),e._v(" .")]),e._v(" "),t("li",[e._v("Achieves "),t("strong",[e._v("significant reductions in memory, compute, and communication costs")]),e._v(" .")]),e._v(" "),t("li",[t("strong",[e._v("Maintains model accuracy")]),e._v("  across "),t("strong",[e._v("GPT models from 125M to 175B parameters")]),e._v(" .")]),e._v(" "),t("li",[e._v("Demonstrates "),t("strong",[e._v("versatility")]),e._v("  in pre-training, instruction tuning, and RLHF.")]),e._v(" "),t("li",[t("strong",[e._v("Future work")]),e._v("  includes scaling to even larger models, training multi-modal models, and deploying FP8 LLMs on edge devices.")])]),e._v(" "),t("h3",{attrs:{id:"key-summary-in-3-sentences"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#key-summary-in-3-sentences"}},[e._v("#")]),e._v(" "),t("em",[e._v("Key Summary in 3 Sentences")]),e._v("*")]),e._v(" "),t("p",[e._v("This paper introduces an "),t("strong",[e._v("FP8 mixed-precision training framework")]),e._v("  that reduces memory consumption by "),t("strong",[e._v("39%")]),e._v(" , speeds up training by "),t("strong",[e._v("75%")]),e._v(" , and "),t("strong",[e._v("outperforms Nvidia Transformer Engine by 37%")]),e._v("  while maintaining LLM accuracy."),t("br"),e._v("\nThe framework uses "),t("strong",[e._v("automatic scaling and precision decoupling")]),e._v("  to stabilize training, supports "),t("strong",[e._v("FP8 optimizers and distributed training")]),e._v(" , and generalizes to "),t("strong",[e._v("fine-tuning and reinforcement learning with human feedback (RLHF)")]),e._v(" ."),t("br"),e._v("\nThese findings establish "),t("strong",[e._v("FP8 as the next-generation precision format for training LLMs")]),e._v(" , significantly lowering costs while preserving model performance.")]),e._v(" "),t("hr"),e._v(" "),t("h2",{attrs:{id:"_6-139-fp8-formats-for-deep-learning"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-139-fp8-formats-for-deep-learning"}},[e._v("#")]),e._v(" 6. [139] FP8 Formats for Deep Learning")]),e._v(" "),t("h3",{attrs:{id:"_1-introduction-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-introduction-2"}},[e._v("#")]),e._v(" "),t("strong",[e._v("1. Introduction")])]),e._v(" "),t("p",[e._v("Deep learning models require increasing computational resources, necessitating lower-precision formats for efficiency.")]),e._v(" "),t("p",[e._v("FP8 is a "),t("strong",[e._v("natural evolution")]),e._v("  from FP16 and BF16, reducing "),t("strong",[e._v("compute and memory costs")]),e._v("  while maintaining "),t("strong",[e._v("accuracy comparable to FP16")]),e._v(" .")]),e._v(" "),t("h3",{attrs:{id:"key-contributions"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#key-contributions"}},[e._v("#")]),e._v(" Key contributions:")]),e._v(" "),t("ul",[t("li",[t("p",[t("strong",[e._v("Two FP8 formats:")])]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("E4M3")]),e._v(" : 4-bit exponent, 3-bit mantissa (for weights and activations).")]),e._v(" "),t("li",[t("strong",[e._v("E5M2")]),e._v(" : 5-bit exponent, 2-bit mantissa (for gradients).")])])]),e._v(" "),t("li",[t("p",[t("strong",[e._v("Training and inference in FP8")]),e._v("  match FP16/BF16 accuracy across CNNs, RNNs, and Transformers.")])]),e._v(" "),t("li",[t("p",[t("strong",[e._v("Post-training quantization (PTQ)")]),e._v("  using FP8 "),t("strong",[e._v("outperforms int8")]),e._v("  while preserving model accuracy.")])])]),e._v(" "),t("h3",{attrs:{id:"_2-aspects-of-fp8-usage-in-deep-learning"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-aspects-of-fp8-usage-in-deep-learning"}},[e._v("#")]),e._v(" "),t("strong",[e._v("2. Aspects of FP8 Usage in Deep Learning")])]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("FP8 computations")]),e._v("  will be performed in "),t("strong",[e._v("higher precision (FP16/FP32)")]),e._v(" , with final results cast back to FP8.")]),e._v(" "),t("li",[t("strong",[e._v("Scaling factors")]),e._v("  are applied to "),t("strong",[e._v("optimize FP8 precision")]),e._v(" , similar to "),t("strong",[e._v("loss-scaling in FP16 mixed precision")]),e._v(" .")]),e._v(" "),t("li",[t("strong",[e._v("Handling of special values (NaNs, Infs) is modified in E4M3")]),e._v("  to increase dynamic range.")])]),e._v(" "),t("h3",{attrs:{id:"_3-fp8-binary-interchange-format"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-fp8-binary-interchange-format"}},[e._v("#")]),e._v(" "),t("strong",[e._v("3. FP8 Binary Interchange Format")])]),e._v(" "),t("p",[t("img",{attrs:{src:"https://github.com/user-attachments/assets/dc054ba5-6892-4c63-888e-ef24c9789d8a",alt:"image"}})]),e._v(" "),t("p",[e._v("FP8 includes "),t("strong",[e._v("two encodings")]),e._v(" :")]),e._v(" "),t("ul",[t("li",[t("p",[t("strong",[e._v("E4M3")]),e._v(" :")]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("Used for weights and activations")]),e._v(" .")]),e._v(" "),t("li",[t("strong",[e._v("No representation for infinities")]),e._v("  (max value: "),t("strong",[e._v("448")]),e._v(" ).")]),e._v(" "),t("li",[t("strong",[e._v("Single NaN representation to extend range")]),e._v(" .")])])]),e._v(" "),t("li",[t("p",[t("strong",[e._v("E5M2")]),e._v(" :")]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("Used for gradients")]),e._v(" .")]),e._v(" "),t("li",[t("strong",[e._v("Standard IEEE-like format")]),e._v(" , supporting "),t("strong",[e._v("NaNs and infinities")]),e._v(" .")]),e._v(" "),t("li",[e._v("Larger range (up to "),t("strong",[e._v("57,344")]),e._v(" ).")])])])]),e._v(" "),t("p",[t("img",{attrs:{src:"https://github.com/user-attachments/assets/ac2dbf07-fd59-4902-a55b-0bb4b0385408",alt:"image"}})]),e._v(" "),t("h4",{attrs:{id:"_3-1-special-value-representations"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-special-value-representations"}},[e._v("#")]),e._v(" "),t("strong",[e._v("3.1 Special Value Representations")])]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("E4M3 removes infinities")]),e._v("  and limits NaNs to a "),t("strong",[e._v("single pattern")]),e._v(" , extending its "),t("strong",[e._v("dynamic range")]),e._v(" .")]),e._v(" "),t("li",[t("strong",[e._v("E5M2 follows IEEE-754")]),e._v(" , allowing "),t("strong",[e._v("straightforward conversion from FP16")]),e._v(" .")])]),e._v(" "),t("h4",{attrs:{id:"_3-2-exponent-bias"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-exponent-bias"}},[e._v("#")]),e._v(" "),t("strong",[e._v("3.2 Exponent Bias")])]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("E4M3 bias = 7, E5M2 bias = 15")]),e._v("  (matching IEEE-style representation).")]),e._v(" "),t("li",[e._v("Some models require "),t("strong",[e._v("per-tensor scaling")]),e._v("  rather than a fixed exponent bias (Figure 2).")])]),e._v(" "),t("h3",{attrs:{id:"_4-empirical-results"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-empirical-results"}},[e._v("#")]),e._v(" "),t("strong",[e._v("4. Empirical Results")])]),e._v(" "),t("h4",{attrs:{id:"_4-1-training"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-training"}},[e._v("#")]),e._v(" "),t("strong",[e._v("4.1 Training")])]),e._v(" "),t("ul",[t("li",[e._v("FP8 training achieves "),t("strong",[e._v("accuracy comparable to FP16/BF16")]),e._v("  across CNNs, RNNs, and Transformers.")]),e._v(" "),t("li",[t("strong",[e._v("Image Classification")]),e._v(" :\n"),t("ul",[t("li",[e._v("FP8 accuracy is "),t("strong",[e._v("within statistical variation")]),e._v("  of FP16 for most CNNs (ResNet, MobileNet, VGG, etc.).")])])]),e._v(" "),t("li",[t("strong",[e._v("Language Translation")]),e._v(" :\n"),t("ul",[t("li",[e._v("FP8 BLEU scores "),t("strong",[e._v("match FP16")]),e._v("  for Transformer and GNMT models.")])])]),e._v(" "),t("li",[t("strong",[e._v("NLP Models (Table 4, Figure 1)")]),e._v(" :\n"),t("ul",[t("li",[e._v("GPT models (126M to 175B parameters) trained in FP8 "),t("strong",[e._v("match FP16 in perplexity")]),e._v(" .")])])])]),e._v(" "),t("h4",{attrs:{id:"_4-2-inference"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-inference"}},[e._v("#")]),e._v(" "),t("strong",[e._v("4.2 Inference")])]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("FP8 post-training quantization (PTQ) outperforms int8")]),e._v(" , retaining "),t("strong",[e._v("full precision accuracy")]),e._v("  for:\n"),t("ul",[t("li",[e._v("BERT (F1 score on SQuAD).")]),e._v(" "),t("li",[e._v("GPT-3 (perplexity on Wikitext103).")])])]),e._v(" "),t("li",[t("strong",[e._v("FP8-trained models require no additional quantization steps")]),e._v(" , simplifying deployment.")])]),e._v(" "),t("h4",{attrs:{id:"_4-3-per-tensor-scaling"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-3-per-tensor-scaling"}},[e._v("#")]),e._v(" "),t("strong",[e._v("4.3 Per-Tensor Scaling")])]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("Fixed exponent bias fails")]),e._v("  when additional tensors (e.g., residuals) are stored in FP8.")]),e._v(" "),t("li",[t("strong",[e._v("Per-tensor scaling maintains accuracy")]),e._v(" , making FP8 viable for "),t("strong",[e._v("expanded use beyond GEMMs")]),e._v(" .")])]),e._v(" "),t("h3",{attrs:{id:"_5-conclusions"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-conclusions"}},[e._v("#")]),e._v(" "),t("strong",[e._v("5. Conclusions")])]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("FP8 formats (E4M3, E5M2) efficiently reduce training and inference costs while maintaining accuracy")]),e._v(" .")]),e._v(" "),t("li",[t("strong",[e._v("FP8 training is on par with FP16/BF16")]),e._v(" , without hyperparameter changes.")]),e._v(" "),t("li",[t("strong",[e._v("FP8 simplifies inference")]),e._v("  by eliminating the need for quantization-aware training (QAT) required for int8.")]),e._v(" "),t("li",[t("strong",[e._v("Future work")]),e._v(" : Expanding FP8 usage to "),t("strong",[e._v("more tensor types and operations")]),e._v("  beyond matrix multiplications.")])]),e._v(" "),t("h3",{attrs:{id:"key-takeaways-in-three-sentences-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#key-takeaways-in-three-sentences-2"}},[e._v("#")]),e._v(" "),t("strong",[e._v("Key Takeaways in Three Sentences")])]),e._v(" "),t("p",[e._v("FP8 formats (E4M3 for weights/activations, E5M2 for gradients) "),t("strong",[e._v("significantly reduce computation and memory overhead")]),e._v("  while maintaining "),t("strong",[e._v("accuracy equivalent to FP16/BF16")]),e._v("  across CNNs, RNNs, and Transformer models.")]),e._v(" "),t("p",[t("strong",[e._v("Post-training quantization (PTQ) with FP8 outperforms int8")]),e._v(" , allowing for "),t("strong",[e._v("simpler and more effective deployment")]),e._v("  of trained models. The study "),t("strong",[e._v("validates FP8 training up to 175B parameters")]),e._v(" , proving its scalability for large-scale deep learning applications.")]),e._v(" "),t("hr"),e._v(" "),t("h2",{attrs:{id:"_8-34-stable-and-low-precision-training-for-large-scale-vision-language-models"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_8-34-stable-and-low-precision-training-for-large-scale-vision-language-models"}},[e._v("#")]),e._v(" 8. [34] Stable and low-precision training for large-scale vision-language models")]),e._v(" "),t("h3",{attrs:{id:"_1-introduction-and-motivation"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-introduction-and-motivation"}},[e._v("#")]),e._v(" 1. Introduction and Motivation")]),e._v(" "),t("p",[e._v("The paper addresses two crucial bottlenecks in large-scale vision-language model training:")]),e._v(" "),t("ul",[t("li",[e._v("Speed ‚Äì how to train massive models efficiently despite ballooning compute costs.")]),e._v(" "),t("li",[e._v("Stability ‚Äì how to avoid ‚Äúloss spikes‚Äù that can degrade or derail training.")])]),e._v(" "),t("p",[e._v("They target contrastive language-image pre-training (CLIP) models, which fuse image and text encoders to learn aligned representations.")]),e._v(" "),t("p",[e._v("These models often involve hundreds of millions to billions of parameters and require large-scale data (like LAION).")]),e._v(" "),t("p",[e._v("By improving efficiency (low-precision arithmetic) and stability (modified optimizer), the authors hope to sustain further scaling of multimodal architectures.")]),e._v(" "),t("h3",{attrs:{id:"_2-eight-bit-8-bit-training"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-eight-bit-8-bit-training"}},[e._v("#")]),e._v(" 2. Eight-Bit (8-bit) Training")]),e._v(" "),t("h4",{attrs:{id:"_2-1-preliminaries-related-work"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-preliminaries-related-work"}},[e._v("#")]),e._v(" 2.1 Preliminaries & Related Work")]),e._v(" "),t("p",[e._v("16-bit operations (float16/bfloat16) are currently standard for large-scale training.")]),e._v(" "),t("p",[e._v("bfloat16 has broader exponent range than float16, making it more robust at scale, but native hardware support for bfloat16 exists mainly on TPUs or newer GPUs.")]),e._v(" "),t("p",[e._v("More recently, hardware support for int8 and float8 is emerging (NVIDIA Ampere has int8, Hopper adds float8), enabling potential speedups over 16-bit if quantization can be made accurate and stable.")]),e._v(" "),t("p",[e._v("However, at the 1B-parameter scale of CLIP ViT-Huge, quantization can introduce noise that leads to sizable accuracy drops unless carefully managed.")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://github.com/user-attachments/assets/40b8d6df-33f0-4fb1-9c99-c86c51ba6c75",alt:"image"}})]),e._v(" "),t("h4",{attrs:{id:"_2-2-the-switchback-method"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-the-switchback-method"}},[e._v("#")]),e._v(" 2.2 The SwitchBack Method")]),e._v(" "),t("ol",[t("li",[t("strong",[e._v("Core Idea")]),e._v(": In a standard linear layer, three matrix multiplications occur: one in the forward pass and two in backprop (input-grad and weight-grad).")])]),e._v(" "),t("p",[e._v("SwitchBack executes only the forward pass and input-grad steps in 8-bit, while reverting the weight-grad step to higher precision (16-bit).")]),e._v(" "),t("ol",{attrs:{start:"2"}},[t("li",[e._v("Why This Matters:")])]),e._v(" "),t("ul",[t("li",[e._v("The weight-grad multiply has an extremely large inner dimension (batch size √ó sequence length), making it more prone to quantization noise.")]),e._v(" "),t("li",[e._v("By keeping that specific multiplication in 16-bit, SwitchBack avoids excessive noise accumulation.")])]),e._v(" "),t("ol",{attrs:{start:"3"}},[t("li",[e._v("Implementation Details:")])]),e._v(" "),t("ul",[t("li",[e._v("Uses row-wise quantization for activation/gradient matrices and tensor-wise quantization for weights.")]),e._v(" "),t("li",[e._v("Relies on triton kernels for fused ‚Äúquantize + transpose‚Äù in the backward pass, minimizing overhead from transposing or storing scaled values.")]),e._v(" "),t("li",[e._v("Extends easily to float8 (fp8) by simulating exact fp8 values with 16-bit computations.")])]),e._v(" "),t("ol",{attrs:{start:"4"}},[t("li",[e._v("Experimental Setup:")])]),e._v(" "),t("ul",[t("li",[e._v("Trains multiple CLIP ViT variants (Base, Large, Huge) on LAION-2B with a short schedule (20k iterations, patch dropout 0.5).")]),e._v(" "),t("li",[e._v("Evaluates zero-shot ImageNet accuracy using standard CLIP prompts.")])]),e._v(" "),t("p",[t("img",{attrs:{src:"https://github.com/user-attachments/assets/c23e270a-0096-4184-af1c-57263d4766e5",alt:"image"}})]),e._v(" "),t("ol",{attrs:{start:"5"}},[t("li",[e._v("Results & Speedups:")])]),e._v(" "),t("ul",[t("li",[e._v("Accuracy: For CLIP ViT-Huge (‚àº1B params), SwitchBack stays within 0.1% of the bfloat16 baseline, whereas a simpler baseline (LLM.int8()) underperforms by nearly 6%.")]),e._v(" "),t("li",[e._v("Speed: Overall training speeds up by 13‚Äì25%. Profiling shows int8 multiplications run ~2√ó faster than fp16, and quantization overhead is small (<25% of total time in these matmuls).")])]),e._v(" "),t("h4",{attrs:{id:"_2-3-float8-via-reduced-feature-magnitudes"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-float8-via-reduced-feature-magnitudes"}},[e._v("#")]),e._v(" 2.3 Float8 via Reduced Feature Magnitudes")]),e._v(" "),t("ul",[t("li",[e._v("While SwitchBack also supports float8 (fp8), the authors observe that a purely tensor-wise fp8 baseline diverges at large scale.")]),e._v(" "),t("li",[e._v("Key Intervention: Zero-initialized layer-scale ‚Äì each transformer block‚Äôs residual path is initially scaled to 0, then learned. This keeps features from growing too large, which can disrupt fp8‚Äôs narrower numeric range.")])]),e._v(" "),t("p",[t("strong",[e._v("Zero-initialized layer-scale")])]),e._v(" "),t("p",[t("img",{attrs:{src:"https://github.com/user-attachments/assets/e8ff88ac-70ad-49ed-b994-2c50ca1cf929",alt:"image"}})]),e._v(" "),t("ul",[t("li",[e._v("With zero-init layer-scale, ViT-Large trains successfully in simulated fp8 (still a small gap from bfloat16, but no divergence).")])]),e._v(" "),t("h3",{attrs:{id:"_3-stability-of-training"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-stability-of-training"}},[e._v("#")]),e._v(" 3. Stability of Training")]),e._v(" "),t("h4",{attrs:{id:"_3-1-problem-loss-spikes"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-problem-loss-spikes"}},[e._v("#")]),e._v(" 3.1 Problem: Loss Spikes")]),e._v(" "),t("ul",[t("li",[e._v("Training very large CLIP models can suffer from fast, sporadic spikes in loss‚Äîepisodes that slow or degrade convergence.")]),e._v(" "),t("li",[e._v("Prior methods like gradient clipping or large warmup sometimes help, but for CLIP ViT-Huge, the authors pinpoint a new mechanism: the AdamW second-moment estimator for the patch embedding layer can become out-of-date.")])]),e._v(" "),t("h4",{attrs:{id:"_3-2-observations-about-loss-spikes"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-observations-about-loss-spikes"}},[e._v("#")]),e._v(" 3.2 Observations About Loss Spikes")]),e._v(" "),t("p",[t("strong",[e._v("Loss spike")])]),e._v(" "),t("p",[t("img",{attrs:{src:"https://github.com/user-attachments/assets/8364d5cb-5296-47bb-9014-9c4d2235a3f6",alt:"image"}})]),e._v(" "),t("p",[t("img",{attrs:{src:"https://github.com/user-attachments/assets/7bf70d6c-aa7a-44fa-93e6-11e220f415c3",alt:"image"}})]),e._v(" "),t("ul",[t("li",[e._v("More Spikes at Larger Scale: Scaling model size, batch size, or learning rate all exacerbate these spikes.")]),e._v(" "),t("li",[e._v("AdamW Œ≤2 Influence: Reducing Œ≤2 from its typical 0.999 helps avoid some spikes but can hamper overall performance.")]),e._v(" "),t("li",[t("strong",[e._v("Root Cause")]),e._v(": ‚ùó When gradients suddenly increase for the early patch-embedding parameters, AdamW‚Äôs exponentially moving average of squared gradients (the second-moment) underestimates the true magnitude, resulting in an oversized update that triggers a transient loss explosion.")])]),e._v(" "),t("p",[t("strong",[e._v("Stuck-in-the-past sceneario")]),e._v(": historicall gradient magnitude have been historically samll, thus, some parameter is larger for those parameters.\nSuddenly, if those parameter receives a large gradient signal, the update can be "),t("strong",[e._v("catastrophycally")]),e._v(" big.")]),e._v(" "),t("h4",{attrs:{id:"_3-3-stableadamw-optimizer"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-stableadamw-optimizer"}},[e._v("#")]),e._v(" 3.3 StableAdamW Optimizer")]),e._v(" "),t("ul",[t("li",[e._v("Based on ideas from AdaFactor, the authors propose update clipping:\n"),t("ul",[t("li",[e._v("Compute an ‚ÄúRMS ratio‚Äù = ‚àö(E[g¬≤ / EMA(g¬≤)]) per layer.")]),e._v(" "),t("li",[e._v("If RMS ratio > 1, automatically downscale the layer‚Äôs effective learning rate for that iteration.")])])]),e._v(" "),t("li",[e._v("StableAdamW = AdamW + update clipping. It successfully removes or mitigates these spikes better than gradient norm clipping, sustaining higher accuracy at large scale.")])]),e._v(" "),t("p",[t("img",{attrs:{src:"https://github.com/user-attachments/assets/fffb86c1-4f81-442f-9d8a-3a79def24748",alt:"image"}})]),e._v(" "),t("h4",{attrs:{id:"_3-4-connection-to-low-precision-training"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-4-connection-to-low-precision-training"}},[e._v("#")]),e._v(" 3.4 Connection to Low-Precision Training")]),e._v(" "),t("ul",[t("li",[e._v("Loss spikes can produce extremely large activations and gradients, risking numerical issues (Inf/NaN) when using narrower floating-point types.")]),e._v(" "),t("li",[e._v("The authors show that stabilizing these early-layer explosions goes hand in hand with ensuring safe low-precision training.")]),e._v(" "),t("li",[e._v("They also adopt a specialized fp16 ‚Äúloss scalar‚Äù strategy (per-layer updates, fixed scaling) to keep ephemeral spikes in one layer from knocking down the entire network‚Äôs scalar.")])]),e._v(" "),t("h3",{attrs:{id:"_4-conclusion-and-future-directions"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-conclusion-and-future-directions"}},[e._v("#")]),e._v(" 4. Conclusion and Future Directions")]),e._v(" "),t("ul",[t("li",[e._v("SwitchBack plus StableAdamW demonstrates both faster (13‚Äì25% speedups) and steadier (fewer loss spikes) training for large CLIP ViTs, outperforming or matching bfloat16 baselines.")]),e._v(" "),t("li",[e._v("The authors note limitations: they simulate float8 (rather than use actual fp8 hardware), do not fully explore alternate initialization or width-scaling schemes, and their training runs are shortened for cost reasons. Nonetheless, the methods and open-source code (including Triton kernels) lay groundwork for future improvement in quantizing and stabilizing very large multimodal models.")])]),e._v(" "),t("h3",{attrs:{id:"three-sentence-core-summary"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#three-sentence-core-summary"}},[e._v("#")]),e._v(" Three-Sentence Core Summary")]),e._v(" "),t("p",[e._v("They propose SwitchBack, an 8-bit training approach that leaves weight-gradient computations in higher precision, yielding 13‚Äì25% speed improvements over standard 16-bit training while closely matching accuracy.")]),e._v(" "),t("p",[e._v("They further show that loss spikes in large CLIP models stem from outdated second-moment estimations in AdamW, and propose StableAdamW (AdamW plus adaptive update clipping) as a fix.")]),e._v(" "),t("p",[e._v("By combining these, the paper demonstrates fast, stable, and memory-efficient low-precision training on billion-parameter vision-language models.")]),e._v(" "),t("hr"),e._v(" "),t("h2",{attrs:{id:"_9-y2025-paretoq-scaling-laws-in-extremely-low-bit-llm-quantization"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_9-y2025-paretoq-scaling-laws-in-extremely-low-bit-llm-quantization"}},[e._v("#")]),e._v(" 9. [Y2025] ParetoQ: Scaling Laws in Extremely Low-bit LLM Quantization")]),e._v(" "),t("h3",{attrs:{id:"abstract-3"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#abstract-3"}},[e._v("#")]),e._v(" "),t("strong",[e._v("Abstract")])]),e._v(" "),t("p",[e._v("The study introduces "),t("strong",[e._v("ParetoQ")]),e._v(" , a unified framework for evaluating extremely low-bit quantization (1-bit to 4-bit) in large language models (LLMs)."),t("br"),e._v("\nIt identifies a "),t("strong",[e._v("learning transition")]),e._v("  between 2-bit and 3-bit models, with 3-bit and higher retaining pre-trained distributions, while 2-bit and below undergo drastic representation changes."),t("br"),e._v("\nBy optimizing training strategies and quantization functions, "),t("strong",[e._v("ParetoQ achieves state-of-the-art (SOTA) performance")]),e._v("  across multiple bit-widths."),t("br"),e._v("\nNotably, a "),t("strong",[e._v("ternary (1.58-bit) 600M model surpasses a previous 3B ternary model")]),e._v(" , using only one-fifth of the parameters."),t("br"),e._v("\nThe study finds that "),t("strong",[e._v("2-bit quantization offers a superior balance between accuracy, model size, and hardware efficiency")]),e._v("  compared to 4-bit and binary quantization.")]),e._v(" "),t("h3",{attrs:{id:"_1-introduction-3"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-introduction-3"}},[e._v("#")]),e._v(" "),t("strong",[e._v("1. Introduction")])]),e._v(" "),t("p",[e._v("As models scale, lower-precision computation is gaining traction due to "),t("strong",[e._v("memory savings and computational efficiency")]),e._v(" ."),t("br"),e._v("\nPrior studies suggest conflicting optimal quantization levels (1.58-bit, 2-bit, 4-bit, etc.), but "),t("strong",[e._v("no unified framework existed")]),e._v("  to systematically compare their effectiveness.")]),e._v(" "),t("h3",{attrs:{id:"key-questions"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#key-questions"}},[e._v("#")]),e._v(" "),t("strong",[e._v("Key Questions:")])]),e._v(" "),t("ul",[t("li",[e._v("What is the optimal trade-off between bit-width and model size?")]),e._v(" "),t("li",[e._v("How does quantization impact "),t("strong",[e._v("scaling laws")]),e._v("  in low-bit settings?")]),e._v(" "),t("li",[e._v("What training strategies and quantization functions yield "),t("strong",[e._v("Pareto-optimal results")]),e._v(" ?")])]),e._v(" "),t("h3",{attrs:{id:"paretoq-approach"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#paretoq-approach"}},[e._v("#")]),e._v(" "),t("strong",[e._v("ParetoQ Approach:")])]),e._v(" "),t("ul",[t("li",[e._v("Incorporates "),t("strong",[e._v("five key dimensions")]),e._v(" : model size ("),t("strong",[e._v("N")]),e._v(" ), token count ("),t("strong",[e._v("D")]),e._v(" ), quantization precision ("),t("strong",[e._v("P")]),e._v(" ), training strategy ("),t("strong",[e._v("S")]),e._v(" ), and quantization function ("),t("strong",[e._v("F")]),e._v(" ).")]),e._v(" "),t("li",[e._v("Identifies "),t("strong",[e._v("bit-specific training schemes and quantization functions")]),e._v(" .")]),e._v(" "),t("li",[e._v("Establishes that "),t("strong",[e._v("binary quantization significantly degrades accuracy")]),e._v(" , while "),t("strong",[e._v("ternary (1.58-bit), 2-bit, and 3-bit quantization match or exceed 4-bit performance")]),e._v(" .")])]),e._v(" "),t("h3",{attrs:{id:"_2-a-better-qat-scheduling-strategy-for-extreme-low-bit-llms"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-a-better-qat-scheduling-strategy-for-extreme-low-bit-llms"}},[e._v("#")]),e._v(" "),t("strong",[e._v("2. A Better QAT Scheduling Strategy for Extreme Low-Bit LLMs")])]),e._v(" "),t("h4",{attrs:{id:"_2-1-training-budget-allocation"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-training-budget-allocation"}},[e._v("#")]),e._v(" "),t("strong",[e._v("2.1 Training Budget Allocation")])]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("Post-Training Quantization (PTQ)")]),e._v("  is easier to implement but "),t("strong",[e._v("performs poorly")]),e._v("  below 4-bit.")]),e._v(" "),t("li",[t("strong",[e._v("Quantization-Aware Training (QAT)")]),e._v("  integrates quantization during training, "),t("strong",[e._v("improving low-bit performance")]),e._v(" .")]),e._v(" "),t("li",[t("strong",[e._v("Optimal budget split:")]),e._v(" "),t("strong",[e._v("90% full-precision training, 10% QAT fine-tuning")]),e._v(" .")]),e._v(" "),t("li",[t("strong",[e._v("Finding-1:")]),e._v(" "),t("strong",[e._v("QAT fine-tuning outperforms both PTQ and QAT from scratch")]),e._v(" , achieving the best trade-off between accuracy and efficiency.")])]),e._v(" "),t("h4",{attrs:{id:"_2-2-fine-tuning-characteristics"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-fine-tuning-characteristics"}},[e._v("#")]),e._v(" "),t("strong",[e._v("2.2 Fine-tuning Characteristics")])]),e._v(" "),t("ul",[t("li",[e._v("Fine-tuning "),t("strong",[e._v("improves accuracy across all bit-widths")]),e._v(" , including binary and ternary models.")]),e._v(" "),t("li",[t("strong",[e._v("Lower-bit models (‚â§2-bit) require more fine-tuning (30B tokens), while 3-bit and 4-bit saturate at 10B tokens")]),e._v(" .")]),e._v(" "),t("li",[t("strong",[e._v("Finding-2:")]),e._v(" "),t("strong",[e._v("Bit-width transition effect:")]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("3-bit & 4-bit recover near full precision with fine-tuning")]),e._v(" .")]),e._v(" "),t("li",[t("strong",[e._v("1-bit to 2-bit undergo substantial weight transformations")]),e._v(" , requiring more tokens.")]),e._v(" "),t("li",[e._v('QAT serves as "compensation" for 3-bit+ but "reconstruction" for ‚â§2-bit models.')])])])]),e._v(" "),t("h3",{attrs:{id:"_3-a-hitchhiker-s-guide-to-quantization-method-choices"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-a-hitchhiker-s-guide-to-quantization-method-choices"}},[e._v("#")]),e._v(" "),t("strong",[e._v("3. A Hitchhiker‚Äôs Guide to Quantization Method Choices")])]),e._v(" "),t("h4",{attrs:{id:"_3-1-trade-offs-in-low-bit-quantization"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-trade-offs-in-low-bit-quantization"}},[e._v("#")]),e._v(" "),t("strong",[e._v("3.1 Trade-offs in Low-bit Quantization")])]),e._v(" "),t("ol",[t("li",[t("strong",[e._v("Range Clipping")]),e._v(" : Lower-bit quantization suffers from outlier effects, requiring range clipping or "),t("strong",[e._v("learnable scales")]),e._v(" .")]),e._v(" "),t("li",[t("strong",[e._v("Quantization Grids")]),e._v(" :")])]),e._v(" "),t("ul",[t("li",[e._v("Binary & Ternary require balanced levels.")]),e._v(" "),t("li",[e._v("2-bit prefers symmetric distribution*.")]),e._v(" "),t("li",[e._v('3-bit and 4-bit benefit from including "0" in quantization levels.')])]),e._v(" "),t("h4",{attrs:{id:"_3-2-introducing-paretoq"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-introducing-paretoq"}},[e._v("#")]),e._v(" "),t("strong",[e._v("3.2 Introducing ParetoQ")])]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("Combines the best quantization functions per bit-width")]),e._v(" :\n"),t("ul",[t("li",[t("strong",[e._v("1-bit")]),e._v(" : Elastic Binarization.")]),e._v(" "),t("li",[t("strong",[e._v("1.58-bit, 2-bit")]),e._v(" : "),t("strong",[e._v("Stretched Elastic Quant (SEQ)")]),e._v(" .")]),e._v(" "),t("li",[t("strong",[e._v("3-bit, 4-bit")]),e._v(" : "),t("strong",[e._v("Learned Step Size Quantization (LSQ)")]),e._v(" .")])])]),e._v(" "),t("li",[t("strong",[e._v("Finding-3:")]),e._v("  No single best function for all bit-widths.\n"),t("strong",[e._v("Learnable range settings outperform fixed statistical methods")]),e._v(" , especially for "),t("strong",[e._v("sub-4-bit quantization")]),e._v(" .")])]),e._v(" "),t("h3",{attrs:{id:"_4-pareto-optimality-of-extremely-low-bit-llms"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-pareto-optimality-of-extremely-low-bit-llms"}},[e._v("#")]),e._v(" "),t("strong",[e._v("4. Pareto-Optimality of Extremely Low-Bit LLMs")])]),e._v(" "),t("h4",{attrs:{id:"_4-1-accuracy-compression-trade-off"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-accuracy-compression-trade-off"}},[e._v("#")]),e._v(" "),t("strong",[e._v("4.1 Accuracy-Compression Trade-off")])]),e._v(" "),t("ul",[t("li",[e._v("Ternary (1.58-bit), 2-bit, and 3-bit outperform 4-bit in accuracy-size efficiency.")]),e._v(" "),t("li",[e._v("2-bit and ternary quantization sit on the Pareto frontier.")])]),e._v(" "),t("h4",{attrs:{id:"_4-2-hardware-constraints"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-hardware-constraints"}},[e._v("#")]),e._v(" "),t("strong",[e._v("4.2 Hardware Constraints")])]),e._v(" "),t("ul",[t("li",[e._v("Ternary (1.58-bit) appears efficient but is difficult to implement due to indexing overhead.")]),e._v(" "),t("li",[e._v("2-bit is more hardware-friendly**  due to **simpler storage and arithmetic operations.")])]),e._v(" "),t("h4",{attrs:{id:"_4-3-accuracy-speed-trade-off"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-3-accuracy-speed-trade-off"}},[e._v("#")]),e._v(" "),t("strong",[e._v("4.3 Accuracy-Speed Trade-off")])]),e._v(" "),t("ul",[t("li",[e._v("2-bit achieves higher speed at the same accuracy as 4-bit.")]),e._v(" "),t("li",[e._v("2-bit kernels are significantly faster than 4-bit kernels in large matrix multiplications.")])]),e._v(" "),t("h3",{attrs:{id:"_6-related-work"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-related-work"}},[e._v("#")]),e._v(" "),t("strong",[e._v("6. Related Work")])]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("Early quantization research")]),e._v("  focused on "),t("strong",[e._v("8-bit and 4-bit LLMs")]),e._v(" .")]),e._v(" "),t("li",[e._v("Recent "),t("strong",[e._v("sub-4-bit research")]),e._v("  explored "),t("strong",[e._v("ternary, 2-bit, and 1-bit models")]),e._v(" , but lacked a "),t("strong",[e._v("unified comparison framework")]),e._v(" .")]),e._v(" "),t("li",[t("strong",[e._v("ParetoQ is the first study to systematically compare sub-4-bit quantization schemes")]),e._v(" .")])]),e._v(" "),t("p",[t("strong",[e._v("7. Conclusions")])]),e._v(" "),t("ul",[t("li",[e._v("ParetoQ unifies training and quantization schemes across five bit-widths.")]),e._v(" "),t("li",[e._v("Ternary (1.58-bit), 2-bit, and 3-bit quantization outperform 4-bit in the accuracy-size trade-off.")]),e._v(" "),t("li",[e._v("2-bit is the most practical choice due to its hardware efficiency.")]),e._v(" "),t("li",[e._v("First framework that ensures fair comparisons across different quantization methods.")])]),e._v(" "),t("p",[t("strong",[e._v("Key Takeaways (3 Sentences)")])]),e._v(" "),t("ol",[t("li",[e._v("ParetoQ introduces a unified framework for extreme low-bit quantization, identifying 2-bit as the most efficient trade-off between accuracy, memory, and computational speed.")]),e._v(" "),t("li",[e._v("A clear transition exists between 2-bit and 3-bit models, where lower-bit quantization requires substantial fine-tuning to compensate for drastic weight transformations.")]),e._v(" "),t("li",[e._v("With its optimized quantization functions and training schemes, ParetoQ achieves state-of-the-art performance across all bit-widths, surpassing previous specialized methods.")])]),e._v(" "),t("hr"),e._v(" "),t("h2",{attrs:{id:"_10-47-microscaling-data-formats-for-deep-learning"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_10-47-microscaling-data-formats-for-deep-learning"}},[e._v("#")]),e._v(" 10. [47] Microscaling Data Formats for Deep Learning")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://github.com/user-attachments/assets/e1533c6c-54ca-47f8-946a-2d6fe7d08aef",alt:"image"}})]),e._v(" "),t("h3",{attrs:{id:"introduction-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#introduction-2"}},[e._v("#")]),e._v(" "),t("strong",[e._v("Introduction")])]),e._v(" "),t("p",[e._v("The rapid advancement of deep learning models has led to increased computational and storage costs."),t("br"),e._v("\nOne approach to mitigating these costs is reducing bit-width precision in data formats, moving beyond traditional "),t("strong",[e._v("FP32")]),e._v("  to lower-bit formats such as "),t("strong",[e._v("FP16, BFloat16, FP8, and INT8")]),e._v("."),t("br"),e._v("\nHowever, per-tensor scaling in low-bit-width formats struggles with dynamic range limitations."),t("br"),e._v(" "),t("strong",[e._v("Microscaling (MX) data formats")]),e._v("  introduce "),t("strong",[e._v("per-block scaling factors")]),e._v("  to enhance efficiency, maintain accuracy, and ease deployment in AI hardware.")]),e._v(" "),t("h3",{attrs:{id:"microscaling-mx-data-formats"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#microscaling-mx-data-formats"}},[e._v("#")]),e._v(" "),t("strong",[e._v("Microscaling (MX) Data Formats")])]),e._v(" "),t("p",[e._v("MX formats encode numerical values in "),t("strong",[e._v("fixed-size blocks")]),e._v(" , where each block consists of:")]),e._v(" "),t("ul",[t("li",[e._v("A "),t("strong",[e._v("shared scaling factor (X)")])]),e._v(" "),t("li",[e._v("Multiple "),t("strong",[e._v("narrow bit-width elements (Pi)")])])]),e._v(" "),t("p",[e._v("This approach "),t("strong",[e._v("extends the dynamic range")]),e._v("  beyond what per-tensor scaling allows, making sub-8-bit computations feasible."),t("br"),e._v("\nMX formats are "),t("strong",[e._v("hardware-efficient")]),e._v("  while minimizing accuracy loss and "),t("strong",[e._v("ensuring seamless adoption in existing AI frameworks")]),e._v(".")]),e._v(" "),t("h3",{attrs:{id:"concrete-mx-formats"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#concrete-mx-formats"}},[e._v("#")]),e._v(" "),t("strong",[e._v("Concrete MX Formats")])]),e._v(" "),t("p",[e._v("MX formats are categorized based on "),t("strong",[e._v("block size, scale format, and element bit-width")]),e._v(".")]),e._v(" "),t("table",[t("thead",[t("tr",[t("th",[e._v("Format")]),e._v(" "),t("th",[e._v("Block Size")]),e._v(" "),t("th",[e._v("Scale Data Format")]),e._v(" "),t("th",[e._v("Scale Bits")]),e._v(" "),t("th",[e._v("Element Format")]),e._v(" "),t("th",[e._v("Element Bit-width")])])]),e._v(" "),t("tbody",[t("tr",[t("td",[e._v("MXFP8")]),e._v(" "),t("td",[e._v("32")]),e._v(" "),t("td",[e._v("E8M0")]),e._v(" "),t("td",[e._v("8")]),e._v(" "),t("td",[e._v("FP8 (E4M3/E5M2)")]),e._v(" "),t("td",[e._v("8")])]),e._v(" "),t("tr",[t("td",[e._v("MXFP6")]),e._v(" "),t("td",[e._v("32")]),e._v(" "),t("td",[e._v("E8M0")]),e._v(" "),t("td",[e._v("8")]),e._v(" "),t("td",[e._v("FP6 (E2M3/E3M2)")]),e._v(" "),t("td",[e._v("6")])]),e._v(" "),t("tr",[t("td",[e._v("MXFP4")]),e._v(" "),t("td",[e._v("32")]),e._v(" "),t("td",[e._v("E8M0")]),e._v(" "),t("td",[e._v("8")]),e._v(" "),t("td",[e._v("FP4 (E2M1)")]),e._v(" "),t("td",[e._v("4")])]),e._v(" "),t("tr",[t("td",[e._v("MXINT8")]),e._v(" "),t("td",[e._v("32")]),e._v(" "),t("td",[e._v("E8M0")]),e._v(" "),t("td",[e._v("8")]),e._v(" "),t("td",[e._v("INT8")]),e._v(" "),t("td",[e._v("8")])])])]),e._v(" "),t("h3",{attrs:{id:"scalar-float-to-mx-format-conversion"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#scalar-float-to-mx-format-conversion"}},[e._v("#")]),e._v(" "),t("strong",[e._v("Scalar Float to MX Format Conversion")])]),e._v(" "),t("p",[e._v("To convert floating-point data to an MX format, the "),t("strong",[e._v("shared scaling factor (X)")]),e._v("  is computed based on the largest absolute value in a block."),t("br"),e._v("\nEach element is then "),t("strong",[e._v("normalized using X and quantized")]),e._v("  to the desired format. The conversion follows a "),t("strong",[e._v("quantization algorithm")]),e._v("  that:")]),e._v(" "),t("ol",[t("li",[t("strong",[e._v("Determines the scaling exponent")]),e._v("  from the maximum value in the block.")]),e._v(" "),t("li",[t("strong",[e._v("Computes X as a power of two")]),e._v(" .")]),e._v(" "),t("li",[t("strong",[e._v("Quantizes elements (Pi) based on X")]),e._v(" .")])]),e._v(" "),t("h3",{attrs:{id:"compute-flow-and-training-pipeline"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#compute-flow-and-training-pipeline"}},[e._v("#")]),e._v(" "),t("strong",[e._v("Compute Flow and Training Pipeline")])]),e._v(" "),t("p",[e._v("For deep learning workloads, "),t("strong",[e._v("dot-product operations (e.g., matrix multiplication, convolutions) are performed in MX formats")]),e._v(" , while "),t("strong",[e._v("non-dot operations (e.g., activations, normalization, residual add) remain in higher-precision formats like FP32 or BFloat16")]),e._v(" ."),t("br"),e._v("\nTraining involves keeping a "),t("strong",[e._v("master FP32 copy of weights")]),e._v("  while performing compute-intensive operations in MX formats."),t("br"),e._v(" "),t("strong",[e._v("Quantization-aware fine-tuning")]),e._v("  is often required for best accuracy, particularly for lower-bit formats like MXFP6 and MXFP4.")]),e._v(" "),t("p",[t("strong",[e._v("Experimental Results")]),e._v(" "),t("strong",[e._v("Inference")]),e._v(" MX data formats were tested across "),t("strong",[e._v("language models, vision transformers, speech recognition, and recommendation models")]),e._v(".")]),e._v(" "),t("p",[t("strong",[e._v("Direct-Cast Inference (No Fine-Tuning)")])]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("MXINT8 performs nearly identically to FP32")]),e._v("  across all tasks, making it a "),t("strong",[e._v("drop-in replacement")]),e._v(" .")]),e._v(" "),t("li",[t("strong",[e._v("MXFP8 and MXFP6 maintain good accuracy")]),e._v(" , but MXFP6 requires fine-tuning for best results.")]),e._v(" "),t("li",[t("strong",[e._v("MXFP4 suffers from significant accuracy loss")]),e._v(" , especially in complex models.")])]),e._v(" "),t("p",[t("strong",[e._v("Post-Training Quantization (PTQ) with Error Diffusion")])]),e._v(" "),t("ul",[t("li",[e._v("Error diffusion (similar to "),t("strong",[e._v("GPFQ-based post-training quantization")]),e._v(" ) helps recover accuracy.")]),e._v(" "),t("li",[t("strong",[e._v("MXFP6 achieves results close to FP32")]),e._v("  after error diffusion.")]),e._v(" "),t("li",[t("strong",[e._v("MXFP4 remains significantly worse than FP32, limiting its practical use in inference")]),e._v(" .")])]),e._v(" "),t("p",[t("strong",[e._v("Finetuned Inference")])]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("MXFP6 achieves FP32-level accuracy after fine-tuning")]),e._v(" .")]),e._v(" "),t("li",[t("strong",[e._v("MXFP4 improves slightly but still lags behind")]),e._v(" .")]),e._v(" "),t("li",[e._v("MXINT8 continues to serve as the most effective "),t("strong",[e._v("low-friction alternative to FP32")]),e._v(" .")])]),e._v(" "),t("p",[t("strong",[e._v("Generative Model Inference (GPT-3, LLaMA)")])]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("MXINT8 closely matches FP32 performance")]),e._v("  on GPT-3 and LLaMA.")]),e._v(" "),t("li",[t("strong",[e._v("MXFP6 and MXFP8 perform well in most tasks")]),e._v(" , but some degradation is observed in complex benchmarks.")]),e._v(" "),t("li",[t("strong",[e._v("MXFP4 shows noticeable loss")]),e._v(" , especially in "),t("strong",[e._v("zero-shot settings")]),e._v(" .")])]),e._v(" "),t("p",[t("strong",[e._v("Training with MX Formats")]),e._v("\nFor the "),t("strong",[e._v("first time, MX formats enable sub-8-bit training of large-scale transformers")]),e._v("  with minimal accuracy loss.")]),e._v(" "),t("p",[t("strong",[e._v("Training with MXFP6")])]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("MXFP6 (E3M2) trains models with no accuracy drop compared to FP32")]),e._v(" .")]),e._v(" "),t("li",[e._v("This represents the "),t("strong",[e._v("first demonstration of 6-bit training for large transformer models")]),e._v("  without modifications to the training recipe.")]),e._v(" "),t("li",[t("strong",[e._v("Hyperparameters remain unchanged from FP32 training")]),e._v(", making MXFP6 a practical choice.")])]),e._v(" "),t("p",[t("strong",[e._v("Training with MXFP4 + MXFP6")])]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("MXFP4 weights combined with MXFP6 activations/gradients")]),e._v("  yield slightly worse performance but remain viable for training.")]),e._v(" "),t("li",[t("strong",[e._v("Loss curves show only a minor increase in training loss")]),e._v(" , proving feasibility.")])]),e._v(" "),t("h3",{attrs:{id:"conclusion-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#conclusion-2"}},[e._v("#")]),e._v(" "),t("strong",[e._v("Conclusion")])]),e._v(" "),t("p",[e._v("Microscaling (MX) data formats introduce "),t("strong",[e._v("per-block scaling")]),e._v("  to "),t("strong",[e._v("reduce bit-width")]),e._v("  while maintaining "),t("strong",[e._v("high accuracy, hardware efficiency, and seamless integration")]),e._v(" .")]),e._v(" "),t("h3",{attrs:{id:"key-findings"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#key-findings"}},[e._v("#")]),e._v(" Key findings:")]),e._v(" "),t("ol",[t("li",[e._v("MXINT8 is an effective drop-in replacement for FP32 inference.")]),e._v(" "),t("li",[e._v("MXFP6 enables sub-8-bit inference and training with minimal accuracy loss.")]),e._v(" "),t("li",[e._v("MXFP4 combined with MXFP6 remains viable for training but suffers in inference.")]),e._v(" "),t("li",[e._v("First-ever demonstration of training large generative models using 6-bit weights, activations, and gradients** .\nMX formats offer a compelling path toward "),t("strong",[e._v("lower precision deep learning")]),e._v("  without sacrificing model quality.")])]),e._v(" "),t("p",[t("img",{attrs:{src:"https://github.com/user-attachments/assets/ca5c4914-cbf2-4cc2-8d80-eb423ef1aa10",alt:"image"}})]),e._v(" "),t("h3",{attrs:{id:"three-sentence-summary"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#three-sentence-summary"}},[e._v("#")]),e._v(" "),t("strong",[e._v("Three-Sentence Summary")])]),e._v(" "),t("p",[e._v("Microscaling (MX) data formats introduce "),t("strong",[e._v("per-block scaling factors")]),e._v(" , improving the efficiency and accuracy of sub-8-bit deep learning computations.")]),e._v(" "),t("p",[t("strong",[e._v("MXINT8 serves as a near-lossless drop-in replacement for FP32 inference")]),e._v(" , while "),t("strong",[e._v("MXFP6 enables large-scale deep learning models to be trained with sub-8-bit precision without altering training recipes")]),e._v(" .")]),e._v(" "),t("p",[e._v("The results demonstrate that "),t("strong",[e._v("MX formats significantly reduce computational and storage costs while maintaining model performance")]),e._v(" , making them a strong alternative to traditional floating-point formats.")]),e._v(" "),t("hr"),e._v(" "),t("h2",{attrs:{id:"_14-33-spinquant-llm-quantization-with-learned-rotations"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_14-33-spinquant-llm-quantization-with-learned-rotations"}},[e._v("#")]),e._v(" 14. [33] SpinQuant: LLM quantization with learned rotations")]),e._v(" "),t("h3",{attrs:{id:"abstract-introduction"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#abstract-introduction"}},[e._v("#")]),e._v(" Abstract & Introduction")]),e._v(" "),t("p",[e._v("SpinQuant is a novel method for post-training quantization (PTQ) of Large Language Models (LLMs) that uses learned rotation matrices to enhance quantization accuracy while maintaining full-precision outputs.")]),e._v(" "),t("p",[t("strong",[e._v("Traditional PTQ struggles with outliers, which widen quantization ranges and reduce effective bit usage. Instead of relying on random rotations, SpinQuant learns rotation matrices that optimize quantization performance.")])]),e._v(" "),t("p",[e._v("The method significantly reduces accuracy gaps in 4-bit quantization across weights, activations, and KV-cache, outperforming previous quantization methods like LLM-QAT, SmoothQuant, and QuaRot.")]),e._v(" "),t("p",[e._v("Specifically, SpinQuant reduces the zero-shot reasoning accuracy gap on LLaMA-2 7B from 12.1 to 1.6 points, surpassing LLM-QAT by 19.1 points and SmoothQuant by 25.0 points.")]),e._v(" "),t("h3",{attrs:{id:"motivation-outlier-reduction"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#motivation-outlier-reduction"}},[e._v("#")]),e._v(" Motivation & Outlier Reduction")]),e._v(" "),t("p",[e._v("Quantization reduces memory and computation costs but suffers from outliers, which stretch the value distribution.")]),e._v(" "),t("p",[e._v("Existing methods like mixed-precision quantization and weight-activation trade-offs attempt to mitigate this but remain suboptimal.")]),e._v(" "),t("p",[t("strong",[e._v("SpinQuant rotates activation and weight matrices to remove outliers, making them more Gaussian-like, thus improving quantization efficiency.")])]),e._v(" "),t("p",[e._v("The paper demonstrates that some random rotations lead to better results than others, with a 13-point accuracy difference in zero-shot reasoning tasks.")]),e._v(" "),t("h3",{attrs:{id:"methodology"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#methodology"}},[e._v("#")]),e._v(" Methodology")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://github.com/user-attachments/assets/5906ef52-5f44-4783-a131-2e5ea9eb26c6",alt:"image"}})]),e._v(" "),t("p",[e._v("The method optimizes rotation matrices using Cayley SGD, which maintains orthonormality while minimizing the quantized network loss.")]),e._v(" "),t("p",[e._v("This process enhances quantization robustness, significantly outperforming random rotations.")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://github.com/user-attachments/assets/421f725d-9051-49e6-b640-4db5b51ded7f",alt:"image"}})]),e._v(" "),t("h3",{attrs:{id:"experiments-results"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#experiments-results"}},[e._v("#")]),e._v(" Experiments & Results")]),e._v(" "),t("p",[e._v("Experiments were conducted on LLaMA-2 (7B/13B/70B), LLaMA-3 (1B/3B/8B), and Mistral-7B, evaluated across zero-shot reasoning tasks and perplexity on WikiText2.")]),e._v(" "),t("h3",{attrs:{id:"key-findings-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#key-findings-2"}},[e._v("#")]),e._v(" Key findings:")]),e._v(" "),t("p",[e._v("SpinQuant‚Çô‚Çí‚Çï‚Çê‚Çëd effectively closes the quantization gap in W4A8KV8 settings, making it comparable to QuIP# and OmniQuant.")]),e._v(" "),t("p",[e._v("SpinQuant‚Çï‚Çê‚Çëd achieves 64.0 average accuracy in W4A4KV4, reducing the accuracy gap to full precision to 2.9 points (LLM-QAT had a 22-point gap).")]),e._v(" "),t("p",[e._v("Against QuaRot, SpinQuant improves accuracy by up to 28.6 points in extreme quantization settings.")]),e._v(" "),t("p",[e._v("Speed analysis shows that SpinQuant‚Çï‚Çê‚Çëd incurs only an 8% latency overhead, making it a practical approach.")]),e._v(" "),t("h3",{attrs:{id:"conclusions"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#conclusions"}},[e._v("#")]),e._v(" Conclusions")]),e._v(" "),t("p",[e._v("SpinQuant is the first PTQ method to optimize learned rotation matrices, offering:")]),e._v(" "),t("ul",[t("li",[e._v("Significant improvements over existing quantization techniques by reducing outliers.")]),e._v(" "),t("li",[e._v("State-of-the-art performance in 4-bit quantization settings.")]),e._v(" "),t("li",[e._v("Compatibility with advanced weight quantization methods like GPTQ.")])]),e._v(" "),t("p",[e._v("Its learned rotations make quantized LLMs more robust, reducing the performance gap to full-precision models, making low-bit LLM inference practical.")]),e._v(" "),t("h3",{attrs:{id:"three-sentence-summary-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#three-sentence-summary-2"}},[e._v("#")]),e._v(" Three-Sentence Summary")]),e._v(" "),t("p",[e._v("SpinQuant introduces learned rotation matrices to mitigate outliers in weight and activation distributions, improving LLM quantization efficiency.")]),e._v(" "),t("p",[e._v("Using Cayley SGD optimization, it significantly reduces the accuracy gap in 4-bit quantization, outperforming SmoothQuant, LLM-QAT, and QuaRot.")]),e._v(" "),t("p",[e._v("Experiments on LLaMA-2, LLaMA-3, and Mistral-7B show state-of-the-art quantization performance, with SpinQuant narrowing the accuracy gap to full precision by up to 45.1% relative to QuaRot.")]),e._v(" "),t("hr"),e._v(" "),t("h2",{attrs:{id:"_17-35-fp8-versus-int8-for-efficient-deep-learning-inference"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_17-35-fp8-versus-int8-for-efficient-deep-learning-inference"}},[e._v("#")]),e._v(" 17. [35] FP8 versus INT8 for efficient deep learning inference")]),e._v(" "),t("p",[e._v("This paperexplores the efficiency and accuracy of using FP8 (8-bit floating point) and INT8 (8-bit integer) formats for deep learning inference, particularly on edge devices.")]),e._v(" "),t("p",[e._v("The key points and findings of the paper are summarized as follows:")]),e._v(" "),t("h3",{attrs:{id:"_1-introduction-and-motivation-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-introduction-and-motivation-2"}},[e._v("#")]),e._v(" 1. Introduction and Motivation")]),e._v(" "),t("p",[e._v("The paper discusses the growing interest in using FP8 for neural network training, especially with Nvidia's introduction of FP8 in their Hopper architecture GPUs.")]),e._v(" "),t("p",[e._v("While FP8 is being considered for training, the paper focuses on its implications for efficient inference on edge devices, where INT8 is commonly used due to its efficiency.")]),e._v(" "),t("p",[e._v("The authors question whether training networks in FP8 and deploying them in the same format could bypass the need for quantization, which is currently required when converting FP32/FP16 models to INT8.")]),e._v(" "),t("h3",{attrs:{id:"_2-hardware-considerations"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-hardware-considerations"}},[e._v("#")]),e._v(" 2. Hardware Considerations")]),e._v(" "),t("p",[e._v("The paper argues that FP8 is less efficient than INT8 in terms of hardware area and energy consumption. FP8 requires 50% more area and energy compared to INT8, making it less suitable for efficient inference.")]),e._v(" "),t("p",[e._v("Floating-point operations are inherently more complex and costly in hardware compared to integer operations, especially when considering the need for floating-point accumulators.")]),e._v(" "),t("p",[e._v("The authors highlight that FP8 implementations often involve mixed precision (e.g., FP16 for activations), which can lead to inefficiencies, particularly in networks with large activation tensors.")]),e._v(" "),t("h3",{attrs:{id:"_3-accuracy-comparison"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-accuracy-comparison"}},[e._v("#")]),e._v(" 3. Accuracy Comparison")]),e._v(" "),t("p",[e._v("The paper provides a theoretical and empirical comparison of FP8 and INT8 formats in terms of network accuracy.")]),e._v(" "),t("p",[e._v("The key difference between FP8 and INT8 lies in their ability to handle outliers. FP8, with its exponent bits, can better represent outliers, while INT8 is more efficient for well-behaved, Gaussian-like distributions.")]),e._v(" "),t("blockquote",[t("p",[e._v("the only significant difference between the two formats is in their ability to capture outliers.")])]),e._v(" "),t("p",[e._v("‚ùó In post-training quantization (PTQ), INT8 generally performs better for networks without significant outliers, while FP8-E4 (4 exponent bits) is better for networks with outliers, such as "),t("strong",[e._v("ransformers")]),e._v(".")]),e._v(" "),t("p",[e._v("‚ùó In quantization-aware training (QAT), INT8 often outperforms FP8, as training can reduce the impact of outliers, making INT8 more accurate and efficient.")]),e._v(" "),t("h3",{attrs:{id:"_4-transformer-networks"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-transformer-networks"}},[e._v("#")]),e._v(" 4. Transformer Networks")]),e._v(" "),t("p",[e._v("Transformer networks, particularly BERT, "),t("strong",[e._v("exhibit significant outliers in certain layers, making FP8-E4 more accurate in PTQ settings.")])]),e._v(" "),t("p",[e._v("However, the paper argues that these outlier issues can be mitigated with techniques like mixed precision (W8A16) or quantization-aware training, allowing INT8 to achieve similar accuracy without the hardware inefficiencies of FP8.")]),e._v(" "),t("p",[t("strong",[e._v("FP8-E4 vs FP8-E5")])]),e._v(" "),t("p",[e._v("‚ùó It‚Äôs all about the outliers. If a distribution has very significant outliers, the FP8-E4/FP8-E5 format is more accurate.")]),e._v(" "),t("p",[e._v("For well-behaved networks without many outliers, the INT8 format is significantly more accurate in the PTQ setting than FP8-E4 and FP8-E5.")]),e._v(" "),t("p",[e._v("We also see that FP8-E5 is never the best format for inference; even for the transformer layers with significant outliers, the FP8-E4 format is better.")]),e._v(" "),t("p",[e._v("For some computer vision networks, INT8 is better; for some networks with significant outliers, the FP8-E4/FP8-E5 formats are better.")]),e._v(" "),t("p",[e._v("Purely taking these results into account, the FP8-E4 format looks comparatively worse than FP8-E2 and FP8-E3.")]),e._v(" "),t("p",[e._v("Combining these findings with the hardware implementation costs, the FP8-E4 format itself looks like it is a\nworse choice than its lower-exponent bit brethren, which are both cheaper hardware-wise and more accurate.")]),e._v(" "),t("p",[e._v("If anything, the "),t("strong",[e._v("FP8-E3 format")]),e._v(" stands out positively in this accuracy analysis compared to\nother FP formats.")]),e._v(" "),t("p",[t("strong",[e._v("However, Deepseek FP8 use E4M4 for both forward and backwards computation.")])]),e._v(" "),t("p",[t("strong",[e._v("QAT versus PTQ")])]),e._v(" "),t("p",[t("img",{attrs:{src:"https://github.com/user-attachments/assets/3bc7ef7b-959d-4869-ac98-855451453709",alt:"image"}})]),e._v(" "),t("p",[e._v("One surprising trend is that the INT8 results improve more than their PTQ baseline than their FP8 counterparts.")]),e._v(" "),t("p",[e._v("There is a good reason for this; again, it‚Äôs about the outliers.")]),e._v(" "),t("p",[e._v("When performing QAT, outliers are clipped and do not receive a gradient.")]),e._v(" "),t("p",[e._v("The clipped weights/activations then tend towards the clipping threshold due to regularization.")]),e._v(" "),t("p",[e._v("But most importantly, with the outliers clipped, the network learns weights that still perform well despite the outliers being removed.")]),e._v(" "),t("p",[e._v("when training the quantization parameters with a method like LSQ (Esser et al. (2020)), the network can learn to make the ranges smaller so as to find a better trade-off between the clipping and quantization errors.")]),e._v(" "),t("p",[e._v("The smaller the range, the more accurate your quantized representation will be.")]),e._v(" "),t("p",[e._v("This is especially the case for INT8, where the sensitivity to the quantization ranges is much larger than the floating-point formats with more exponent bits that are naturally more resistant to outliers.")]),e._v(" "),t("p",[e._v("This way, the INT8 format benefits significantly more from QAT than the FP formats.")]),e._v(" "),t("p",[t("strong",[e._v("QAT")])]),e._v(" "),t("p",[e._v("Numerical representation chosen for training (e.g., FP8-E4) does not dictate how the distributions of weights and activations form.")]),e._v(" "),t("p",[e._v("Instead, these distributions are primarily shaped by the overall training process, including factors like regularization, optimizer settings, and initialization.")]),e._v(" "),t("p",[t("strong",[e._v("QAT Transformer")])]),e._v(" "),t("p",[e._v("There are significant outliers in the summation going into the layer-norm in some of the fully connected modules,  especially in the final layers of the network.")]),e._v(" "),t("p",[e._v("These outliers force the attention mechanism in the next layer to pay attention to some meaningless tokens ‚Äì like "),t("strong",[e._v("sentence separator tokens, periods, or commas")]),e._v(" ‚Äì that occur in the text, causing that specific token to not update significantly.")]),e._v(" "),t("p",[e._v("Simply clipping these outlier reduces accuracy significantly.")]),e._v(" "),t("p",[e._v("Only a few layers are the best in FP8-E4. The other layers find a lower MSE error with the FP8-E2 and FP8-E3 formats.")]),e._v(" "),t("p",[e._v("In the most naive PTQ setting, the FP8-E4 format performs better than INT8.")]),e._v(" "),t("p",[t("strong",[e._v("Comparison to other work")])]),e._v(" "),t("blockquote",[t("p",[t("strong",[e._v("The problems with the quantization of gradients put forth in the paper are well-known and have been\naddressed in many works in the past. (Sun et al. (2019); Gupta et al. (2015)). Many works have shown\nthe necessity of stochastic rounding and proper range setting for the backward pass that alleviate\nthese issues and make INT8 for gradients work just as well (Sun et al. (2019).")]),e._v("\nWhat is this?")])]),e._v(" "),t("p",[e._v("Transformer models can be executed in INT8 as well, both with PTQ and QAT.")]),e._v(" "),t("p",[e._v("Finally, the only comparison with the INT8 format comes in the form of comparing transformer-based language models in the PTQ setting.")]),e._v(" "),t("p",[e._v("However, as argued, these problems are easily fixable for transformer networks, making them able to execute entirely in INT8 or in mixed precision with a small number of activations in INT16.")]),e._v(" "),t("h3",{attrs:{id:"_5-comparison-to-other-work"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-comparison-to-other-work"}},[e._v("#")]),e._v(" 5. Comparison to Other Work")]),e._v(" "),t("p",[e._v("The authors compare their findings with other works, such as those from Nvidia, Arm, and Intel, and Graphcore, which also explore FP8 for training.")]),e._v(" "),t("p",[e._v("They find that their results are consistent with these works but provide a more comprehensive comparison between FP8 and INT8.")]),e._v(" "),t("p",[e._v("The paper highlights that other works often omit critical comparisons, such as the hardware efficiency of FP8 versus INT8, and the impact of mixed precision on inference performance.")]),e._v(" "),t("p",[e._v("Several works have shown that even in the INT8 PTQ setting you can get back your original accuracy with any of several possible tricks")]),e._v(" "),t("h3",{attrs:{id:"_6-fp8-to-int8-conversion"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-fp8-to-int8-conversion"}},[e._v("#")]),e._v(" 6. FP8 to INT8 Conversion")]),e._v(" "),t("p",[e._v("The paper explores the feasibility of converting FP8-trained networks to INT8.")]),e._v(" "),t("p",[e._v("For networks without significant outliers, the conversion is straightforward and can even improve accuracy.")]),e._v(" "),t("p",[t("strong",[e._v("For networks with outliers, such as transformers, the conversion to INT8 may degrade accuracy, but this can be mitigated with quantization-aware training.")])]),e._v(" "),t("h3",{attrs:{id:"_7-int-quantization-paradigm"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_7-int-quantization-paradigm"}},[e._v("#")]),e._v(" 7. INT Quantization Paradigm")]),e._v(" "),t("p",[e._v("The authors advocate for the use of INT8 and INT4 formats for efficient inference, as they offer better hardware efficiency and accuracy for most networks.")]),e._v(" "),t("p",[e._v("They present a quantization paradigm where INT16 is used for high accuracy, INT8 for most networks, and INT4 for further efficiency, especially in weight-bound networks like large language models.")]),e._v(" "),t("h3",{attrs:{id:"_8-conclusion"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_8-conclusion"}},[e._v("#")]),e._v(" 8. Conclusion")]),e._v(" "),t("p",[e._v("The paper concludes that FP8 is not a suitable replacement for INT8 in efficient deep learning inference.")]),e._v(" "),t("p",[e._v("While FP8 can handle outliers better in certain cases, the hardware inefficiencies and the availability of techniques to mitigate outlier issues in INT8 make it a less attractive option.")]),e._v(" "),t("p",[e._v("The authors recommend using INT8 and INT4 formats for efficient on-device inference, as they provide the best trade-off between accuracy and efficiency.")]),e._v(" "),t("h3",{attrs:{id:"key-takeaways"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#key-takeaways"}},[e._v("#")]),e._v(" Key Takeaways:")]),e._v(" "),t("p",[e._v("FP8 is less efficient than INT8 in terms of hardware area and energy consumption.")]),e._v(" "),t("p",[e._v("INT8 is more accurate for most networks, especially after quantization-aware training, which can reduce the impact of outliers.")]),e._v(" "),t("p",[t("strong",[e._v("FP8 is only beneficial in specific cases, such as transformer networks with significant outliers, but these issues can be addressed with INT8 using mixed precision or QAT.")])]),e._v(" "),t("p",[e._v("INT4 and INT8 are recommended for efficient inference, offering a better balance of accuracy and hardware efficiency compared to FP8.")]),e._v(" "),t("p",[e._v("Overall, the paper provides a comprehensive analysis of the trade-offs between FP8 and INT8, concluding that INT8 remains the superior choice for efficient deep learning inference on edge devices.")]),e._v(" "),t("hr"),e._v(" "),t("h2",{attrs:{id:"_16"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_16"}},[e._v("#")]),e._v(" 16.")]),e._v(" "),t("hr"),e._v(" "),t("h2",{attrs:{id:"_17-434-integer-quantization-for-deep-learning-inference-principles-and-empirical-evaluation"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_17-434-integer-quantization-for-deep-learning-inference-principles-and-empirical-evaluation"}},[e._v("#")]),e._v(" 17. [434] Integer Quantization for Deep Learning Inference: Principles and Empirical Evaluation")]),e._v(" "),t("p",[e._v("This paper explores integer quantization techniques for deep learning inference, which help reduce model size and improve computational efficiency by leveraging high-throughput integer math pipelines.")]),e._v(" "),t("p",[e._v("The authors provide a mathematical foundation for different quantization choices and evaluate their empirical performance across multiple deep learning models spanning vision, speech, and language domains.")]),e._v(" "),t("p",[e._v("The study focuses on 8-bit integer quantization, demonstrating that accuracy loss can be minimized to within 1% of the floating-point baseline, even for challenging models like MobileNets and BERT-large.")]),e._v(" "),t("h3",{attrs:{id:"key-highlights"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#key-highlights"}},[e._v("#")]),e._v(" Key Highlights:")]),e._v(" "),t("p",[e._v("Benefits of Integer Quantization")]),e._v(" "),t("ul",[t("li",[e._v("Integer operations offer up to 16√ó speedup over FP32 on NVIDIA Turing GPUs.")]),e._v(" "),t("li",[e._v("Smaller word sizes reduce memory bandwidth pressure and improve cache utilization.")])]),e._v(" "),t("h3",{attrs:{id:"quantization-methods"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#quantization-methods"}},[e._v("#")]),e._v(" Quantization Methods")]),e._v(" "),t("ul",[t("li",[e._v("Affine Quantization: Uses a scale factor and zero-point but adds computational overhead.")]),e._v(" "),t("li",[e._v("Scale Quantization: More efficient as it avoids additional computations by using only a scale factor.")])]),e._v(" "),t("h3",{attrs:{id:"post-training-quantization-ptq-vs-quantization-aware-training-qat"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#post-training-quantization-ptq-vs-quantization-aware-training-qat"}},[e._v("#")]),e._v(" Post Training Quantization (PTQ) vs. Quantization-Aware Training (QAT)")]),e._v(" "),t("ul",[t("li",[e._v("PTQ quantizes weights and activations after training but may lead to accuracy degradation for some models.")]),e._v(" "),t("li",[e._v("QAT fine-tunes the network with quantization effects included, yielding better results, especially for MobileNets and Transformers.")])]),e._v(" "),t("p",[e._v("Per-channel quantization for weights and per-tensor quantization for activations is recommended for accuracy and performance.")]),e._v(" "),t("h3",{attrs:{id:"calibration-methods"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#calibration-methods"}},[e._v("#")]),e._v(" Calibration Methods")]),e._v(" "),t("p",[e._v("Max, entropy, and percentile-based (99.9%-99.999%) calibrations are tested.")]),e._v(" "),t("p",[e._v("No single calibration is best for all networks; entropy and 99.99% percentile provide optimal accuracy for most models.")]),e._v(" "),t("h3",{attrs:{id:"optimizations-to-reduce-accuracy-loss"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#optimizations-to-reduce-accuracy-loss"}},[e._v("#")]),e._v(" Optimizations to Reduce Accuracy Loss")]),e._v(" "),t("ul",[t("li",[e._v("Partial Quantization: Leaves sensitive layers in floating point, improving accuracy while retaining performance benefits.")]),e._v(" "),t("li",[e._v("Learning Quantization Parameters: Fine-tuning the quantization ranges (PACT method) slightly improves accuracy but is not always necessary for int8 quantization.")])]),e._v(" "),t("p",[t("strong",[e._v("ELU Clipping: For BERT, modifying the GELU activation range significantly enhances post-training quantization results.")])]),e._v(" "),t("h3",{attrs:{id:"recommended-workflow"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#recommended-workflow"}},[e._v("#")]),e._v(" Recommended Workflow")]),e._v(" "),t("ul",[t("li",[e._v("Start with PTQ using max, entropy, and percentile calibrations.")]),e._v(" "),t("li",[e._v("If accuracy loss is high, use Partial Quantization to leave sensitive layers unquantized.")]),e._v(" "),t("li",[e._v("If further accuracy recovery is needed, perform QAT with pre-determined best calibration.")])]),e._v(" "),t("h3",{attrs:{id:"final-3-sentence-summary"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#final-3-sentence-summary"}},[e._v("#")]),e._v(" Final 3-Sentence Summary:")]),e._v(" "),t("p",[e._v("This paper presents a quantization workflow for deep learning inference, balancing speed and accuracy by leveraging int8 quantization with scale quantization for weights and activations.")]),e._v(" "),t("p",[e._v("It demonstrates that a combination of post-training quantization, partial quantization, and quantization-aware training ensures that accuracy remains within 1% of floating-point models, even for challenging architectures like MobileNets and BERT.")]),e._v(" "),t("p",[e._v("The proposed methods significantly improve inference efficiency, making integer quantization a practical approach for deploying neural networks on hardware accelerators.")]),e._v(" "),t("hr"),e._v(" "),t("h2",{attrs:{id:"_20-73-fp8-quantization-the-power-of-the-exponent"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_20-73-fp8-quantization-the-power-of-the-exponent"}},[e._v("#")]),e._v(" 20.[73] FP8 Quantization: The Power of the Exponent")]),e._v(" "),t("p",[e._v("This paper investigates FP8 quantization for neural network inference, comparing it with traditional INT8 quantization.")]),e._v(" "),t("p",[e._v("The authors analyze different FP8 format configurations, focusing on the trade-off between exponent and mantissa bits.")]),e._v(" "),t("p",[e._v("The study includes theoretical analysis, post-training quantization (PTQ), and quantization-aware training (QAT) across various deep learning models.")]),e._v(" "),t("p",[t("strong",[e._v("Key findings indicate that FP8 outperforms INT8 in post-training quantization, particularly for networks with activation outliers, such as Transformers.")])]),e._v(" "),t("p",[e._v("However, in quantization-aware training, the accuracy difference between INT8 and FP8 diminishes as the network learns to adapt to the quantization scheme.")]),e._v(" "),t("h3",{attrs:{id:"key-takeaways-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#key-takeaways-2"}},[e._v("#")]),e._v(" Key Takeaways:")]),e._v(" "),t("ul",[t("li",[e._v("FP8 vs. INT8: FP8 offers an additional degree of freedom through exponent bits, which helps manage outliers better than INT8, improving post-training quantization accuracy.")]),e._v(" "),t("li",[e._v("Optimal Format Selection: "),t("strong",[e._v("The choice of FP8 format (e.g., 5M2E vs. 4M3E) depends on the severity of outliers in a network,")]),e._v(" with higher exponent bits benefiting models with significant activation outliers.")]),e._v(" "),t("li",[e._v("QAT Reduces Differences: Quantization-aware training helps networks adapt to the quantization format, making INT8 and FP8 perform similarly in trained models.")])]),e._v(" "),t("h3",{attrs:{id:"three-sentence-summary-3"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#three-sentence-summary-3"}},[e._v("#")]),e._v(" Three-Sentence Summary")]),e._v(" "),t("p",[e._v("This paper explores FP8 quantization and its advantages over INT8, showing that FP8 provides better accuracy in post-training quantization due to its ability to handle activation outliers more effectively.")]),e._v(" "),t("p",[e._v("Through analytical and empirical studies, the authors determine that the optimal FP8 configuration depends on the balance between exponent and mantissa bits, with higher exponent bits benefiting networks with larger outliers.")]),e._v(" "),t("p",[e._v("However, in quantization-aware training, the differences between FP8 and INT8 diminish as the network learns to optimize within the quantization scheme.")]),e._v(" "),t("blockquote",[t("p",[e._v("We validated the FP8 format for many networks in a post-training quantization setting, showing that generally for neural networks the 5M2E and 4M3E FP8 format works the best, and that for networks with more outliers like transformers increasing the number of exponent bits works best.")])]),e._v(" "),t("hr"),e._v(" "),t("h2",{attrs:{id:"_18-y2024-integer-scale-a-free-lunch-for-faster-fine-grained-quantization-of-llms"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_18-y2024-integer-scale-a-free-lunch-for-faster-fine-grained-quantization-of-llms"}},[e._v("#")]),e._v(" 18. [Y2024]Integer Scale: A Free Lunch for Faster Fine-grained Quantization of LLMs")]),e._v(" "),t("h3",{attrs:{id:"overview"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#overview"}},[e._v("#")]),e._v(" Overview")]),e._v(" "),t("p",[e._v("This paper deals with post-training quantization for large language models (LLMs), focusing on a technique called fine-grained quantization.\nWhile fine-grained quantization (group-wise scales) generally retains better accuracy at lower bit-widths than coarse-grained methods, it comes with a major drawback in slower inference.\nThe authors identify that a large part of this overhead comes from repeatedly converting integer multiplication results into floating-point to apply each group‚Äôs ‚Äúfloat scale.‚Äù\nThey therefore propose an Integer Scale approach that removes most of these costly conversions by storing and applying each group‚Äôs scale in integer form.")]),e._v(" "),t("h3",{attrs:{id:"key-motivation"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#key-motivation"}},[e._v("#")]),e._v(" Key Motivation")]),e._v(" "),t("ol",[t("li",[e._v("Accuracy vs. Speed Trade-off:")])]),e._v(" "),t("ul",[t("li",[e._v("Fine-grained quantization (grouping weights or activations into small blocks) achieves higher accuracy than coarse-grained approaches, especially when pushing to lower bit-widths like W4A8 or W4A4 (weights 4-bit, activations 8 or 4-bit).")]),e._v(" "),t("li",[e._v("However, the group-wise scaling factors in floating-point form introduce numerous conversions (e.g., INT32 ‚Üí FP32 ‚Üí multiply by FP32 scale ‚Üí back to INT32), which dramatically reduce inference speed.")])]),e._v(" "),t("ol",{attrs:{start:"2"}},[t("li",[e._v("Integer Scale as a ‚ÄúFree Lunch‚Äù:")])]),e._v(" "),t("ul",[t("li",[e._v("By transforming each group‚Äôs floating-point scale into an integer, the paper‚Äôs method avoids a lot of repetitive float conversions within the GEMM kernels.")]),e._v(" "),t("li",[e._v("The authors call it a ‚Äúfree lunch‚Äù because it requires no additional calibration or training‚Äîjust a straightforward conversion of float scales into integer form with a suitable integer ‚Äúamplifier.‚Äù")])]),e._v(" "),t("h3",{attrs:{id:"proposed-method-integer-scale"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#proposed-method-integer-scale"}},[e._v("#")]),e._v(" Proposed Method: Integer Scale")]),e._v(" "),t("ol",[t("li",[e._v("Integer Amplifier (Œ±):")])]),e._v(" "),t("ul",[t("li",[e._v("Since the learned scales from fine-grained quantization typically lie between 0 and 1, the authors multiply them by a power-of-two factor (e.g., 2^10 = 1024) to map them into integer space without introducing big rounding errors.")]),e._v(" "),t("li",[e._v("They then store these integer scales and use simple integer multiply operations inside the kernel, followed by one final float conversion for the output‚Äîrather than one float conversion per group multiplication.")])]),e._v(" "),t("ol",{attrs:{start:"2"}},[t("li",[e._v("Modified GEMM Kernel:")])]),e._v(" "),t("ul",[t("li",[e._v("The new kernel accumulates partial sums at integer precision and multiplies by the integer scales on the fly.")]),e._v(" "),t("li",[e._v("This leads to far fewer float conversions and yields a noticeable speedup (often well above 1.5√ó faster) relative to the standard float-scale approach.")])]),e._v(" "),t("ol",{attrs:{start:"3"}},[t("li",[e._v("Stability & Overflow:")])]),e._v(" "),t("ul",[t("li",[e._v("The paper shows that choosing an amplifier (like 2^10) is sufficient to preserve accuracy while keeping integer operations safely in INT32 range‚Äîthere are no overflow issues in tested scenarios.")]),e._v(" "),t("li",[e._v("The authors also show that per-layer ‚Äúheuristic search‚Äù for the best amplifier can be replaced by a single fixed power-of-two amplifier (e.g., 1024), with negligible difference in accuracy.")])]),e._v(" "),t("p",[t("img",{attrs:{src:"https://github.com/user-attachments/assets/57599852-ef8a-4c22-b69d-b3ed0af743e7",alt:"image"}})]),e._v(" "),t("h3",{attrs:{id:"results"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#results"}},[e._v("#")]),e._v(" Results")]),e._v(" "),t("ol",[t("li",[e._v("Accuracy Retention:")])]),e._v(" "),t("ul",[t("li",[e._v("On tasks like LAMBADA, C4, WikiText-2, and Common Sense QA, the Integer Scale method achieves nearly the same (or slightly better) accuracy compared to float-scale baselines (GPTQ, AWQ, Omniquant) under the same fine-grained quantization setup.")]),e._v(" "),t("li",[e._v("It also helps quantize more challenging models like LLaMA-3 and Mixtral 8√ó7B at 4-bit weights without the large drop typical of naive methods.")])]),e._v(" "),t("ol",{attrs:{start:"2"}},[t("li",[e._v("Speed Gains:")])]),e._v(" "),t("ul",[t("li",[e._v("The central benefit is that Integer Scale speeds up fine-grained quantization kernels significantly.")]),e._v(" "),t("li",[e._v("In many experiments, the method achieves:\n"),t("ul",[t("li",[e._v("Up to 1.85√ó acceleration vs. float-scale fine-grained kernels,")]),e._v(" "),t("li",[e._v("Up to 1.17√ó faster than certain well-optimized W4A16 kernels (e.g., Marlin),")]),e._v(" "),t("li",[e._v("Up to 2.13√ó faster than the model‚Äôs FP16 baseline (depending on batch size and model).")])])])]),e._v(" "),t("ol",{attrs:{start:"3"}},[t("li",[e._v("Comparison to Other Libraries:")])]),e._v(" "),t("ul",[t("li",[e._v("Compared to QServe (another W4A8 system) or Marlin‚Äôs W4A16, the Integer Scale approach often yields higher or comparable throughput, especially under typical inference batch sizes (32, 64, 128).")])]),e._v(" "),t("h3",{attrs:{id:"practical-takeaways"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#practical-takeaways"}},[e._v("#")]),e._v(" Practical Takeaways")]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("Plug-and-Play for Existing Methods")]),e._v(": Integer Scale is designed to be a drop-in replacement for float scales in fine-grained quantization. You keep the same group sizes, bit widths, etc., just multiply the group scales by a power-of-two to store them as integers.")]),e._v(" "),t("li",[t("strong",[e._v("No Extra Training")]),e._v(": Unlike some other quantization techniques that require knowledge distillation or fine-tuning, Integer Scale only changes how scales are stored and applied. This means no additional compute overhead for calibrating or adjusting the model.")]),e._v(" "),t("li",[t("strong",[e._v("Balancing Memory- and Compute-Bound Scenarios")]),e._v(": The paper emphasizes that as batch size grows, the gains might change (memory-bound vs. compute-bound). Still, they show consistent improvements in typical inference settings.")])]),e._v(" "),t("h3",{attrs:{id:"key-parts-of-the-paper-in-3-sentences"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#key-parts-of-the-paper-in-3-sentences"}},[e._v("#")]),e._v(" Key Parts of the Paper in 3 Sentences")]),e._v(" "),t("ul",[t("li",[e._v("The authors pinpoint that existing fine-grained quantization is slowed down by many float conversions during inference.")]),e._v(" "),t("li",[e._v("They propose ‚ÄúInteger Scale,‚Äù which transforms per-group float scales to integer scales (with a power-of-two amplifier), avoiding most of the costly conversions.")]),e._v(" "),t("li",[e._v("As a result, they achieve up to 2√ó speed boost while retaining nearly the same quantization accuracy on a broad range of large language models.")])]),e._v(" "),t("hr"),e._v(" "),t("h2",{attrs:{id:"_19-121-training-high-performance-and-large-scale-deep-neural-networks-with-full-8-bit-integers"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_19-121-training-high-performance-and-large-scale-deep-neural-networks-with-full-8-bit-integers"}},[e._v("#")]),e._v(" 19. [121] Training High-Performance and Large-Scale Deep Neural Networks with Full 8-bit Integers")]),e._v(" "),t("h3",{attrs:{id:"_1-introduction-4"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-introduction-4"}},[e._v("#")]),e._v(" "),t("strong",[e._v("1. Introduction")])]),e._v(" "),t("p",[e._v("Deep neural networks (DNNs) have achieved remarkable success in fields such as image processing, object detection, and natural language processing.")]),e._v(" "),t("p",[e._v("However, training these models requires extensive floating-point (FP) operations, leading to high memory, compute, and energy costs.")]),e._v(" "),t("p",[e._v("DNN quantization has been explored as a solution to this problem, primarily focusing on inference quantization (e.g., BWN, XNOR-Net).")]),e._v(" "),t("p",[e._v("Recent advancements extend quantization to training, but existing methods still leave parts of the computation in high-precision floating-point (e.g., FP8, FP16) or do not quantize Batch Normalization (BN).")]),e._v(" "),t("p",[e._v("The major challenges in achieving full quantization include:")]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("Incomplete quantization")]),e._v(" : Some parts of the model remain in floating-point, limiting memory and compute savings.")]),e._v(" "),t("li",[t("strong",[e._v("Unquantized Batch Normalization (BN)")]),e._v(" : BN is critical for training stability but is often left in floating-point.")]),e._v(" "),t("li",[t("strong",[e._v("Lack of a unified low-bit training framework")]),e._v(" : No existing method successfully trains large-scale models with only low-bit integer operations.")])]),e._v(" "),t("p",[e._v("This work introduces "),t("strong",[e._v("WAGEUBN")]),e._v(" , a unified "),t("strong",[e._v("INT8 training framework")]),e._v("  that quantizes all major operations, including:")]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("Weights (W)")])]),e._v(" "),t("li",[t("strong",[e._v("Activations (A)")])]),e._v(" "),t("li",[t("strong",[e._v("Gradients (G)")])]),e._v(" "),t("li",[t("strong",[e._v("Errors (E)")])]),e._v(" "),t("li",[t("strong",[e._v("Updates (U)")])]),e._v(" "),t("li",[t("strong",[e._v("Batch Normalization (BN)")])]),e._v(" "),t("li",[t("strong",[e._v("Momentum optimizer")])])]),e._v(" "),t("h3",{attrs:{id:"_2-related-work"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-related-work"}},[e._v("#")]),e._v(" "),t("strong",[e._v("2. Related Work")])]),e._v(" "),t("h4",{attrs:{id:"_2-1-inference-quantization"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-inference-quantization"}},[e._v("#")]),e._v(" "),t("strong",[e._v("2.1. Inference Quantization")])]),e._v(" "),t("p",[e._v("Inference quantization aims to reduce the memory and compute cost of DNN inference by converting FP operations to bit-wise integer operations. Some key works include:")]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("BWN (Binary Weight Networks)")]),e._v(" : Quantizes only weights to {-1,1}.")]),e._v(" "),t("li",[t("strong",[e._v("XNOR-Net")]),e._v(" : Quantizes both weights and activations to binary values.")]),e._v(" "),t("li",[t("strong",[e._v("ADMM-based Quantization")]),e._v(" : Compresses models via alternating direction method of multipliers.")]),e._v(" "),t("li",[t("strong",[e._v("FP8/INT16-based Methods")]),e._v(" : Reduce bit-width to maintain accuracy.")])]),e._v(" "),t("p",[e._v("However, inference quantization only focuses on the forward pass and does not address the backward pass needed for training.")]),e._v(" "),t("h4",{attrs:{id:"_2-2-training-quantization"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-training-quantization"}},[e._v("#")]),e._v(" "),t("strong",[e._v("2.2. Training Quantization")])]),e._v(" "),t("p",[e._v("Training quantization extends quantization to the backward pass (gradients and updates). Key approaches include:")]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("DoReFa-Net")]),e._v(" : Uses low-bit activations, weights, and gradients but retains FP elements.")]),e._v(" "),t("li",[t("strong",[e._v("MP (Mixed Precision)")]),e._v(" : Uses FP16 for training but is not purely integer-based.")]),e._v(" "),t("li",[t("strong",[e._v("FP8 Training")]),e._v(" : Reduces training precision to FP8 but retains FP operations in BN.")]),e._v(" "),t("li",[t("strong",[e._v("QBP2")]),e._v(" : Uses 8-bit INT for weights, activations, and errors, but gradients remain FP.")]),e._v(" "),t("li",[t("strong",[e._v("WAGE")]),e._v(" : The most complete prior work, quantizing W, A, G, E, and U, but it lacks BN layers, making it unsuitable for large-scale DNNs.")])]),e._v(" "),t("p",[t("img",{attrs:{src:"https://github.com/user-attachments/assets/2d177f82-6d45-424e-9801-3bf3b85c3ca8",alt:"image"}})]),e._v(" "),t("h3",{attrs:{id:"_3-wageubn-framework"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-wageubn-framework"}},[e._v("#")]),e._v(" "),t("strong",[e._v("3. WAGEUBN Framework")])]),e._v(" "),t("h4",{attrs:{id:"_3-1-key-contributions"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-key-contributions"}},[e._v("#")]),e._v(" "),t("strong",[e._v("3.1. Key Contributions")])]),e._v(" "),t("ul",[t("li",[e._v("Fully quantizes "),t("strong",[e._v("all")]),e._v("  training data paths (W, A, G, E, U, BN, and Momentum).")]),e._v(" "),t("li",[e._v("Introduces three custom quantization functions for different training components.")]),e._v(" "),t("li",[e._v("Quantizes Batch Normalization (BN) for the first time.")]),e._v(" "),t("li",[e._v("Applies INT8 quantization to large-scale networks like ResNet on ImageNet.")])]),e._v(" "),t("h4",{attrs:{id:"_3-2-straight-through-estimator-ste"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-straight-through-estimator-ste"}},[e._v("#")]),e._v(" "),t("strong",[e._v("3.2. Straight-Through Estimator (STE)")])]),e._v(" "),t("p",[e._v("Quantization introduces a "),t("strong",[e._v("non-differentiability problem")]),e._v(" , making gradient updates challenging.")]),e._v(" "),t("p",[t("strong",[e._v("STE")]),e._v("  is used to approximate gradients during backpropagation:\n$$\\frac{\\partial L}{\\partial x} = \\frac{\\partial L}{\\partial x_q}$$")]),e._v(" "),t("p",[e._v("This method allows training to proceed despite non-differentiability.")]),e._v(" "),t("h4",{attrs:{id:"_3-3-quantization-functions"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-quantization-functions"}},[e._v("#")]),e._v(" "),t("strong",[e._v("3.3. Quantization Functions")])]),e._v(" "),t("p",[e._v("The framework introduces three quantization functions tailored for different data types:")]),e._v(" "),t("ol",[t("li",[t("strong",[e._v("Direct Quantization")]),e._v(" : Used for "),t("strong",[e._v("weights, activations, and BN parameters")]),e._v(".\n$$Q(x, k) = \\frac{\\text{round}(x \\cdot 2^{k-1})}{2^{k-1}}$$")])]),e._v(" "),t("p",[e._v("This function approximates floating-point values to the nearest discrete integer.")]),e._v(" "),t("ol",{attrs:{start:"2"}},[t("li",[t("strong",[e._v("Constant Quantization")]),e._v(" : Used for "),t("strong",[e._v("gradients")]),e._v("  to ensure a fixed update bit-width.\n$$CQ(x) = \\frac{Sd(x)}{2^{k-1}}$$")])]),e._v(" "),t("p",[e._v("This function scales data dynamically to avoid excessive precision loss.")]),e._v(" "),t("ol",{attrs:{start:"3"}},[t("li",[t("strong",[e._v("Shift Quantization")]),e._v(" : Used for "),t("strong",[e._v("errors")]),e._v(" , which are typically small-magnitude values.\n$$SQ(x, k) = R(x) \\cdot \\text{clip}(Q(\\text{Norm}(x), k), -1, 1)$$")])]),e._v(" "),t("p",[e._v("This function ensures errors maintain a meaningful range.")]),e._v(" "),t("h4",{attrs:{id:"_3-4-quantized-training-steps"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-4-quantized-training-steps"}},[e._v("#")]),e._v(" "),t("strong",[e._v("3.4. Quantized Training Steps")])]),e._v(" "),t("p",[e._v("The framework quantizes the entire training process:")]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("Forward Pass:")]),e._v(" "),t("ul",[t("li",[e._v("Quantizes inputs, applies INT8 convolutions, quantizes BN, and applies INT8 activation.")])])]),e._v(" "),t("li",[t("strong",[e._v("Backward Pass:")]),e._v(" "),t("ul",[t("li",[e._v("Uses INT8 gradients and error propagation.")]),e._v(" "),t("li",[e._v("Applies INT8 momentum optimization.")]),e._v(" "),t("li",[e._v("Uses fixed-point updates for weight adjustments.")])])]),e._v(" "),t("li",[t("strong",[e._v("Momentum Quantization:")]),e._v(" "),t("ul",[t("li",[e._v("Conventional optimizers like Adam/Momentum use floating-point accumulations.")]),e._v(" "),t("li",[e._v("WAGEUBN constrains them to fixed-point INT8.")])])])]),e._v(" "),t("h3",{attrs:{id:"_4-results"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-results"}},[e._v("#")]),e._v(" "),t("strong",[e._v("4. Results")])]),e._v(" "),t("h4",{attrs:{id:"_4-1-accuracy-evaluation"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-accuracy-evaluation"}},[e._v("#")]),e._v(" "),t("strong",[e._v("4.1. Accuracy Evaluation")])]),e._v(" "),t("p",[e._v("The framework was tested on "),t("strong",[e._v("ResNet18/34/50 with ImageNet")]),e._v(".\nTwo versions were evaluated:")]),e._v(" "),t("ol",[t("li",[t("strong",[e._v("Full 8-bit INT")]),e._v(" : All computations use 8-bit integers.")]),e._v(" "),t("li",[t("strong",[e._v("16-bit E2 Variant")]),e._v(" : Uses 16-bit error gradients to improve convergence.\n| Model | Vanilla FP32 | WAGEUBN (16-bit E2) | WAGEUBN (Full 8-bit) |\n| --- | --- | --- | --- |\n| ResNet18 | 68.70% | 67.40% | 64.79% |\n| ResNet34 | 71.99% | 68.50% | 67.63% |\n| ResNet50 | 74.66% | 69.07% | 67.95% |")])]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("Accuracy loss is minimal")]),e._v("  (~3-5% top-1 accuracy).")]),e._v(" "),t("li",[t("strong",[e._v("16-bit E2 improves accuracy")]),e._v("  over pure 8-bit training.")]),e._v(" "),t("li",[t("strong",[e._v("Comparable accuracy to FP8-based methods")]),e._v(".")])]),e._v(" "),t("h4",{attrs:{id:"_4-2-efficiency-gains"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-efficiency-gains"}},[e._v("#")]),e._v(" "),t("strong",[e._v("4.2. Efficiency Gains")])]),e._v(" "),t("p",[e._v("WAGEUBN significantly reduces hardware overhead compared to FP32:")]),e._v(" "),t("table",[t("thead",[t("tr",[t("th",[e._v("Precision")]),e._v(" "),t("th",[e._v("Compute Speedup")]),e._v(" "),t("th",[e._v("Power Reduction")]),e._v(" "),t("th",[e._v("Circuit Area Reduction")])])]),e._v(" "),t("tbody",[t("tr",[t("td",[e._v("INT8")]),e._v(" "),t("td",[e._v("3√ó - 9√ó")]),e._v(" "),t("td",[e._v("10√ó - 30√ó")]),e._v(" "),t("td",[e._v("9√ó - 30√ó")])]),e._v(" "),t("tr",[t("td",[e._v("FP8")]),e._v(" "),t("td",[e._v("0.73√ó")]),e._v(" "),t("td",[e._v("0.31√ó")]),e._v(" "),t("td",[e._v("0.4√ó")])]),e._v(" "),t("tr",[t("td",[e._v("FP16")]),e._v(" "),t("td",[e._v("0.58√ó")]),e._v(" "),t("td",[e._v("0.4√ó")]),e._v(" "),t("td",[e._v("0.4√ó")])])])]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("Memory is reduced by 4√ó")]),e._v(" .")]),e._v(" "),t("li",[t("strong",[e._v("Computation is up to 9√ó faster")]),e._v(" .")]),e._v(" "),t("li",[t("strong",[e._v("Power usage is up to 30√ó lower")]),e._v(" .")])]),e._v(" "),t("h3",{attrs:{id:"_5-analysis"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-analysis"}},[e._v("#")]),e._v(" "),t("strong",[e._v("5. Analysis")])]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("Batch Size Sensitivity")]),e._v(" : WAGEUBN works best with batch sizes ‚â•32. Smaller batches lead to higher accuracy loss.")]),e._v(" "),t("li",[t("strong",[e._v("Error Gradient Sensitivity")]),e._v(" : The "),t("strong",[e._v("8-bit Flag QE2 method")]),e._v("  significantly improves accuracy over simple 8-bit quantization.")]),e._v(" "),t("li",[t("strong",[e._v("Quantization Impact")]),e._v(" :\n"),t("ul",[t("li",[t("strong",[e._v("BN and Errors are the most sensitive to precision loss")]),e._v(" .")]),e._v(" "),t("li",[t("strong",[e._v("Weights and activations are more robust to INT8 constraints")]),e._v(" .")])])])]),e._v(" "),t("h3",{attrs:{id:"_6-conclusion-wageubn-is-the-first-complete-int8-quantization-framework-for-training-large-scale-dnns-it-achieves"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-conclusion-wageubn-is-the-first-complete-int8-quantization-framework-for-training-large-scale-dnns-it-achieves"}},[e._v("#")]),e._v(" "),t("strong",[e._v("6. Conclusion")]),e._v(" WAGEUBN is the "),t("strong",[e._v("first complete INT8 quantization framework")]),e._v("  for training large-scale DNNs. It achieves:")]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("End-to-end INT8 training")]),e._v("  (including BN and optimizers).")]),e._v(" "),t("li",[t("strong",[e._v("Competitive accuracy with significant hardware efficiency improvements")]),e._v(" .")]),e._v(" "),t("li",[t("strong",[e._v("Potential for online learning on energy-efficient devices")]),e._v(" .\nFuture work includes specialized "),t("strong",[e._v("hardware architectures")]),e._v("  to fully exploit WAGEUBN‚Äôs benefits.")])]),e._v(" "),t("h3",{attrs:{id:"three-sentence-summary-4"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#three-sentence-summary-4"}},[e._v("#")]),e._v(" "),t("strong",[e._v("Three-Sentence Summary")])]),e._v(" "),t("p",[e._v("WAGEUBN is a "),t("strong",[e._v("fully quantized INT8 training framework")]),e._v("  for large-scale deep learning, covering all data paths (W, A, G, E, U, BN, and Momentum).")]),e._v(" "),t("p",[e._v("By introducing novel quantization functions and INT8 batch normalization, it "),t("strong",[e._v("reduces memory by 4√ó, accelerates computation by up to 9√ó, and cuts power usage by 30√ó")]),e._v(" , while achieving "),t("strong",[e._v("comparable accuracy to FP-based models")])]),e._v(" "),t("p",[e._v("This work establishes a "),t("strong",[e._v("scalable and efficient approach for energy-efficient AI hardware and online learning")]),e._v(" .")]),e._v(" "),t("hr"),e._v(" "),t("h2",{attrs:{id:"_20-381-i-bert-integer-only-bert-quantization"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_20-381-i-bert-integer-only-bert-quantization"}},[e._v("#")]),e._v(" 20. [381] I-BERT: Integer-only BERT Quantization")]),e._v(" "),t("h3",{attrs:{id:"challenges-addressed"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#challenges-addressed"}},[e._v("#")]),e._v(" Challenges Addressed")]),e._v(" "),t("p",[e._v("Inefficiency of Transformer-Based Models: BERT and RoBERTa achieve high accuracy but have high memory, latency, and power costs, making them difficult to deploy on edge devices and data centers.")]),e._v(" "),t("p",[e._v("Limitations of Previous Quantization Approaches: Prior Transformer quantization methods rely on floating-point arithmetic, preventing efficient execution on integer-only hardware like ARM Cortex-M processors and Turing Tensor Cores.")]),e._v(" "),t("p",[e._v("Difficulty in Handling Non-Linear Functions: Existing integer-only quantization techniques are mainly designed for CNNs with piece-wise linear functions like ReLU. Transformers use complex non-linear functions (GELU, Softmax, LayerNorm), which are hard to process using integer arithmetic without significant accuracy loss.")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://github.com/user-attachments/assets/da7b8969-c3fe-4db7-a0a0-8d1ed1210382",alt:"image"}})]),e._v(" "),t("h3",{attrs:{id:"solution-i-bert-approach"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#solution-i-bert-approach"}},[e._v("#")]),e._v(" Solution - I-BERT Approach:")]),e._v(" "),t("p",[e._v("Integer-Only Approximation for Non-Linear Functions:")]),e._v(" "),t("ul",[t("li",[e._v("GELU: Approximated using a second-order polynomial (i-GELU), avoiding floating-point computation while maintaining accuracy.")]),e._v(" "),t("li",[e._v("Softmax: Transformed into a stable integer-friendly form using logarithm and bit-shift operations (i-exp).")]),e._v(" "),t("li",[e._v("LayerNorm: Computed using an integer-only square root algorithm.")])]),e._v(" "),t("p",[e._v("End-to-End Integer Execution:")]),e._v(" "),t("ul",[t("li",[e._v("MatMul and embeddings are computed using INT8 multiplication and INT32 accumulation.")]),e._v(" "),t("li",[e._v("Non-linear operations (GELU, Softmax, LayerNorm) are applied directly to INT32 values and re-quantized to INT8.")]),e._v(" "),t("li",[e._v("The entire inference process remains in integer arithmetic without dequantization.")])]),e._v(" "),t("h3",{attrs:{id:"results-and-impact"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#results-and-impact"}},[e._v("#")]),e._v(" Results and Impact:")]),e._v(" "),t("ul",[t("li",[e._v("Accuracy: I-BERT achieves comparable or slightly better accuracy than FP32 models on the GLUE benchmark, with an improvement of 0.3 (Base) and 0.5 (Large) in average score.")]),e._v(" "),t("li",[e._v("Efficiency: I-BERT provides 2.4√ó ‚Äì 4.0√ó speedup in inference compared to FP32 on NVIDIA T4 GPUs.")]),e._v(" "),t("li",[e._v("Deployment Feasibility: Eliminates floating-point dependency, making it ideal for deployment on integer-only hardware like ARM Cortex-M processors and specialized accelerators.")])]),e._v(" "),t("h3",{attrs:{id:"key-takeaways-in-3-sentences"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#key-takeaways-in-3-sentences"}},[e._v("#")]),e._v(" Key Takeaways in 3 Sentences")]),e._v(" "),t("p",[e._v("I-BERT introduces a novel integer-only quantization method for BERT, eliminating floating-point operations and enabling efficient deployment on integer-only hardware.")]),e._v(" "),t("p",[e._v("By approximating non-linear functions like GELU, Softmax, and LayerNorm with polynomial and integer arithmetic, it maintains high accuracy while significantly improving inference speed.")]),e._v(" "),t("p",[e._v("Evaluation on the GLUE benchmark and hardware tests demonstrate that I-BERT achieves up to 4√ó speedup while maintaining or slightly improving accuracy over FP32 models.")]),e._v(" "),t("hr"),e._v(" "),t("h2",{attrs:{id:"_21-904-llm-int8-8-bit-matrix-multiplication-for-transformers-at-scale"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_21-904-llm-int8-8-bit-matrix-multiplication-for-transformers-at-scale"}},[e._v("#")]),e._v(" 21. [904] LLM.int8(): 8-bit Matrix Multiplication for Transformers at Scale")]),e._v(" "),t("p",[e._v("The paper introduces LLM.int8(), a quantization method enabling 8-bit matrix multiplication for large transformers without degrading performance.")]),e._v(" "),t("p",[e._v("Traditional 8-bit quantization methods struggle with large-scale models due to systematic outlier features that disrupt quantization precision beyond 6.7B parameters.")]),e._v(" "),t("p",[e._v("To overcome this, LLM.int8() combines vector-wise quantization (which assigns separate normalization constants per inner product) and mixed-precision decomposition, where "),t("strong",[e._v("outlier dimensions are computed in 16-bit")]),e._v(" while 99.9% of values remain in 8-bit.")]),e._v(" "),t("p",[e._v("This approach allows large-scale transformers like OPT-175B and BLOOM to run on a single consumer GPU without accuracy loss.")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://github.com/user-attachments/assets/36c7a517-2cd5-4f69-ad74-31388c354235",alt:"image"}})]),e._v(" "),t("h3",{attrs:{id:"key-findings-include"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#key-findings-include"}},[e._v("#")]),e._v(" Key findings include:")]),e._v(" "),t("ul",[t("li",[e._v("Emergent outliers: Beyond 6.7B parameters, certain feature dimensions dominate transformer attention and predictive performance, requiring higher precision.")]),e._v(" "),t("li",[e._v("Quantization challenge: Existing methods fail due to these outliers, as they occupy only 0.1% of the data but significantly impact accuracy.")])]),e._v(" "),t("h3",{attrs:{id:"llm-int8-solution"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#llm-int8-solution"}},[e._v("#")]),e._v(" LLM.int8 solution")]),e._v(" "),t("p",[e._v("By isolating outliers in 16-bit operations while keeping most computations in 8-bit, the method retains full-precision inference while cutting memory usage by half.")]),e._v(" "),t("p",[e._v("The study empirically validates that LLM.int8() maintains 16-bit accuracy across models up to 175B parameters, making LLMs more accessible and practical. The method is open-sourced and integrated with Hugging Face Transformers.")]),e._v(" "),t("h3",{attrs:{id:"three-sentence-key-takeaways"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#three-sentence-key-takeaways"}},[e._v("#")]),e._v(" Three-Sentence Key Takeaways")]),e._v(" "),t("p",[e._v("LLM.int8() enables performance-preserving 8-bit quantization for transformers up to 175B parameters by combining vector-wise quantization and mixed-precision decomposition to handle emergent large-magnitude features.")]),e._v(" "),t("p",[e._v("These systematic outliers, appearing beyond 6.7B parameters, disrupt standard 8-bit quantization but can be isolated in 16-bit precision while keeping over 99.9% of computations in 8-bit, achieving a 2√ó memory reduction.")]),e._v(" "),t("p",[e._v("This allows massive models like OPT-175B and BLOOM to run efficiently on consumer GPUs, making large-scale LLM inference more accessible.")]),e._v(" "),t("hr"),e._v(" "),t("h2",{attrs:{id:"_22-637-training-deep-neural-networks-with-8-bit-floating-point-numbers"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_22-637-training-deep-neural-networks-with-8-bit-floating-point-numbers"}},[e._v("#")]),e._v(" 22.[637] Training Deep Neural Networks with 8-bit Floating Point Numbers")]),e._v(" "),t("h3",{attrs:{id:"_1-introduction-5"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-introduction-5"}},[e._v("#")]),e._v(" 1. Introduction")]),e._v(" "),t("p",[e._v("The paper addresses the challenge of training deep neural networks (DNNs) with reduced precision floating point numbers, specifically using 8-bit floating point (FP8).")]),e._v(" "),t("p",[e._v("While inference has been successfully performed with low precision (as low as 2‚Äì4 bits), training has traditionally required at least 16-bit precision due to gradient fidelity concerns.")]),e._v(" "),t("p",[e._v("The paper proposes novel techniques that allow DNN training using FP8 without accuracy loss, promising 2‚Äì4√ó improvements in energy efficiency and throughput.")]),e._v(" "),t("h3",{attrs:{id:"_2-challenges-in-low-precision-training"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-challenges-in-low-precision-training"}},[e._v("#")]),e._v(" 2. Challenges in Low-Precision Training")]),e._v(" "),t("p",[e._v("Three major challenges arise when reducing DNN training precision:")]),e._v(" "),t("ul",[t("li",[e._v("Loss of accuracy when all operands (weights, activations, errors, gradients) are quantized to 8 bits.")]),e._v(" "),t("li",[e._v("Reduced accumulation precision (moving from FP32 to FP16) significantly impacts convergence.")]),e._v(" "),t("li",[e._v("Weight updates in 16-bit may degrade accuracy unless managed properly.")])]),e._v(" "),t("p",[t("img",{attrs:{src:"https://github.com/user-attachments/assets/90a7d951-8c63-46f1-8159-1bc21964bb6c",alt:"image"}})]),e._v(" "),t("h3",{attrs:{id:"_3-proposed-solutions"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-proposed-solutions"}},[e._v("#")]),e._v(" 3. Proposed Solutions")]),e._v(" "),t("p",[e._v("The paper introduces several key innovations:")]),e._v(" "),t("ul",[t("li",[e._v("Custom FP8 Format: A new FP8 format (1-bit sign, 5-bit exponent, 2-bit mantissa) that effectively represents DNN parameters.")]),e._v(" "),t("li",[t("strong",[e._v("Chunk-Based Accumulation")]),e._v(": Breaking matrix multiplications into small chunks before accumulation to prevent truncation errors.")])]),e._v(" "),t("p",[t("img",{attrs:{src:"https://github.com/user-attachments/assets/ff65ed3e-1fce-4d12-b10c-263b4ebd29b1",alt:"image"}})]),e._v(" "),t("ul",[t("li",[e._v("Floating Point Stochastic Rounding: A rounding method that retains small numerical details to prevent loss of information.")]),e._v(" "),t("li",[e._v("Mixed-Precision Computations: Using FP8 for most computations while keeping critical accumulations and weight updates in FP16.")])]),e._v(" "),t("h3",{attrs:{id:"_4-experimental-results"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-experimental-results"}},[e._v("#")]),e._v(" 4. Experimental Results")]),e._v(" "),t("p",[e._v("The proposed FP8 training method was tested on various models, including ResNet18/50, AlexNet, and CIFAR10-CNN. Results show:")]),e._v(" "),t("ul",[t("li",[e._v("No significant accuracy loss compared to FP32.")]),e._v(" "),t("li",[e._v("Memory savings: Model sizes were reduced by ~50%.")]),e._v(" "),t("li",[e._v("Energy-efficient hardware implementation: A prototype chip demonstrated 2‚Äì4√ó efficiency gains.")])]),e._v(" "),t("h3",{attrs:{id:"_5-discussion"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-discussion"}},[e._v("#")]),e._v(" 5. Discussion")]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("The first and last layers of DNNs require higher precision (FP16) for better stability.")])]),e._v(" "),t("li",[e._v("Gradient accumulation in FP16 must be carefully handled with chunk-based summation.")]),e._v(" "),t("li",[e._v("Stochastic rounding outperforms nearest rounding in weight updates.")])]),e._v(" "),t("h3",{attrs:{id:"_6-conclusion"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-conclusion"}},[e._v("#")]),e._v(" 6. Conclusion")]),e._v(" "),t("p",[e._v("The paper successfully demonstrates DNN training with FP8 while maintaining accuracy.")]),e._v(" "),t("p",[e._v("The combination of chunk-based accumulation, stochastic rounding, and mixed-precision strategies opens the door for more efficient hardware training platforms.")]),e._v(" "),t("h3",{attrs:{id:"key-takeaways-in-3-sentences-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#key-takeaways-in-3-sentences-2"}},[e._v("#")]),e._v(" Key Takeaways in 3 Sentences")]),e._v(" "),t("p",[e._v("The paper proposes training deep neural networks using 8-bit floating point numbers by introducing a custom FP8 format, chunk-based accumulation, and stochastic rounding to prevent accuracy loss.")]),e._v(" "),t("p",[e._v("Experiments across multiple models (ResNet, AlexNet) confirm that FP8 training achieves the same accuracy as FP32 while significantly reducing memory and energy costs.")]),e._v(" "),t("p",[e._v("These innovations enable future hardware architectures with 2‚Äì4√ó improved efficiency, paving the way for practical low-precision DNN training.")]),e._v(" "),t("hr"),e._v(" "),t("h2",{attrs:{id:"_270-hybrid-8-bit-floating-point-hfp8-training-and-inference-for-deep-neural-networks"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_270-hybrid-8-bit-floating-point-hfp8-training-and-inference-for-deep-neural-networks"}},[e._v("#")]),e._v(" [270] Hybrid 8-bit Floating Point (HFP8) Training and Inference for Deep Neural Networks")]),e._v(" "),t("p",[e._v("This paper addresses the challenge of training and deploying deep neural networks (DNNs) in 8-bit precision while preserving accuracy.")]),e._v(" "),t("p",[e._v("The authors note that existing 8-bit floating point (FP8) approaches (e.g., the  (1‚àí5-2) format) can train some large-capacity networks like ResNet but struggle with compact models such as MobileNet or NLP-oriented architectures like Transformer.")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://github.com/user-attachments/assets/93af1c3c-4f98-49f0-aed5-d9c338516a5c",alt:"image"}})]),e._v(" "),t("p",[e._v("By analyzing the distinct needs of the forward pass (weights and activations) and the backward pass (gradients), they propose a hybrid FP8 (HFP8) scheme:")]),e._v(" "),t("ul",[t("li",[e._v("Forward Pass\n"),t("ul",[t("li",[e._v("Uses the (1‚àí4‚àí3) format (1 sign bit, 4 exponent bits, 3 mantissa bits) with an exponent bias of 4.")]),e._v(" "),t("li",[e._v("This format gives "),t("strong",[e._v("extra mantissa precision to minimize quantization noise for forward activations and weights")]),e._v(".")]),e._v(" "),t("li",[t("strong",[e._v("The exponent bias ensures coverage for smaller values often present in weight distributions.")])])])]),e._v(" "),t("li",[e._v("Backward Pass\n"),t("ul",[t("li",[e._v("Uses (1‚àí5‚àí2) precision (1 sign bit, 5 exponent bits, 2 mantissa bits) for gradients and errors.")]),e._v(" "),t("li",[t("strong",[e._v("The wider exponent range captures large gradient magnitudes during backpropagation")]),e._v(".")]),e._v(" "),t("li",[t("strong",[e._v("An auto-adjusted loss-scaling technique further prevents underflow or overflow of gradients in 8-bit.")])])])])]),e._v(" "),t("p",[e._v("The paper‚Äôs theoretical framework highlights how too few mantissa bits in forward activations create large quantization mismatches, which degrade training.")]),e._v(" "),t("p",[e._v("Conversely, reducing exponent bits for backward gradients risks clamping large gradient ranges. By splitting the formats, HFP8 balances mantissa fidelity in the forward path and dynamic range in the backward path.")]),e._v(" "),t("blockquote",[t("p",[e._v("The underlying reason for this choice is that forward and backward passes have different optimal balances between range and precision.\nWhile tensors in the forward pass prefer higher precision (and lower representational error), gradients in the backward pass prefer a higher dynamic range.\nWe describe our HFP8 training methodology where weights and activations adopt the (1-4-3) format (bias=4) while tensors used in backpropagation continue to be represented using the (1-5-2) format (in combination with loss\nscaling techniques pioneered by [28]).")])]),e._v(" "),t("p",[t("strong",[e._v("Additional contributions include")])]),e._v(" "),t("ul",[t("li",[e._v("Post-Training FP8 Inference "),t("br"),e._v("\nDirectly quantizing a full-precision (FP32) model to FP8 often loses accuracy. "),t("br"),e._v("\nThe authors show that re-tuning Batch Normalization statistics with a small subset of unlabeled training data recovers most or all of the lost accuracy. "),t("br"),e._v("\nFurthermore, depthwise convolutions (common in MobileNet-like architectures) and some layers with very small or large magnitudes may remain in slightly higher precision (FP16) to avoid accuracy drops. "),t("br")]),e._v(" "),t("li",[e._v("SoftMax Optimization "),t("br"),e._v("\nFor tasks like machine translation or speech recognition that rely on large final FC layers, subtracting the max logits before quantization lets the SoftMax function operate in FP8 without collapsing scores. "),t("br")]),e._v(" "),t("li",[e._v("Distributed Training "),t("br"),e._v("\nThe paper modifies standard ring-based all-reduce to exchange compressed 8-bit weights. "),t("br"),e._v("\nA local ‚Äúround-off residual‚Äù (stored in higher precision) ensures these 8-bit weight updates remain stable and converge reliably. "),t("br"),e._v("\nThe authors‚Äô hardware simulations indicate that adopting HFP8 for both computation and communication can significantly reduce training time. "),t("br")])]),e._v(" "),t("p",[e._v("Comprehensive experiments on ImageNet (ResNet, MobileNet, DenseNet, AlexNet), WMT14 En-De (Transformer), large-scale speech (LSTM), and object detection (SSD-Lite, Mask R-CNN) confirm that HFP8 preserves baseline accuracies within a fraction of a percentage point.")]),e._v(" "),t("p",[e._v("This demonstrates that 8-bit floating point is feasible not only for specialized cases but for a broad range of DNN workloads, offering substantial speedups and energy savings.")]),e._v(" "),t("p",[t("strong",[e._v("Three-Sentence Key Summary")])]),e._v(" "),t("ul",[t("li",[e._v("This paper proposes a hybrid 8-bit floating point (HFP8) approach that uses two different 8-bit formats to match the distinct precision requirements of forward (weights/activations) and backward (gradients/errors) passes.")]),e._v(" "),t("li",[e._v("It introduces practical techniques‚Äîlike Batch Normalization re-tuning, depthwise convolution in FP16, and round-off residual updates‚Äîto ensure stable training and inference in 8 bits across diverse models.")]),e._v(" "),t("li",[e._v("As a result, HFP8 achieves near-baseline accuracy on tasks ranging from image classification and object detection to machine translation and speech recognition.")])]),e._v(" "),t("hr"),e._v(" "),t("h2",{attrs:{id:"_28-read-y2025-nvidia-coat-compressing-optimizer-states-and-activation-for-memory-efficient-fp8-training"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_28-read-y2025-nvidia-coat-compressing-optimizer-states-and-activation-for-memory-efficient-fp8-training"}},[e._v("#")]),e._v(" 28. [Read Y2025 NVIDIA] Coat: Compressing Optimizer States and Activation for Memory-Efficient FP8 Training  üëç  üëç  üëç  üëç  üëç")]),e._v(" "),t("p",[t("em",[e._v("Prior studies do not tackle the memory consumption of activations and still leave the optimizer‚Äôs second-order momentum in higher precision.")])]),e._v(" "),t("p",[e._v("COAT significantly reduces the overall memory footprint by quantizing optimizer states and activations into FP8.")]),e._v(" "),t("p",[e._v("For optimizer states, we observe that "),t("strong",[e._v("FP8 format‚Äôs representation range is under-utilized when quantizing them")]),e._v(", as illustrated in Figure 2(a).")]),e._v(" "),t("p",[e._v("To address this, we introduce a novel Dynamic Range Expansion method which adjusts the distribution of optimizer states to better fit within the FP8 range, thereby minimizing quantization error.")]),e._v(" "),t("p",[e._v("For activations, we propose Mixed-Granularity Activation Quantization to achieve efficient and accurate quantization. We apply fine-grained quantization to non-linear layers and apply per-tensor quantization to linear layers.")]),e._v(" "),t("p",[e._v("Per-tensor quantization for matrix multiplications is more efficient and better suited for TensorCores, while fine-grained quantization helps maintain accuracy.")]),e._v(" "),t("p",[e._v("These two approaches tackle high memory consumption while ensuring minimal performance degradation.")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://github.com/user-attachments/assets/cc6a4e9d-fbc3-4644-aaed-82b82a7adae3",alt:"image"}})]),e._v(" "),t("blockquote",[t("p",[e._v("Prior studies: FP8-LM (Peng et al., 2023) quantizes the first-order momentum to FP8 while "),t("strong",[e._v("leaving second-order momentum in FP16, which limits the overall memory savings")]),e._v(". (Fishman et al., 2024) finds that second-order momentum is more sensitive to quantization, and proposes to quantize it using E5M2 format.")])]),e._v(" "),t("blockquote",[t("p",[e._v("In addition to quantization, there are other approaches that aim to reduce the memory footprint of the optimizer states (Shazeer & Stern, 2018; Anil et al., 2019; Chen et al., 2024; Zhao et al., 2024), such as low-rank decomposition and optimizer simplification that only store the first-order momentum. These methods are orthogonal to our approach.")])]),e._v(" "),t("p",[e._v("To perform optimizer state quantization, we adopt per-group quantization for both first-order and second-order momentum, following previous works (Dettmers et al., 2021; Li et al., 2024).")]),e._v(" "),t("p",[e._v("Every consecutive G element forms a group (G is defined as the group size), and each group is quantized independently with its own statistics.")]),e._v(" "),t("p",[e._v("Optimizer states are stored in FP8 precision, while its scaling factor is stored in BF16.")]),e._v(" "),t("p",[t("strong",[e._v("the dynamic range for first-order momentum is typically less than 1e4, and for second-order momentum, it is\nusually less than 1e1‚Äîboth far below the available range of FP8. That is what they mean by second-order momentum is underutilized FP8.")])]),e._v(" "),t("p",[t("img",{attrs:{src:"https://github.com/user-attachments/assets/3fe1c480-39a1-4392-9af0-30fb7ab5ef36",alt:"image"}})]),e._v(" "),t("p",[e._v("We propose to vary the quantization granularity across different layers to balance precision and efficiency in a mixed-granularity manner.")]),e._v(" "),t("p",[e._v("For non-linear layers, VS-Quant (Dai et al., 2021) or PerBlock Quant (Xi et al., 2024) methods are well-suited due to their fine-grained and precise nature.")]),e._v(" "),t("p",[e._v("For linear layers, we apply per-tensor quantization to maximize the performance of Tensor Cores.")]),e._v(" "),t("p",[e._v("We observe that quantizing the input of layernorm across multiple token axes is detrimental to accuracy.")]),e._v(" "),t("p",[e._v("As illustrated in Figure 4(a), when the number of elements that share a scaling factor is fixed, the quantization error increases significantly when quantization is performed across the token axis.")]),e._v(" "),t("p",[e._v("Therefore instead of using per-block quantization with block size B √ó B as proposed in (Xi et al., 2024), we propose to use per-group quantization with group size 1 √ó G, where G = B2 to keep the granularity the same.")]),e._v(" "),t("p",[e._v("This approach enhances "),t("strong",[e._v("the accuracy of non-linear layers while maintaining efficiency")]),e._v(". Our precise FP8 precision flow is visualized in Figure 1(a), where we display the full precision flow for a Llama-style decoder layer, both forward and backward pass.")]),e._v(" "),t("p",[t("em",[e._v("Note the red color in following graph, shows "),t("strong",[e._v("BF16")]),e._v(".")])]),e._v(" "),t("p",[t("img",{attrs:{src:"https://github.com/user-attachments/assets/9caf39d6-c382-4be3-8be6-9542c61dc703",alt:"image"}})])])}),[],!1,null,null,null);t.default=n.exports}}]);
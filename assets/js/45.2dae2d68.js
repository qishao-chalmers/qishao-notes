(window.webpackJsonp=window.webpackJsonp||[]).push([[45],{498:function(s,n,e){"use strict";e.r(n);var t=e(8),a=Object(t.a)({},(function(){var s=this,n=s._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[n("ul",[n("li",[s._v("libcuda\n"),n("ul",[n("li",[s._v("cuda_runtime_api.cc")])])]),s._v(" "),n("li",[s._v("src\n"),n("ul",[n("li",[s._v("abstract_hardware_model.h/cpp")]),s._v(" "),n("li",[s._v("gpgpusim_entrypoint.h/cpp")]),s._v(" "),n("li",[s._v("stream_manager.h/cpp")]),s._v(" "),n("li",[s._v("cuda-sim\n"),n("ul",[n("li",[n("p",[s._v("cuda-sim.h/cc\nðŸ\n")]),n("details",[n("summary",[s._v("Code")]),n("p"),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("void function_info::ptx_assemble() {\n for ( i=m_instructions.begin(); i != m_instructions.end(); i++ ) {\n  // map pc to instruction\n  g_pc_to_finfo[PC] = this;\n  // This is a uniform array, each entry is one instruction\n  m_instr_mem[n] = pI; \n  s_g_pc_to_insn.push_back(pI);\n  ssert(pI == s_g_pc_to_insn[PC]);\n  pI->set_m_instr_mem_index(n);\n  pI->set_PC(PC);\n }\n}\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br")])])])]),s._v(" "),n("li",[n("p",[s._v("memory.h/cc")])]),s._v(" "),n("li",[n("p",[s._v("opcode.h/def")])]),s._v(" "),n("li",[n("p",[s._v("ptx_loader.h/cc")])]),s._v(" "),n("li",[n("p",[s._v("ptx.y"),n("br"),s._v("\nIt is a Yacc/Bison grammar file used to parse PTX (Parallel Thread Execution) assembly code, which is a low-level intermediate representation used by NVIDIA GPUs."),n("br"),s._v("\nIt defines the grammar rules for PTX assembly code and specifies how different components of PTX code should be interpreted and processed."),n("br"),s._v("\nThis includes recognizing various PTX instructions, operands, directives, and control structures, and translating them into an internal representation that the simulator can work with.")]),s._v(" "),n("p",[s._v("When it meets instruction statement it will call add_instruction.\n")]),n("details",[n("summary",[s._v("Code")]),n("p"),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("statement_list: directive_statement { add_directive(); }\n| instruction_statement { add_instruction();}\n...\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br")])])])]),s._v(" "),n("li",[n("p",[s._v("ptx_parser.h/cc\nthe add_instruction used in ptx.y will call the following instruction.\n")]),n("details",[n("summary",[s._v("Code")]),n("p"),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("void add_instruction() \n{\nptx_instruction *i = new ptx_instruction(**);\ng_instructions.push_back(i);\n}\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br")])])]),s._v("\nin the end of function it will add all the instructins into function infomation\n"),n("details",[n("summary",[s._v("Code")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("void end_function()\n{\n...\ng_func_info->add_inst( g_instructions );\n...\n}\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br")])])])]),s._v(" "),n("li",[n("p",[s._v("ptx_ir.h/cc\n")]),n("details",[n("summary",[s._v("Code")]),n("p"),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("//@@@@@@ ptx_ir.h\n...\nstd::vector<const symbol*> m_args;\n// end_function will put function into this list\nstd::list<ptx_instruction*> m_instructions;\nstd::vector<basic_block_t*> m_basic_blocks;\n\n//@@@@@@ ptx_ir.cc\nvoid gpgpu_ptx_assemble( std::string kname, void *kinfo ) {\n function_info *func_info = (function_info *)kinfo;\n // This will call cuda_sim ptx_assemble function\n func_info->ptx_assemble();\n}\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br")])])])]),s._v(" "),n("li",[n("p",[s._v("ptx_sim.h/cc")])])])]),s._v(" "),n("li",[s._v("gpgpu-sim\n"),n("ul",[n("li",[s._v("gpgpu-sim.h/cc")]),s._v(" "),n("li",[s._v("shader.h/shader.cc")]),s._v(" "),n("li",[s._v("mem_fetch.h/cc")]),s._v(" "),n("li",[s._v("stack.h/cc")]),s._v(" "),n("li",[s._v("addrdec.h/cc")]),s._v(" "),n("li",[s._v("dram.h/cc")]),s._v(" "),n("li",[s._v("traffic_breakdown.h/cc")])])])])])]),s._v(" "),n("h3",{attrs:{id:"how-did-gpgpu-sim-get-instruction-from-cuda"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#how-did-gpgpu-sim-get-instruction-from-cuda"}},[s._v("#")]),s._v(" How did GPGPU-sim get instruction from CUDA?")]),s._v(" "),n("p",[s._v("ðŸ show how Yacc/Bison grammar file is used to add instruction in function_info.\nNow we will describe how GPGPU-sim execute each instructin.")]),s._v(" "),n("h4",{attrs:{id:"function-mode"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#function-mode"}},[s._v("#")]),s._v(" Function Mode")]),s._v(" "),n("p",[s._v("abstract_hardware_model.cc implement this function, if you provde a warpId, it can return warp_instruction."),n("br"),s._v("\nThus, if we know next pc, we can use ptx_fetch_inst to get instruction.\n")]),n("details",[n("summary",[s._v("Code")]),n("p"),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("// @@@@@@ abstract_hardware_model.cc\n//! Get the warp to be executed using the data taken form the SIMT stack\nwarp_inst_t core_t::getExecuteWarp(unsigned warpId)\n{\n    unsigned pc,rpc;\n    m_simt_stack[warpId]->get_pdom_stack_top_info(&pc,&rpc);\n    warp_inst_t wi= *ptx_fetch_inst(pc);\n    wi.set_active(m_simt_stack[warpId]->get_active_mask());\n    return wi;\n}\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br")])])]),s._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[s._v("      gpgpu*_sim_main_function\n                 |\n    gpgpu_cuda_ptx_sim_main_func\n                 |\n              execute\n                 |\n            executeWarp\n                 |\n   getExecuteWarp execute_warp_inst_t\n")])])]),n("details",[n("summary",[s._v("Code")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("// @@@@@@ gpgpusim_entrypoint.cc\nint gpgpu_opencl_ptx_sim_main_func( kernel_info_t *grid )\n{\n    //calling the CUDA PTX simulator, sending the kernel by reference and a flag set to true,\n    //the flag used by the function to distinguish OpenCL calls from the CUDA simulation calls which\n    //it is needed by the called function to not register the exit the exit of OpenCL kernel as it doesn't register entering in the first place as the CUDA kernels does\n   gpgpu_cuda_ptx_sim_main_func( *grid, true );\n   return 0;\n}\n\n// @@@@@@ cuda-sim.cc\n/*!\nThis function simulates the CUDA code functionally, it takes a kernel_info_t parameter \nwhich holds the data for the CUDA kernel to be executed\n!*/\nvoid gpgpu_cuda_ptx_sim_main_func( kernel_info_t &kernel, bool openCL ) {\n  while(!kernel.no_more_ctas_to_run()){\n    functionalCoreSim cta(&kernel,g_the_gpu,\n    g_the_gpu->getShaderCoreConfig()->warp_size\n    );\n    cta.execute();\n }\n}\n\n\nvoid functionalCoreSim::execute()\n {\n    ...\n    //start executing the CTA\n    while(true){\n        ...\n        for(unsigned i=0;i<m_warp_count;i++){\n            executeWarp(i,allAtBarrier,someOneLive);\n        }\n        ...\n    }\n }\n\nvoid functionalCoreSim::executeWarp(unsigned i, bool &allAtBarrier, bool & someOneLive)\n{\n ...\n warp_inst_t inst =getExecuteWarp(i);\n //!!!!! Attention !!!!!!!!\n execute_warp_inst_t(inst,i);\n ...\n updateSIMTStack( i, &inst );\n}\n\nconst warp_inst_t *ptx_fetch_inst( address_type pc )\n{\n    return function_info::pc_to_instruction(pc);\n}\n\n// @@@@@@ ptx_ir.h\nstatic const ptx_instruction* pc_to_instruction(unsigned pc) \n{\n  if( pc < s_g_pc_to_insn.size() )\n      return s_g_pc_to_insn[pc];\n  else\n      return NULL;\n}\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br"),n("span",{staticClass:"line-number"},[s._v("22")]),n("br"),n("span",{staticClass:"line-number"},[s._v("23")]),n("br"),n("span",{staticClass:"line-number"},[s._v("24")]),n("br"),n("span",{staticClass:"line-number"},[s._v("25")]),n("br"),n("span",{staticClass:"line-number"},[s._v("26")]),n("br"),n("span",{staticClass:"line-number"},[s._v("27")]),n("br"),n("span",{staticClass:"line-number"},[s._v("28")]),n("br"),n("span",{staticClass:"line-number"},[s._v("29")]),n("br"),n("span",{staticClass:"line-number"},[s._v("30")]),n("br"),n("span",{staticClass:"line-number"},[s._v("31")]),n("br"),n("span",{staticClass:"line-number"},[s._v("32")]),n("br"),n("span",{staticClass:"line-number"},[s._v("33")]),n("br"),n("span",{staticClass:"line-number"},[s._v("34")]),n("br"),n("span",{staticClass:"line-number"},[s._v("35")]),n("br"),n("span",{staticClass:"line-number"},[s._v("36")]),n("br"),n("span",{staticClass:"line-number"},[s._v("37")]),n("br"),n("span",{staticClass:"line-number"},[s._v("38")]),n("br"),n("span",{staticClass:"line-number"},[s._v("39")]),n("br"),n("span",{staticClass:"line-number"},[s._v("40")]),n("br"),n("span",{staticClass:"line-number"},[s._v("41")]),n("br"),n("span",{staticClass:"line-number"},[s._v("42")]),n("br"),n("span",{staticClass:"line-number"},[s._v("43")]),n("br"),n("span",{staticClass:"line-number"},[s._v("44")]),n("br"),n("span",{staticClass:"line-number"},[s._v("45")]),n("br"),n("span",{staticClass:"line-number"},[s._v("46")]),n("br"),n("span",{staticClass:"line-number"},[s._v("47")]),n("br"),n("span",{staticClass:"line-number"},[s._v("48")]),n("br"),n("span",{staticClass:"line-number"},[s._v("49")]),n("br"),n("span",{staticClass:"line-number"},[s._v("50")]),n("br"),n("span",{staticClass:"line-number"},[s._v("51")]),n("br"),n("span",{staticClass:"line-number"},[s._v("52")]),n("br"),n("span",{staticClass:"line-number"},[s._v("53")]),n("br"),n("span",{staticClass:"line-number"},[s._v("54")]),n("br"),n("span",{staticClass:"line-number"},[s._v("55")]),n("br"),n("span",{staticClass:"line-number"},[s._v("56")]),n("br"),n("span",{staticClass:"line-number"},[s._v("57")]),n("br"),n("span",{staticClass:"line-number"},[s._v("58")]),n("br"),n("span",{staticClass:"line-number"},[s._v("59")]),n("br"),n("span",{staticClass:"line-number"},[s._v("60")]),n("br"),n("span",{staticClass:"line-number"},[s._v("61")]),n("br")])])]),s._v(" "),n("h4",{attrs:{id:"timing-mode"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#timing-mode"}},[s._v("#")]),s._v(" Timing Mode")]),s._v(" "),n("ul",[n("li",[s._v("shader.cc decode() fill instruction into ibuffer")]),s._v(" "),n("li",[s._v("shader.h filled into m_ibuffer")]),s._v(" "),n("li",[s._v("shader.cc cycle issue warp")])]),s._v(" "),n("details",[n("summary",[s._v("Code")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("// @@@@@@ shader.cc\nvoid shader_core_ctx::decode()\n{\n    if( m_inst_fetch_buffer.m_valid ) {\n        // decode 1 or 2 instructions and place them into ibuffer\n        address_type pc = m_inst_fetch_buffer.m_pc;\n        const warp_inst_t* pI1 = ptx_fetch_inst(pc);\n        m_warp[m_inst_fetch_buffer.m_warp_id].ibuffer_fill(0,pI1);\n        m_warp[m_inst_fetch_buffer.m_warp_id].inc_inst_in_pipeline();\n        ...\n    }\n}\n\n// @@@@@@ shader.h\n    void ibuffer_fill( unsigned slot, const warp_inst_t *pI )\n    {\n       m_ibuffer[slot].m_inst=pI;\n       m_ibuffer[slot].m_valid=true;\n    }\n\n    const warp_inst_t *ibuffer_next_inst() { return m_ibuffer[m_next].m_inst; }\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br")])]),n("p",[s._v("Every cycle, if current warp is done, it will pick form the m_next_cycle_prioritized_warps to schedule next warp."),n("br"),s._v("\nThe instruction is obtained from m_ibuffer.")]),s._v(" "),n("details",[n("summary",[s._v("Code")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("void scheduler_unit::cycle()\n{\n    SCHED_DPRINTF( \"scheduler_unit::cycle()\\n\" );\n    bool valid_inst = false;  // there was one warp with a valid instruction to issue (didn't require flush due to control hazard)\n    bool ready_inst = false;  // of the valid instructions, there was one not waiting for pending register writes\n    bool issued_inst = false; // of these we issued one\n\n    order_warps();\n    for ( std::vector< shd_warp_t* >::const_iterator iter = m_next_cycle_prioritized_warps.begin();\n          iter != m_next_cycle_prioritized_warps.end();\n          iter++ ) {\n        // Don't consider warps that are not yet valid\n        if ( (*iter) == NULL || (*iter)->done_exit() ) {\n            continue;\n        }\n        while( !warp(warp_id).waiting() && !warp(warp_id).ibuffer_empty() && (checked < max_issue) && (checked <= issued) && (issued < max_issue) ) {\n            const warp_inst_t *pI = warp(warp_id).ibuffer_next_inst();\n            if( pI ) {\n            ...\n              if ( (pI->op == LOAD_OP) || (pI->op == STORE_OP) || (pI->op == MEMORY_BARRIER_OP) ) {\n                m_shader->issue_warp(*m_mem_out,pI,active_mask,warp_id);\n                issued++;\n                issued_inst=true;\n                warp_inst_issued = true;\n              } else if ( (pI->op == SFU_OP) || (pI->op == ALU_SFU_OP) ) {\n                m_shader->issue_warp(*m_sfu_out,pI,active_mask,warp_id);\n              }\n            }\n        }\n    }\n  }\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br"),n("span",{staticClass:"line-number"},[s._v("22")]),n("br"),n("span",{staticClass:"line-number"},[s._v("23")]),n("br"),n("span",{staticClass:"line-number"},[s._v("24")]),n("br"),n("span",{staticClass:"line-number"},[s._v("25")]),n("br"),n("span",{staticClass:"line-number"},[s._v("26")]),n("br"),n("span",{staticClass:"line-number"},[s._v("27")]),n("br"),n("span",{staticClass:"line-number"},[s._v("28")]),n("br"),n("span",{staticClass:"line-number"},[s._v("29")]),n("br"),n("span",{staticClass:"line-number"},[s._v("30")]),n("br"),n("span",{staticClass:"line-number"},[s._v("31")]),n("br")])])])])])}),[],!1,null,null,null);n.default=a.exports}}]);
(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{490:function(e,n,s){"use strict";s.r(n);var a=s(9),t=Object(a.a)({},(function(){var e=this,n=e._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h3",{attrs:{id:"chapter-1-toy-language-and-ast"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#chapter-1-toy-language-and-ast"}},[e._v("#")]),e._v(" Chapter 1. Toy Language and AST")]),e._v(" "),n("p",[e._v("Lexer and recursive descent parser construt AST")]),e._v(" "),n("h3",{attrs:{id:"chapter-2-emit-basic-mlir"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#chapter-2-emit-basic-mlir"}},[e._v("#")]),e._v(" Chapter 2. Emit Basic MLIR")]),e._v(" "),n("p",[e._v("Operations: instructions, globals(functions), modules, in LLVM")]),e._v(" "),n("p",[n("img",{attrs:{src:"https://github.com/user-attachments/assets/1547200e-1e13-4075-b202-77be37cf0b74",alt:"image"}}),e._v("\nFrom "),n("a",{attrs:{href:"https://medium.com/sniper-ai/mlir-tutorial-create-your-custom-dialect-lowering-to-llvm-ir-dialect-system-1-1f125a6a3008",target:"_blank",rel:"noopener noreferrer"}},[e._v("link"),n("OutboundLink")],1)]),e._v(" "),n("p",[e._v("Transpose Operation")]),e._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('%t_tensor = "toy.transpose"(%tensor) {inplace = true} : (tensor<2x3xf64>) ->\ntensor<3x2xf64> loc("example/file/path":12:1)\n')])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br"),n("span",{staticClass:"line-number"},[e._v("2")]),n("br")])]),n("p",[e._v("meaning of each part")]),e._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("result  = name of operation (input operands) dictionary of traits :\ntype of operations (input and output), location\n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br"),n("span",{staticClass:"line-number"},[e._v("2")]),n("br")])]),n("ul",[n("li",[e._v("A name for the operation.")]),e._v(" "),n("li",[e._v("A list of SSA operand values.")]),e._v(" "),n("li",[e._v("A list of attributes.")]),e._v(" "),n("li",[e._v("A list of types for result values.")]),e._v(" "),n("li",[e._v("A source location for debugging purposes.")]),e._v(" "),n("li",[e._v("A list of successors blocks (for branches, mostly).")]),e._v(" "),n("li",[e._v("A list of regions (for structural operations like functions).")])]),e._v(" "),n("p",[n("strong",[e._v("Opaque API")])]),e._v(" "),n("p",[n("strong",[e._v("Define a Toy Dialect")])]),e._v(" "),n("p",[e._v("dialect could be defined by c++ or tablegen(declarative specification).")]),e._v(" "),n("p",[e._v("after the definiation, it could be loaded to MLIR Context.\ncontext.loadDialect"),n("ToyDialect",[e._v("();")])],1),e._v(" "),n("p",[n("strong",[e._v("Defining Toy Operations")])]),e._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("class ConstantOp : public mlir::Op<\n                     /// `mlir::Op` is a CRTP class, meaning that we provide the\n                     /// derived class as a template parameter.\n                     ConstantOp,\n                     /// The ConstantOp takes zero input operands.\n                     mlir::OpTrait::ZeroOperands,\n                     /// The ConstantOp returns a single result.\n                     mlir::OpTrait::OneResult,\n                     /// We also provide a utility `getType` accessor that\n                     /// returns the TensorType of the single result.\n                     mlir::OpTraits::OneTypedResult<TensorType>::Impl> {\n\n public:\n  /// Inherit the constructors from the base Op class.\n  using Op::Op;\n  ...\n  static void build(mlir::OpBuilder &builder, mlir::OperationState &state,\n                    mlir::Type result, mlir::DenseElementsAttr value);\n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br"),n("span",{staticClass:"line-number"},[e._v("2")]),n("br"),n("span",{staticClass:"line-number"},[e._v("3")]),n("br"),n("span",{staticClass:"line-number"},[e._v("4")]),n("br"),n("span",{staticClass:"line-number"},[e._v("5")]),n("br"),n("span",{staticClass:"line-number"},[e._v("6")]),n("br"),n("span",{staticClass:"line-number"},[e._v("7")]),n("br"),n("span",{staticClass:"line-number"},[e._v("8")]),n("br"),n("span",{staticClass:"line-number"},[e._v("9")]),n("br"),n("span",{staticClass:"line-number"},[e._v("10")]),n("br"),n("span",{staticClass:"line-number"},[e._v("11")]),n("br"),n("span",{staticClass:"line-number"},[e._v("12")]),n("br"),n("span",{staticClass:"line-number"},[e._v("13")]),n("br"),n("span",{staticClass:"line-number"},[e._v("14")]),n("br"),n("span",{staticClass:"line-number"},[e._v("15")]),n("br"),n("span",{staticClass:"line-number"},[e._v("16")]),n("br"),n("span",{staticClass:"line-number"},[e._v("17")]),n("br"),n("span",{staticClass:"line-number"},[e._v("18")]),n("br")])]),n("p",[e._v("register operation:")]),e._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("void ToyDialect::initialize() {\n  addOperations<ConstantOp>();\n}\n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br"),n("span",{staticClass:"line-number"},[e._v("2")]),n("br"),n("span",{staticClass:"line-number"},[e._v("3")]),n("br")])]),n("p",[n("strong",[e._v("Op vs Operation: Using MLIR Operations")])]),e._v(" "),n("p",[n("strong",[e._v("Using Operation Definition Specification Framwork")])]),e._v(" "),n("p",[e._v("base Toy_Op")]),e._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("class Toy_Op<string mnemonic, list<Trait> traits = []> :\n    Op<Toy_Dialect, mnemonic, traits>;\n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br"),n("span",{staticClass:"line-number"},[e._v("2")]),n("br")])]),n("p",[e._v("ConstantOp")]),e._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('def ConstantOp : Toy_Op<"constant"> {\n}\n')])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br"),n("span",{staticClass:"line-number"},[e._v("2")]),n("br")])]),n("p",[n("strong",[e._v("Attaching build Methods")])]),e._v(" "),n("p",[e._v("In ConstantOp, it declared a list of build. ODS will generate the first build."),n("br"),e._v("\nAs to other builds, we have to atttach.")]),e._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('def ConstantOp : Toy_Op<"constant"> {\n  ...\n\n  // Add custom build methods for the constant operation. These methods populate\n  // the `state` that MLIR uses to create operations, i.e. these are used when\n  // using `builder.create<ConstantOp>(...)`.\n  let builders = [\n    // Build a constant with a given constant tensor value.\n    OpBuilder<(ins "DenseElementsAttr":$value), [{\n      // Call into an autogenerated `build` method.\n      build(builder, result, value.getType(), value);\n    }]>,\n\n    // Build a constant with a given constant floating-point value. This builder\n    // creates a declaration for `ConstantOp::build` with the given parameters.\n    OpBuilder<(ins "double":$value)>\n  ];\n}\n')])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br"),n("span",{staticClass:"line-number"},[e._v("2")]),n("br"),n("span",{staticClass:"line-number"},[e._v("3")]),n("br"),n("span",{staticClass:"line-number"},[e._v("4")]),n("br"),n("span",{staticClass:"line-number"},[e._v("5")]),n("br"),n("span",{staticClass:"line-number"},[e._v("6")]),n("br"),n("span",{staticClass:"line-number"},[e._v("7")]),n("br"),n("span",{staticClass:"line-number"},[e._v("8")]),n("br"),n("span",{staticClass:"line-number"},[e._v("9")]),n("br"),n("span",{staticClass:"line-number"},[e._v("10")]),n("br"),n("span",{staticClass:"line-number"},[e._v("11")]),n("br"),n("span",{staticClass:"line-number"},[e._v("12")]),n("br"),n("span",{staticClass:"line-number"},[e._v("13")]),n("br"),n("span",{staticClass:"line-number"},[e._v("14")]),n("br"),n("span",{staticClass:"line-number"},[e._v("15")]),n("br"),n("span",{staticClass:"line-number"},[e._v("16")]),n("br"),n("span",{staticClass:"line-number"},[e._v("17")]),n("br"),n("span",{staticClass:"line-number"},[e._v("18")]),n("br")])]),n("p",[n("strong",[e._v("Specifying a Custom Assembly Format")])]),e._v(" "),n("p",[e._v("The printout version of IR has too much information.")]),e._v(" "),n("p",[e._v("We can strip out by implementing our owne oversion of print and parse function.")]),e._v(" "),n("p",[e._v("Take PrintOp as example.")]),e._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('void PrintOp::print(mlir::OpAsmPrinter &printer) {\n  printer << "toy.print " << op.input();\n  printer.printOptionalAttrDict(op.getAttrs());\n  printer << " : " << op.input().getType();\n}\n\nmlir::ParseResult PrintOp::parse(mlir::OpAsmParser &parser,\n                                 mlir::OperationState &result) {\n...\n}\n')])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br"),n("span",{staticClass:"line-number"},[e._v("2")]),n("br"),n("span",{staticClass:"line-number"},[e._v("3")]),n("br"),n("span",{staticClass:"line-number"},[e._v("4")]),n("br"),n("span",{staticClass:"line-number"},[e._v("5")]),n("br"),n("span",{staticClass:"line-number"},[e._v("6")]),n("br"),n("span",{staticClass:"line-number"},[e._v("7")]),n("br"),n("span",{staticClass:"line-number"},[e._v("8")]),n("br"),n("span",{staticClass:"line-number"},[e._v("9")]),n("br"),n("span",{staticClass:"line-number"},[e._v("10")]),n("br")])]),n("h3",{attrs:{id:"chapter-3-high-level-language-specific-analysis-and-transformation"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#chapter-3-high-level-language-specific-analysis-and-transformation"}},[e._v("#")]),e._v(" Chapter 3. High-level Language-Specific Analysis and Transformation")]),e._v(" "),n("ul",[n("li",[e._v("Imperative, C++ Pattern match and Rewrite")]),e._v(" "),n("li",[e._v("Decalrative, rule-based pattern-match and rewrite using table-driven")])]),e._v(" "),n("p",[n("strong",[e._v("C++")])]),e._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("/// Fold transpose(transpose(x)) -> x\nstruct SimplifyRedundantTranspose : public mlir::OpRewritePattern<TransposeOp> {\n  SimplifyRedundantTranspose(mlir::MLIRContext *context)\n      : OpRewritePattern<TransposeOp>(context, /*benefit=*/1) {}\n  llvm::LogicalResult\n  matchAndRewrite(TransposeOp op,\n                  mlir::PatternRewriter &rewriter) const override {\n    // Look through the input of the current transpose.\n  ....\n  }\n};\n\n// Register our patterns for rewrite by the Canonicalization framework.\nvoid TransposeOp::getCanonicalizationPatterns(\n    RewritePatternSet &results, MLIRContext *context) {\n  results.add<SimplifyRedundantTranspose>(context);\n}\n\n// Add into Pass Manager\nmlir::PassManager pm(module->getName());\npm.addNestedPass<mlir::toy::FuncOp>(mlir::createCanonicalizerPass());\n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br"),n("span",{staticClass:"line-number"},[e._v("2")]),n("br"),n("span",{staticClass:"line-number"},[e._v("3")]),n("br"),n("span",{staticClass:"line-number"},[e._v("4")]),n("br"),n("span",{staticClass:"line-number"},[e._v("5")]),n("br"),n("span",{staticClass:"line-number"},[e._v("6")]),n("br"),n("span",{staticClass:"line-number"},[e._v("7")]),n("br"),n("span",{staticClass:"line-number"},[e._v("8")]),n("br"),n("span",{staticClass:"line-number"},[e._v("9")]),n("br"),n("span",{staticClass:"line-number"},[e._v("10")]),n("br"),n("span",{staticClass:"line-number"},[e._v("11")]),n("br"),n("span",{staticClass:"line-number"},[e._v("12")]),n("br"),n("span",{staticClass:"line-number"},[e._v("13")]),n("br"),n("span",{staticClass:"line-number"},[e._v("14")]),n("br"),n("span",{staticClass:"line-number"},[e._v("15")]),n("br"),n("span",{staticClass:"line-number"},[e._v("16")]),n("br"),n("span",{staticClass:"line-number"},[e._v("17")]),n("br"),n("span",{staticClass:"line-number"},[e._v("18")]),n("br"),n("span",{staticClass:"line-number"},[e._v("19")]),n("br"),n("span",{staticClass:"line-number"},[e._v("20")]),n("br"),n("span",{staticClass:"line-number"},[e._v("21")]),n("br")])]),n("p",[n("strong",[e._v("rule-based pattern-match and rewrite (DRR)")])]),e._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('def TypesAreIdentical : Constraint<CPred<"$0.getType() == $1.getType()">>;\ndef RedundantReshapeOptPattern : Pat<\n  (ReshapeOp:$res $arg), (replaceWithValue $arg),\n  [(TypesAreIdentical $res, $arg)]>;\n')])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br"),n("span",{staticClass:"line-number"},[e._v("2")]),n("br"),n("span",{staticClass:"line-number"},[e._v("3")]),n("br"),n("span",{staticClass:"line-number"},[e._v("4")]),n("br")])]),n("h3",{attrs:{id:"chapter-4-enabling-generic-transformation-with-interfaces"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#chapter-4-enabling-generic-transformation-with-interfaces"}},[e._v("#")]),e._v(" Chapter 4. Enabling Generic Transformation with Interfaces")]),e._v(" "),n("p",[e._v("If you still remember correctly, in last chapter, we register "),n("em",[e._v("SimplifyRedundantTranspose")]),e._v(" into getCanonicalizationPatterns"),n("br"),e._v("\nwhich "),n("em",[e._v("applies transformations defined by operations in a greedy, iterative manner")]),e._v(".")]),e._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("void TransposeOp::getCanonicalizationPatterns(\n    RewritePatternSet &results, MLIRContext *context) {\n  results.add<SimplifyRedundantTranspose>(context);\n}\n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br"),n("span",{staticClass:"line-number"},[e._v("2")]),n("br"),n("span",{staticClass:"line-number"},[e._v("3")]),n("br"),n("span",{staticClass:"line-number"},[e._v("4")]),n("br")])]),n("p",[e._v("This is not scalable.")]),e._v(" "),n("p",[n("strong",[e._v("Shape Inference: Preparing for Code Generation")])]),e._v(" "),n("p",[e._v("This starts from an example of inlining all function calls to perform intraprocedural shape propagation.")]),e._v(" "),n("p",[n("strong",[e._v("Inlining")])]),e._v(" "),n("p",[e._v("MLIR provide a generic inliner algorithm that dialects can plug into.")]),e._v(" "),n("p",[e._v("In toy, we need to provide interfaces so the inliner could hook into.")]),e._v(" "),n("ol",[n("li",[e._v("The first, we need to define constraints on inlining operations.")])]),e._v(" "),n("p",[e._v("Define a interface, which is a class containing a set of virtual hooks which the dialects can override.")]),e._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("struct ToyInlinerInterface : public DialectInlinerInterface {\n  using DialectInlinerInterface::DialectInlinerInterface;\n  ...\n  // check whether the region is able to inline\n  isLegalToInline();\n  ...\n  void handleTerminator(Operation *op,\n                        MutableArrayRef<Value> valuesToRepl)\n  ...\n}\n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br"),n("span",{staticClass:"line-number"},[e._v("2")]),n("br"),n("span",{staticClass:"line-number"},[e._v("3")]),n("br"),n("span",{staticClass:"line-number"},[e._v("4")]),n("br"),n("span",{staticClass:"line-number"},[e._v("5")]),n("br"),n("span",{staticClass:"line-number"},[e._v("6")]),n("br"),n("span",{staticClass:"line-number"},[e._v("7")]),n("br"),n("span",{staticClass:"line-number"},[e._v("8")]),n("br"),n("span",{staticClass:"line-number"},[e._v("9")]),n("br"),n("span",{staticClass:"line-number"},[e._v("10")]),n("br")])]),n("ol",{attrs:{start:"2"}},[n("li",[e._v("Register dialect interface on to TOY dialect.")])]),e._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("void ToyDialect::initialize() {\n  addInterfaces<ToyInlinerInterface>();\n}\n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br"),n("span",{staticClass:"line-number"},[e._v("2")]),n("br"),n("span",{staticClass:"line-number"},[e._v("3")]),n("br")])]),n("ol",{attrs:{start:"3"}},[n("li",[e._v("We need a way to inform inliner that toy.generic_call is a "),n("em",[e._v("call")]),e._v(" and toy.func is "),n("em",[e._v("function")]),e._v(".")])]),e._v(" "),n("p",[e._v("We achieve this goal by operation interface, marking they are callable or callop.")]),e._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('include "mlir/Interfaces/CallInterfaces.td"\n\ndef FuncOp : Toy_Op<"func",\n    [DeclareOpInterfaceMethods<CallableOpInterface>]> {\n  ...\n}\n\ndef GenericCallOp : Toy_Op<"generic_call",\n    [DeclareOpInterfaceMethods<CallOpInterface>]> {\n  ...\n}\n')])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br"),n("span",{staticClass:"line-number"},[e._v("2")]),n("br"),n("span",{staticClass:"line-number"},[e._v("3")]),n("br"),n("span",{staticClass:"line-number"},[e._v("4")]),n("br"),n("span",{staticClass:"line-number"},[e._v("5")]),n("br"),n("span",{staticClass:"line-number"},[e._v("6")]),n("br"),n("span",{staticClass:"line-number"},[e._v("7")]),n("br"),n("span",{staticClass:"line-number"},[e._v("8")]),n("br"),n("span",{staticClass:"line-number"},[e._v("9")]),n("br"),n("span",{staticClass:"line-number"},[e._v("10")]),n("br"),n("span",{staticClass:"line-number"},[e._v("11")]),n("br")])]),n("p",[e._v("The above "),n("em",[e._v("DeclareOpInterfaceMethods")]),e._v(" directive auto-declares all of the interface methods in the class declaration of GenericCallOp.")]),e._v(" "),n("p",[e._v("Then we need to fill in the definitions:")]),e._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("...\nRegion *FuncOp::getCallableRegion()\n...\nCallInterfaceCallable GenericCallOp::getCallableForCallee()\n...\nGenericCallOp::setCalleeFromCallable(CallInterfaceCallable callee)\n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br"),n("span",{staticClass:"line-number"},[e._v("2")]),n("br"),n("span",{staticClass:"line-number"},[e._v("3")]),n("br"),n("span",{staticClass:"line-number"},[e._v("4")]),n("br"),n("span",{staticClass:"line-number"},[e._v("5")]),n("br"),n("span",{staticClass:"line-number"},[e._v("6")]),n("br")])]),n("ol",{attrs:{start:"4"}},[n("li",[e._v("Now the inliner has been informed about the Toy dialect.")])]),e._v(" "),n("p",[e._v("add the inlinerpasser to pass manager")]),e._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("pm.addPass(mlir::createInlinerPass());\n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br")])]),n("ol",{attrs:{start:"5"}},[n("li",[e._v("Considering the input of the transpose function is different from argument.")])]),e._v(" "),n("p",[e._v("Then they define a cast Op to cast between different shapes.")]),e._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('def CastOp : Toy_Op<"cast", [\n    DeclareOpInterfaceMethods<CastOpInterface>,\n    Pure,\n    SameOperandsAndResultShape]\n\n > {\n...\n}\n')])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br"),n("span",{staticClass:"line-number"},[e._v("2")]),n("br"),n("span",{staticClass:"line-number"},[e._v("3")]),n("br"),n("span",{staticClass:"line-number"},[e._v("4")]),n("br"),n("span",{staticClass:"line-number"},[e._v("5")]),n("br"),n("span",{staticClass:"line-number"},[e._v("6")]),n("br"),n("span",{staticClass:"line-number"},[e._v("7")]),n("br"),n("span",{staticClass:"line-number"},[e._v("8")]),n("br")])]),n("p",[e._v("Notice that CastOp add CastOpInterface into traits lists.")]),e._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("/// Returns true if the given set of input and result types are compatible with\n/// this cast operation. This is required by the `CastOpInterface` to verify\n/// this operation and provide other additional utilities.\nbool CastOp::areCastCompatible(TypeRange inputs, TypeRange outputs) {\n...\n}\n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br"),n("span",{staticClass:"line-number"},[e._v("2")]),n("br"),n("span",{staticClass:"line-number"},[e._v("3")]),n("br"),n("span",{staticClass:"line-number"},[e._v("4")]),n("br"),n("span",{staticClass:"line-number"},[e._v("5")]),n("br"),n("span",{staticClass:"line-number"},[e._v("6")]),n("br")])]),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("struct ToyInlinerInterface : public DialectInlinerInterface {\n  ...\n\n  /// Attempts to materialize a conversion for a type mismatch between a call\n  /// from this dialect, and a callable region. This method should generate an\n  /// operation that takes 'input' as the only operand, and produces a single\n  /// result of 'resultType'. If a conversion can not be generated, nullptr\n  /// should be returned.\n  Operation *materializeCallConversion(OpBuilder &builder, Value input,\n                                       Type resultType,\n                                       Location conversionLoc) const final {\n    return builder.create<CastOp>(conversionLoc, resultType, input);\n  }\n};\n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br"),n("span",{staticClass:"line-number"},[e._v("2")]),n("br"),n("span",{staticClass:"line-number"},[e._v("3")]),n("br"),n("span",{staticClass:"line-number"},[e._v("4")]),n("br"),n("span",{staticClass:"line-number"},[e._v("5")]),n("br"),n("span",{staticClass:"line-number"},[e._v("6")]),n("br"),n("span",{staticClass:"line-number"},[e._v("7")]),n("br"),n("span",{staticClass:"line-number"},[e._v("8")]),n("br"),n("span",{staticClass:"line-number"},[e._v("9")]),n("br"),n("span",{staticClass:"line-number"},[e._v("10")]),n("br"),n("span",{staticClass:"line-number"},[e._v("11")]),n("br"),n("span",{staticClass:"line-number"},[e._v("12")]),n("br"),n("span",{staticClass:"line-number"},[e._v("13")]),n("br"),n("span",{staticClass:"line-number"},[e._v("14")]),n("br")])]),n("p",[e._v("Then, the output is as expected.")]),e._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("toy.func @main() {\n  %0 = toy.constant dense<[[1.000000e+00, 2.000000e+00, 3.000000e+00], [4.000000e+00, 5.000000e+00, 6.000000e+00]]> : tensor<2x3xf64>\n  %1 = toy.constant dense<[[1.000000e+00, 2.000000e+00, 3.000000e+00], [4.000000e+00, 5.000000e+00, 6.000000e+00]]> : tensor<2x3xf64>\n  %2 = toy.cast %1 : tensor<2x3xf64> to tensor<*xf64>\n  %3 = toy.cast %0 : tensor<2x3xf64> to tensor<*xf64>\n  %4 = toy.transpose(%2 : tensor<*xf64>) to tensor<*xf64>\n  %5 = toy.transpose(%3 : tensor<*xf64>) to tensor<*xf64>\n  %6 = toy.mul %4, %5 : tensor<*xf64>\n  toy.print %6 : tensor<*xf64>\n  toy.return\n}\n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br"),n("span",{staticClass:"line-number"},[e._v("2")]),n("br"),n("span",{staticClass:"line-number"},[e._v("3")]),n("br"),n("span",{staticClass:"line-number"},[e._v("4")]),n("br"),n("span",{staticClass:"line-number"},[e._v("5")]),n("br"),n("span",{staticClass:"line-number"},[e._v("6")]),n("br"),n("span",{staticClass:"line-number"},[e._v("7")]),n("br"),n("span",{staticClass:"line-number"},[e._v("8")]),n("br"),n("span",{staticClass:"line-number"},[e._v("9")]),n("br"),n("span",{staticClass:"line-number"},[e._v("10")]),n("br"),n("span",{staticClass:"line-number"},[e._v("11")]),n("br")])]),n("p",[n("strong",[e._v("Intraprocedural Shape Inference")])]),e._v(" "),n("p",[e._v("Current state: all function has been inlined and mixed with static and dynamic shaped operations.")]),e._v(" "),n("p",[e._v("The shape propagation should be generic to many dialects.")]),e._v(" "),n("p",[n("em",[e._v("Operation Interface")])]),e._v(" "),n("p",[e._v("We could define this by:")]),e._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('def ShapeInferenceOpInterface : OpInterface<"ShapeInference"> {\n  let description = [{\n    Interface to access a registered method to infer the return types for an\n    operation that can be used during type inference.\n  }];\n\n  let methods = [\n    InterfaceMethod<"Infer and set the output shape for the current operation.",\n                    "void", "inferShapes">\n  ];\n\n}\n')])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br"),n("span",{staticClass:"line-number"},[e._v("2")]),n("br"),n("span",{staticClass:"line-number"},[e._v("3")]),n("br"),n("span",{staticClass:"line-number"},[e._v("4")]),n("br"),n("span",{staticClass:"line-number"},[e._v("5")]),n("br"),n("span",{staticClass:"line-number"},[e._v("6")]),n("br"),n("span",{staticClass:"line-number"},[e._v("7")]),n("br"),n("span",{staticClass:"line-number"},[e._v("8")]),n("br"),n("span",{staticClass:"line-number"},[e._v("9")]),n("br"),n("span",{staticClass:"line-number"},[e._v("10")]),n("br"),n("span",{staticClass:"line-number"},[e._v("11")]),n("br"),n("span",{staticClass:"line-number"},[e._v("12")]),n("br")])]),n("p",[e._v("Then we add interface to necessary Toy Operations.")]),e._v(" "),n("p",[e._v("This is simple to add "),n("em",[e._v("CallOpInterface")]),e._v(" to GenericCallOp.")]),e._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('def MulOp : Toy_Op<"mul",\n    [..., DeclareOpInterfaceMethods<ShapeInferenceOpInterface>]> {\n  ...\n}\n')])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br"),n("span",{staticClass:"line-number"},[e._v("2")]),n("br"),n("span",{staticClass:"line-number"},[e._v("3")]),n("br"),n("span",{staticClass:"line-number"},[e._v("4")]),n("br")])]),n("p",[e._v("As to the operations has been added the interface, we need to provide definition of the method.")]),e._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("void MulOp::inferShapes() { getResult().setType(getLhs().getType()); }\n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br")])]),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("class ShapeInferencePass\n    : public mlir::PassWrapper<ShapeInferencePass, OperationPass<FuncOp>> {\n  void runOnOperation() override {\n    FuncOp function = getOperation();\n    ...\n  }\n};\n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br"),n("span",{staticClass:"line-number"},[e._v("2")]),n("br"),n("span",{staticClass:"line-number"},[e._v("3")]),n("br"),n("span",{staticClass:"line-number"},[e._v("4")]),n("br"),n("span",{staticClass:"line-number"},[e._v("5")]),n("br"),n("span",{staticClass:"line-number"},[e._v("6")]),n("br"),n("span",{staticClass:"line-number"},[e._v("7")]),n("br")])]),n("p",[n("em",[e._v("Helper method")])]),e._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("std::unique_ptr<mlir::Pass> mlir::toy::createShapeInferencePass() {\n  return std::make_unique<ShapeInferencePass>();\n}\n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br"),n("span",{staticClass:"line-number"},[e._v("2")]),n("br"),n("span",{staticClass:"line-number"},[e._v("3")]),n("br")])]),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("pm.addPass(mlir::createShapeInferencePass());\n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br")])]),n("p",[e._v("Then the output will be like this:")]),e._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("toy.func @main() {\n  %0 = toy.constant dense<[[1.000000e+00, 2.000000e+00, 3.000000e+00], [4.000000e+00, 5.000000e+00, 6.000000e+00]]> : tensor<2x3xf64>\n  %1 = toy.transpose(%0 : tensor<2x3xf64>) to tensor<3x2xf64>\n  %2 = toy.mul %1, %1 : tensor<3x2xf64>\n  toy.print %2 : tensor<3x2xf64>\n  toy.return\n}\n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br"),n("span",{staticClass:"line-number"},[e._v("2")]),n("br"),n("span",{staticClass:"line-number"},[e._v("3")]),n("br"),n("span",{staticClass:"line-number"},[e._v("4")]),n("br"),n("span",{staticClass:"line-number"},[e._v("5")]),n("br"),n("span",{staticClass:"line-number"},[e._v("6")]),n("br"),n("span",{staticClass:"line-number"},[e._v("7")]),n("br")])]),n("h3",{attrs:{id:"chapter-5-partial-lowering-to-lower-level-dialects-for-optimization"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#chapter-5-partial-lowering-to-lower-level-dialects-for-optimization"}},[e._v("#")]),e._v(" Chapter 5. Partial Lowering to Lower-Level Dialects for Optimization")]),e._v(" "),n("p",[n("strong",[e._v("Dialect Conversions")])]),e._v(" "),n("ol",[n("li",[e._v("Conversion Target")])]),e._v(" "),n("ul",[n("li",[e._v("formal specification of what operations or dialects are legal for the conversion")]),e._v(" "),n("li",[e._v("Operations that arenâ€™t legal will require rewrite patterns to perform legalization.")])]),e._v(" "),n("ol",{attrs:{start:"2"}},[n("li",[e._v("Rewrite Patterns")])]),e._v(" "),n("ul",[n("li",[e._v("set of patterns used to convert illegal operations into a set of zero or more legal ones.")])]),e._v(" "),n("ol",{attrs:{start:"3"}},[n("li",[e._v("Type Convert")])]),e._v(" "),n("h4",{attrs:{id:"conversion-target"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#conversion-target"}},[e._v("#")]),e._v(" Conversion Target")]),e._v(" "),n("p",[e._v("Convert Toy Operations into combination of operations from:")]),e._v(" "),n("ul",[n("li",[e._v("Affine")]),e._v(" "),n("li",[e._v("Arith")]),e._v(" "),n("li",[e._v("Func")]),e._v(" "),n("li",[e._v("MemRef")])]),e._v(" "),n("p",[e._v("Then we set "),n("em",[e._v("ToyDialect")]),e._v(" to be illegal. So it will be lowered.")]),e._v(" "),n("p",[e._v("And print will be dynamically legal to keep it untouched.")]),e._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("void ToyToAffineLoweringPass::runOnOperation() {\n  target.addLegalDialect<affine::AffineDialect,\n                         arith::ArithDialect,\n                         func::FuncDialect,\n                         memref::MemRefDialect>();\n\n  target.addIllegalDialect<ToyDialect>();\n  target.addDynamicallyLegalOp<toy::PrintOp>([](toy::PrintOp op) {\n    return llvm::none_of(op->getOperandTypes(),\n                         [](Type type) { return type.isa<TensorType>(); });\n  });\n}\n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br"),n("span",{staticClass:"line-number"},[e._v("2")]),n("br"),n("span",{staticClass:"line-number"},[e._v("3")]),n("br"),n("span",{staticClass:"line-number"},[e._v("4")]),n("br"),n("span",{staticClass:"line-number"},[e._v("5")]),n("br"),n("span",{staticClass:"line-number"},[e._v("6")]),n("br"),n("span",{staticClass:"line-number"},[e._v("7")]),n("br"),n("span",{staticClass:"line-number"},[e._v("8")]),n("br"),n("span",{staticClass:"line-number"},[e._v("9")]),n("br"),n("span",{staticClass:"line-number"},[e._v("10")]),n("br"),n("span",{staticClass:"line-number"},[e._v("11")]),n("br"),n("span",{staticClass:"line-number"},[e._v("12")]),n("br")])]),n("h4",{attrs:{id:"conversion-patterns"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#conversion-patterns"}},[e._v("#")]),e._v(" Conversion Patterns")]),e._v(" "),n("p",[e._v("For operator that needs lowering, define "),n("strong",[e._v("matchAndRewrite")]),e._v(".")]),e._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("/// Lower the `toy.transpose` operation to an affine loop nest.\nstruct TransposeOpLowering : public mlir::ConversionPattern {\n  TransposeOpLowering(mlir::MLIRContext *ctx)\n  llvm::LogicalResult\n  matchAndRewrite(mlir::Operation *op, ArrayRef<mlir::Value> operands,\n                  mlir::ConversionPatternRewriter &rewriter) const final {\n  ...\n   return rewriter.create<mlir::AffineLoadOp>(loc, input, reverseIvs);\n  }\n}\n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br"),n("span",{staticClass:"line-number"},[e._v("2")]),n("br"),n("span",{staticClass:"line-number"},[e._v("3")]),n("br"),n("span",{staticClass:"line-number"},[e._v("4")]),n("br"),n("span",{staticClass:"line-number"},[e._v("5")]),n("br"),n("span",{staticClass:"line-number"},[e._v("6")]),n("br"),n("span",{staticClass:"line-number"},[e._v("7")]),n("br"),n("span",{staticClass:"line-number"},[e._v("8")]),n("br"),n("span",{staticClass:"line-number"},[e._v("9")]),n("br"),n("span",{staticClass:"line-number"},[e._v("10")]),n("br")])]),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("void ToyToAffineLoweringPass::runOnOperation() {\n  ...\n\n  // Now that the conversion target has been defined, we just need to provide\n  // the set of patterns that will lower the Toy operations.\n  mlir::RewritePatternSet patterns(&getContext());\n  patterns.add<..., TransposeOpLowering>(&getContext());\n\n  ...\n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br"),n("span",{staticClass:"line-number"},[e._v("2")]),n("br"),n("span",{staticClass:"line-number"},[e._v("3")]),n("br"),n("span",{staticClass:"line-number"},[e._v("4")]),n("br"),n("span",{staticClass:"line-number"},[e._v("5")]),n("br"),n("span",{staticClass:"line-number"},[e._v("6")]),n("br"),n("span",{staticClass:"line-number"},[e._v("7")]),n("br"),n("span",{staticClass:"line-number"},[e._v("8")]),n("br"),n("span",{staticClass:"line-number"},[e._v("9")]),n("br")])]),n("h4",{attrs:{id:"partial-lowering"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#partial-lowering"}},[e._v("#")]),e._v(" Partial Lowering")]),e._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("void ToyToAffineLoweringPass::runOnOperation() {\n  ...\n  mlir::applyPartialConversion(getOperation(), target, patterns));\n  ...\n}\n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br"),n("span",{staticClass:"line-number"},[e._v("2")]),n("br"),n("span",{staticClass:"line-number"},[e._v("3")]),n("br"),n("span",{staticClass:"line-number"},[e._v("4")]),n("br"),n("span",{staticClass:"line-number"},[e._v("5")]),n("br")])]),n("p",[n("strong",[e._v("Design Considerations with Partial Lowering")])]),e._v(" "),n("p",[e._v("In this lowering, we lower from value-type(TensorType) to allcoate(or buffer)-type(MemRefType).")]),e._v(" "),n("p",[e._v("However, toy.print function is not designed for allocate-type from beginning.")]),e._v(" "),n("p",[e._v("Three ways to solve this:")]),e._v(" "),n("ul",[n("li",[e._v("Generate load operations from the buffer")]),e._v(" "),n("li",[e._v("Generate a new version of toy.print that operates on the lowered type")]),e._v(" "),n("li",[e._v("Update toy.print to allow for operating on the lowered type")])]),e._v(" "),n("p",[e._v("The third way is chosen due to its simplicity.")]),e._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('def PrintOp : Toy_Op<"print"> {\n  ...\n\n  // The print operation takes an input tensor to print.\n  // We also allow a F64MemRef to enable interop during partial lowering.\n  let arguments = (ins AnyTypeOf<[F64Tensor, F64MemRef]>:$input);\n}\n')])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br"),n("span",{staticClass:"line-number"},[e._v("2")]),n("br"),n("span",{staticClass:"line-number"},[e._v("3")]),n("br"),n("span",{staticClass:"line-number"},[e._v("4")]),n("br"),n("span",{staticClass:"line-number"},[e._v("5")]),n("br"),n("span",{staticClass:"line-number"},[e._v("6")]),n("br"),n("span",{staticClass:"line-number"},[e._v("7")]),n("br")])]),n("h4",{attrs:{id:"complete-toy-example"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#complete-toy-example"}},[e._v("#")]),e._v(" Complete Toy Example")]),e._v(" "),n("details",[n("summary",[e._v("Code")]),e._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("func.func @main() {\n  %cst = arith.constant 1.000000e+00 : f64\n  %cst_0 = arith.constant 2.000000e+00 : f64\n  %cst_1 = arith.constant 3.000000e+00 : f64\n  %cst_2 = arith.constant 4.000000e+00 : f64\n  %cst_3 = arith.constant 5.000000e+00 : f64\n  %cst_4 = arith.constant 6.000000e+00 : f64\n\n  // Allocating buffers for the inputs and outputs.\n  %0 = memref.alloc() : memref<3x2xf64>\n  %1 = memref.alloc() : memref<3x2xf64>\n  %2 = memref.alloc() : memref<2x3xf64>\n\n  // Initialize the input buffer with the constant values.\n  affine.store %cst, %2[0, 0] : memref<2x3xf64>\n  affine.store %cst_0, %2[0, 1] : memref<2x3xf64>\n  affine.store %cst_1, %2[0, 2] : memref<2x3xf64>\n  affine.store %cst_2, %2[1, 0] : memref<2x3xf64>\n  affine.store %cst_3, %2[1, 1] : memref<2x3xf64>\n  affine.store %cst_4, %2[1, 2] : memref<2x3xf64>\n\n  // Load the transpose value from the input buffer and store it into the\n  // next input buffer.\n  affine.for %arg0 = 0 to 3 {\n    affine.for %arg1 = 0 to 2 {\n      %3 = affine.load %2[%arg1, %arg0] : memref<2x3xf64>\n      affine.store %3, %1[%arg0, %arg1] : memref<3x2xf64>\n    }\n  }\n\n  // Multiply and store into the output buffer.\n  affine.for %arg0 = 0 to 3 {\n    affine.for %arg1 = 0 to 2 {\n      %3 = affine.load %1[%arg0, %arg1] : memref<3x2xf64>\n      %4 = affine.load %1[%arg0, %arg1] : memref<3x2xf64>\n      %5 = arith.mulf %3, %4 : f64\n      affine.store %5, %0[%arg0, %arg1] : memref<3x2xf64>\n    }\n  }\n\n  // Print the value held by the buffer.\n  toy.print %0 : memref<3x2xf64>\n  memref.dealloc %2 : memref<2x3xf64>\n  memref.dealloc %1 : memref<3x2xf64>\n  memref.dealloc %0 : memref<3x2xf64>\n  return\n}\n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br"),n("span",{staticClass:"line-number"},[e._v("2")]),n("br"),n("span",{staticClass:"line-number"},[e._v("3")]),n("br"),n("span",{staticClass:"line-number"},[e._v("4")]),n("br"),n("span",{staticClass:"line-number"},[e._v("5")]),n("br"),n("span",{staticClass:"line-number"},[e._v("6")]),n("br"),n("span",{staticClass:"line-number"},[e._v("7")]),n("br"),n("span",{staticClass:"line-number"},[e._v("8")]),n("br"),n("span",{staticClass:"line-number"},[e._v("9")]),n("br"),n("span",{staticClass:"line-number"},[e._v("10")]),n("br"),n("span",{staticClass:"line-number"},[e._v("11")]),n("br"),n("span",{staticClass:"line-number"},[e._v("12")]),n("br"),n("span",{staticClass:"line-number"},[e._v("13")]),n("br"),n("span",{staticClass:"line-number"},[e._v("14")]),n("br"),n("span",{staticClass:"line-number"},[e._v("15")]),n("br"),n("span",{staticClass:"line-number"},[e._v("16")]),n("br"),n("span",{staticClass:"line-number"},[e._v("17")]),n("br"),n("span",{staticClass:"line-number"},[e._v("18")]),n("br"),n("span",{staticClass:"line-number"},[e._v("19")]),n("br"),n("span",{staticClass:"line-number"},[e._v("20")]),n("br"),n("span",{staticClass:"line-number"},[e._v("21")]),n("br"),n("span",{staticClass:"line-number"},[e._v("22")]),n("br"),n("span",{staticClass:"line-number"},[e._v("23")]),n("br"),n("span",{staticClass:"line-number"},[e._v("24")]),n("br"),n("span",{staticClass:"line-number"},[e._v("25")]),n("br"),n("span",{staticClass:"line-number"},[e._v("26")]),n("br"),n("span",{staticClass:"line-number"},[e._v("27")]),n("br"),n("span",{staticClass:"line-number"},[e._v("28")]),n("br"),n("span",{staticClass:"line-number"},[e._v("29")]),n("br"),n("span",{staticClass:"line-number"},[e._v("30")]),n("br"),n("span",{staticClass:"line-number"},[e._v("31")]),n("br"),n("span",{staticClass:"line-number"},[e._v("32")]),n("br"),n("span",{staticClass:"line-number"},[e._v("33")]),n("br"),n("span",{staticClass:"line-number"},[e._v("34")]),n("br"),n("span",{staticClass:"line-number"},[e._v("35")]),n("br"),n("span",{staticClass:"line-number"},[e._v("36")]),n("br"),n("span",{staticClass:"line-number"},[e._v("37")]),n("br"),n("span",{staticClass:"line-number"},[e._v("38")]),n("br"),n("span",{staticClass:"line-number"},[e._v("39")]),n("br"),n("span",{staticClass:"line-number"},[e._v("40")]),n("br"),n("span",{staticClass:"line-number"},[e._v("41")]),n("br"),n("span",{staticClass:"line-number"},[e._v("42")]),n("br"),n("span",{staticClass:"line-number"},[e._v("43")]),n("br"),n("span",{staticClass:"line-number"},[e._v("44")]),n("br"),n("span",{staticClass:"line-number"},[e._v("45")]),n("br"),n("span",{staticClass:"line-number"},[e._v("46")]),n("br"),n("span",{staticClass:"line-number"},[e._v("47")]),n("br")])])]),e._v(" "),n("h4",{attrs:{id:"taking-advantage-of-affine-optimization"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#taking-advantage-of-affine-optimization"}},[e._v("#")]),e._v(" Taking Advantage of Affine Optimization")]),e._v(" "),n("p",[e._v("Add additional passes to the pipeline to reduce redundant loads.")]),e._v(" "),n("ul",[n("li",[e._v("LoopFusion")]),e._v(" "),n("li",[e._v("AffineScalarReplacement")])]),e._v(" "),n("h3",{attrs:{id:"chapter-6-lowering-to-llvm-and-codegeneration"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#chapter-6-lowering-to-llvm-and-codegeneration"}},[e._v("#")]),e._v(" Chapter 6.Lowering to LLVM and CodeGeneration")]),e._v(" "),n("h4",{attrs:{id:"conversion-target-2"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#conversion-target-2"}},[e._v("#")]),e._v(" Conversion Target")]),e._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("  mlir::ConversionTarget target(getContext());\n  target.addLegalDialect<mlir::LLVMDialect>();\n  target.addLegalOp<mlir::ModuleOp>();\n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br"),n("span",{staticClass:"line-number"},[e._v("2")]),n("br"),n("span",{staticClass:"line-number"},[e._v("3")]),n("br")])]),n("h4",{attrs:{id:"type-converter"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#type-converter"}},[e._v("#")]),e._v(" Type Converter")]),e._v(" "),n("p",[e._v("This lowering transform the MemRef types which are currently being operated on into a representation in LLVM.")]),e._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("  LLVMTypeConverter typeConverter(&getContext());\n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br")])]),n("h4",{attrs:{id:"conversion-patterns-2"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#conversion-patterns-2"}},[e._v("#")]),e._v(" Conversion Patterns")]),e._v(" "),n("p",[n("em",[e._v("affine")]),e._v(", "),n("em",[e._v("arith")]),e._v(" and "),n("em",[e._v("std")]),e._v(" has provide set of patterns needed to lower them into llvm dialect")]),e._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("  mlir::RewritePatternSet patterns(&getContext());\n  mlir::populateAffineToStdConversionPatterns(patterns, &getContext());\n  mlir::cf::populateSCFToControlFlowConversionPatterns(patterns, &getContext());\n  mlir::arith::populateArithToLLVMConversionPatterns(typeConverter,\n                                                          patterns);\n  mlir::populateFuncToLLVMConversionPatterns(typeConverter, patterns);\n  mlir::cf::populateControlFlowToLLVMConversionPatterns(patterns, &getContext());\n\n  // The only remaining operation, to lower from the `toy` dialect, is the\n  // PrintOp.\n  patterns.add<PrintOpLowering>(&getContext());\n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br"),n("span",{staticClass:"line-number"},[e._v("2")]),n("br"),n("span",{staticClass:"line-number"},[e._v("3")]),n("br"),n("span",{staticClass:"line-number"},[e._v("4")]),n("br"),n("span",{staticClass:"line-number"},[e._v("5")]),n("br"),n("span",{staticClass:"line-number"},[e._v("6")]),n("br"),n("span",{staticClass:"line-number"},[e._v("7")]),n("br"),n("span",{staticClass:"line-number"},[e._v("8")]),n("br"),n("span",{staticClass:"line-number"},[e._v("9")]),n("br"),n("span",{staticClass:"line-number"},[e._v("10")]),n("br"),n("span",{staticClass:"line-number"},[e._v("11")]),n("br")])]),n("h4",{attrs:{id:"full-lowering"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#full-lowering"}},[e._v("#")]),e._v(" Full Lowering")]),e._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("mlir::ModuleOp module = getOperation();\nif (mlir::failed(mlir::applyFullConversion(module, target, patterns)))\n  signalPassFailure();\n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br"),n("span",{staticClass:"line-number"},[e._v("2")]),n("br"),n("span",{staticClass:"line-number"},[e._v("3")]),n("br")])]),n("p",[e._v("The generated llvm dialect:")]),e._v(" "),n("details",[n("summary",[e._v("Code")]),e._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('llvm.func @free(!llvm<"i8*">)\nllvm.func @printf(!llvm<"i8*">, ...) -> i32\nllvm.func @malloc(i64) -> !llvm<"i8*">\nllvm.func @main() {\n  %0 = llvm.mlir.constant(1.000000e+00 : f64) : f64\n  %1 = llvm.mlir.constant(2.000000e+00 : f64) : f64\n\n  ...\n\n^bb16:\n  %221 = llvm.extractvalue %25[0] : !llvm<"{ double*, i64, [2 x i64], [2 x i64] }">\n  %222 = llvm.mlir.constant(0 : index) : i64\n  %223 = llvm.mlir.constant(2 : index) : i64\n  %224 = llvm.mul %214, %223 : i64\n  %225 = llvm.add %222, %224 : i64\n  %226 = llvm.mlir.constant(1 : index) : i64\n  %227 = llvm.mul %219, %226 : i64\n  %228 = llvm.add %225, %227 : i64\n  %229 = llvm.getelementptr %221[%228] : (!llvm."double*">, i64) -> !llvm<"f64*">\n  %230 = llvm.load %229 : !llvm<"double*">\n  %231 = llvm.call @printf(%207, %230) : (!llvm<"i8*">, f64) -> i32\n  %232 = llvm.add %219, %218 : i64\n  llvm.br ^bb15(%232 : i64)\n\n  ...\n\n^bb18:\n  %235 = llvm.extractvalue %65[0] : !llvm<"{ double*, i64, [2 x i64], [2 x i64] }">\n  %236 = llvm.bitcast %235 : !llvm<"double*"> to !llvm<"i8*">\n  llvm.call @free(%236) : (!llvm<"i8*">) -> ()\n  %237 = llvm.extractvalue %45[0] : !llvm<"{ double*, i64, [2 x i64], [2 x i64] }">\n  %238 = llvm.bitcast %237 : !llvm<"double*"> to !llvm<"i8*">\n  llvm.call @free(%238) : (!llvm<"i8*">) -> ()\n  %239 = llvm.extractvalue %25[0] : !llvm<"{ double*, i64, [2 x i64], [2 x i64] }">\n  %240 = llvm.bitcast %239 : !llvm<"double*"> to !llvm<"i8*">\n  llvm.call @free(%240) : (!llvm<"i8*">) -> ()\n  llvm.return\n}\n')])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br"),n("span",{staticClass:"line-number"},[e._v("2")]),n("br"),n("span",{staticClass:"line-number"},[e._v("3")]),n("br"),n("span",{staticClass:"line-number"},[e._v("4")]),n("br"),n("span",{staticClass:"line-number"},[e._v("5")]),n("br"),n("span",{staticClass:"line-number"},[e._v("6")]),n("br"),n("span",{staticClass:"line-number"},[e._v("7")]),n("br"),n("span",{staticClass:"line-number"},[e._v("8")]),n("br"),n("span",{staticClass:"line-number"},[e._v("9")]),n("br"),n("span",{staticClass:"line-number"},[e._v("10")]),n("br"),n("span",{staticClass:"line-number"},[e._v("11")]),n("br"),n("span",{staticClass:"line-number"},[e._v("12")]),n("br"),n("span",{staticClass:"line-number"},[e._v("13")]),n("br"),n("span",{staticClass:"line-number"},[e._v("14")]),n("br"),n("span",{staticClass:"line-number"},[e._v("15")]),n("br"),n("span",{staticClass:"line-number"},[e._v("16")]),n("br"),n("span",{staticClass:"line-number"},[e._v("17")]),n("br"),n("span",{staticClass:"line-number"},[e._v("18")]),n("br"),n("span",{staticClass:"line-number"},[e._v("19")]),n("br"),n("span",{staticClass:"line-number"},[e._v("20")]),n("br"),n("span",{staticClass:"line-number"},[e._v("21")]),n("br"),n("span",{staticClass:"line-number"},[e._v("22")]),n("br"),n("span",{staticClass:"line-number"},[e._v("23")]),n("br"),n("span",{staticClass:"line-number"},[e._v("24")]),n("br"),n("span",{staticClass:"line-number"},[e._v("25")]),n("br"),n("span",{staticClass:"line-number"},[e._v("26")]),n("br"),n("span",{staticClass:"line-number"},[e._v("27")]),n("br"),n("span",{staticClass:"line-number"},[e._v("28")]),n("br"),n("span",{staticClass:"line-number"},[e._v("29")]),n("br"),n("span",{staticClass:"line-number"},[e._v("30")]),n("br"),n("span",{staticClass:"line-number"},[e._v("31")]),n("br"),n("span",{staticClass:"line-number"},[e._v("32")]),n("br"),n("span",{staticClass:"line-number"},[e._v("33")]),n("br"),n("span",{staticClass:"line-number"},[e._v("34")]),n("br"),n("span",{staticClass:"line-number"},[e._v("35")]),n("br"),n("span",{staticClass:"line-number"},[e._v("36")]),n("br"),n("span",{staticClass:"line-number"},[e._v("37")]),n("br"),n("span",{staticClass:"line-number"},[e._v("38")]),n("br")])])])])}),[],!1,null,null,null);n.default=t.exports}}]);
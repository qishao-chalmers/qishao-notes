(window.webpackJsonp=window.webpackJsonp||[]).push([[82],{537:function(e,t,a){"use strict";a.r(t);var i=a(9),s=Object(i.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("ol",[t("li",[e._v("[1 2024] Uncovering Real GPU NoC Chara cteristics:Implications on Interconnect Architecture")]),e._v(" "),t("li",[e._v("[53 2015] Asymmetric NoC Architectures for GPU Systems")])]),e._v(" "),t("hr"),e._v(" "),t("h2",{attrs:{id:"_1-1-2024-uncovering-real-gpu-noc-chara-cteristics-implications-on-interconnect-architecture"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-2024-uncovering-real-gpu-noc-chara-cteristics-implications-on-interconnect-architecture"}},[e._v("#")]),e._v(" 1. [1 2024] Uncovering Real GPU NoC Chara cteristics:Implications on Interconnect Architecture")]),e._v(" "),t("p",[e._v('The paper, "Uncovering Real GPU NoC Characteristics: Implications on Interconnect Architecture", thoroughly analyzes the network-on-chip (NoC) architectures of modern GPUs from NVIDIA (V100, A100, H100), examining critical aspects such as latency and bandwidth, and discusses key architectural implications.')]),e._v(" "),t("p",[e._v("Here is a profound explanation of the key observations and findings from this significant work:")]),e._v(" "),t("h3",{attrs:{id:"key-observations-and-findings"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#key-observations-and-findings"}},[e._v("#")]),e._v(" Key Observations and Findings:")]),e._v(" "),t("h4",{attrs:{id:"_1-non-uniform-latency"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-non-uniform-latency"}},[e._v("#")]),e._v(" 1. Non-uniform Latency:")]),e._v(" "),t("p",[e._v("Core-L2 slice latency varies significantly based on their physical placement within GPUs.")]),e._v(" "),t("p",[e._v("For instance, the V100 GPU shows a latency variation up to 71 cycles (about 33%), depending on the proximity of the SM (Streaming Multiprocessor) to the specific L2 slice accessed.")]),e._v(" "),t("p",[e._v("Physical location heavily influences latency, thus emphasizing the importance of core and memory slice placement strategies in GPU architecture.")]),e._v(" "),t("p",[t("strong",[e._v("Latency")]),e._v(": Access latency from Streaming Multiprocessors (SMs) to L2 cache slices is highly non-uniform, varying by up to ~70% (e.g., 175 to 248 cycles on V100).\nThis variation is primarily determined by the physical location of the SM within its Graphics Processing Cluster (GPC) and the L2 slice within its Memory Partition (MP). SMs and L2 slices that are physically closer have significantly lower latency.")]),e._v(" "),t("p",[t("strong",[e._v("Bandwidth")]),e._v(": In contrast, the bandwidth provided from cores (SMs or GPCs) to different L2 slices is remarkably uniform. The average bandwidth per SM-to-L2 slice link is ~34 GB/s, and aggregate bandwidth scales predictably with the number of sources.")]),e._v(" "),t("h4",{attrs:{id:"_2-impact-of-physical-placement"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-impact-of-physical-placement"}},[e._v("#")]),e._v(" 2. Impact of Physical Placement:")]),e._v(" "),t("p",[e._v("Detailed analysis using Pearson correlation identifies that SMs within the same GPU cluster (GPC) tend to have highly correlated latency patterns.")]),e._v(" "),t("p",[e._v("This characteristic allows reverse-engineering of physical SM placement using latency patterns, presenting opportunities for optimization and potential security vulnerabilities (such as side-channel attacks).")]),e._v(" "),t("p",[t("strong",[e._v("Impact of GPU Partitions (A100/H100)")]),e._v(': Modern large GPUs are split into multiple "partitions" (left/right).\n'),t("strong",[e._v("Cross-Partition Latency")]),e._v(": Communication across these partitions introduces significant additional latency (~400 cycles vs. ~212 cycles for intra-partition on A100).\n"),t("strong",[e._v("New Hierarchy (H100)")]),e._v(": The H100 exhibits an additional, previously undocumented hierarchy between the TPC and GPC levels, termed Compute Processing Clusters (CPCs). Latency varies based on CPC distance.\n"),t("strong",[e._v("H100 Optimization")]),e._v(": H100 employs optimizations where L2 caches data locally for SMs directly connected to its partition, leading to more uniform L2 hit latency compared to A100, despite the partition structure.\n"),t("strong",[e._v("Cross-Partition Bandwidth")]),e._v(': Bandwidth to L2 slices in the "far" partition is significantly lower than to those in the "near" partition (e.g., ~26 GB/s vs. ~39.5 GB/s on A100). This non-uniformity diminishes as more SMs saturate the link.')]),e._v(" "),t("h4",{attrs:{id:"_3-hierarchy-induced-non-uniformity-a100-h100-gpus"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-hierarchy-induced-non-uniformity-a100-h100-gpus"}},[e._v("#")]),e._v(" 3. Hierarchy-Induced Non-uniformity (A100, H100 GPUs):")]),e._v(" "),t("p",[e._v("Recent GPUs (A100, H100) introduce multi-partition architectures, significantly amplifying latency non-uniformities due to their increased complexity and larger physical size.")]),e._v(" "),t("p",[e._v("H100 introduces an intermediate hierarchy known as Compute Processing Cluster (CPC), causing further latency differentiation within a GPU cluster (GPC). This hierarchical change is notable in how cores within the same GPC can exhibit varied latency characteristics depending on their CPC placement.")]),e._v(" "),t("h4",{attrs:{id:"_4-latency-crossing-gpu-partitions"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-latency-crossing-gpu-partitions"}},[e._v("#")]),e._v(" 4. Latency Crossing GPU Partitions:")]),e._v(" "),t("p",[e._v("Latency significantly increases when accesses cross GPU partitions, especially evident in A100, where latency to a remote partition nearly doubles from approximately 212 cycles to around 400 cycles.")]),e._v(" "),t("p",[e._v("H100 partially mitigates this issue through a localized caching policy, thus providing more uniform latency compared to A100 when accessing different partitions.")]),e._v(" "),t("h4",{attrs:{id:"_5-on-chip-bandwidth-uniformity-and-non-uniformity"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-on-chip-bandwidth-uniformity-and-non-uniformity"}},[e._v("#")]),e._v(" 5. On-chip Bandwidth Uniformity and Non-uniformity:")]),e._v(" "),t("p",[e._v("Interestingly, while latency shows clear non-uniformity, bandwidth remains relatively uniform across different cores and L2 slices.")]),e._v(" "),t("p",[e._v("Bandwidth uniformity ensures reliable performance irrespective of SM or L2 slice placement, crucial for balanced parallel execution.")]),e._v(" "),t("h4",{attrs:{id:"_6-increasing-on-chip-bandwidth-vs-memory-bandwidth"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-increasing-on-chip-bandwidth-vs-memory-bandwidth"}},[e._v("#")]),e._v(" 6. Increasing On-chip Bandwidth vs. Memory Bandwidth:")]),e._v(" "),t("p",[e._v("The total aggregate on-chip L2 bandwidth far exceeds off-chip memory bandwidth (by 2.4× to 3.5×).")]),e._v(" "),t("p",[e._v("Such high internal bandwidth is necessary to prevent performance bottlenecks, emphasizing the critical role of NoC architecture design.")]),e._v(" "),t("h4",{attrs:{id:"_7-hierarchical-bandwidth-speedup"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_7-hierarchical-bandwidth-speedup"}},[e._v("#")]),e._v(" 7. Hierarchical Bandwidth Speedup:")]),e._v(" "),t("p",[e._v("The study identifies hierarchical speedup strategies (TPC, GPC levels) implemented by GPUs to ensure sufficient bandwidth.")]),e._v(" "),t("p",[e._v("Recent GPUs provide substantial speedup improvements compared to earlier generations, although non-uniformities emerge, especially evident when crossing partitions.")]),e._v(" "),t("h4",{attrs:{id:"_8-load-balancing-is-crucial"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_8-load-balancing-is-crucial"}},[e._v("#")]),e._v(" 8. Load-balancing is Crucial:")]),e._v(" "),t("p",[e._v("Load balancing across cores (SMs) is crucial due to asymmetric speedups at various NoC hierarchy levels.")]),e._v(" "),t("p",[e._v("Conversely, load balancing across L2 slices is less critical, highlighting the need to focus on SM-level workload distribution for optimal performance.")]),e._v(" "),t("p",[e._v("The real bottleneck arises when "),t("strong",[e._v("you concentrate all your kernel's threads onto SMs within only one or a few GPCs, even if you're accessing many L2 slices")]),e._v(".")]),e._v(" "),t("img",{attrs:{width:"524",height:"305",alt:"image",src:"https://github.com/user-attachments/assets/b1683351-a1dc-424e-a117-1125fbd940f1"}}),e._v(" "),t("p",[t("strong",[e._v("The Bottleneck")])]),e._v(" "),t("p",[e._v("The total bandwidth available from a single GPC to an MP is limited by its own speedup factor.")]),e._v(" "),t("p",[e._v("If too many SMs (e.g., 28 SMs as in Figure 15(b)) try to send data to a single MP through only one GPC, they hit this speedup limit.")]),e._v(" "),t("p",[e._v("Performance Degradation: As shown in Figure 15(b), concentrating 28 SMs into just 2 GPCs caused a massive ~62% performance degradation compared to spreading them across 6 GPCs.")]),e._v(" "),t("p",[e._v("The limiting factor was not the number of L2 slices being accessed, but the fact that the traffic was funneled through too few GPCs, overwhelming their maximum output bandwidth despite having ample L2 slice capacity.")]),e._v(" "),t("h4",{attrs:{id:"_9-traffic-distribution-and-load-balancing"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_9-traffic-distribution-and-load-balancing"}},[e._v("#")]),e._v(" 9. Traffic Distribution and Load-Balancing:")]),e._v(" "),t("p",[e._v("Real workloads, analyzed through Rodinia benchmarks, exhibit balanced on-chip traffic, implying that GPU address hashing techniques effectively distribute memory accesses evenly across memory channels and thus NoC traffic.")]),e._v(" "),t("h3",{attrs:{id:"ideas"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#ideas"}},[e._v("#")]),e._v(" Ideas")]),e._v(" "),t("h4",{attrs:{id:"noc-aware-cta-scheduler"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#noc-aware-cta-scheduler"}},[e._v("#")]),e._v(" NoC-Aware CTA Scheduler")]),e._v(" "),t("p",[t("strong",[e._v("Insight used.")]),e._v(" Performance collapses when many CTAs run on SMs inside one GPC and hammer a single memory partition because GPC-level speed-up is limited and asymmetric")]),e._v(" "),t("p",[t("strong",[e._v("Idea.")]),e._v(" Extend Accel-Sim’s thread-block scheduler so that, at launch time, it spreads CTAs across GPCs/partitions to equalise NoC ingress bandwidth.")]),e._v(" "),t("p",[t("strong",[e._v("Evaluation.")]),e._v(" Compare latency-sensitive kernels (e.g., pointer-chasing, Graph workloads) under: (i) stock round-robin scheduling and (ii) your NoC-aware scheme. Measure SM-stall cycles and achieved L2 slice bandwidth.")]),e._v(" "),t("h4",{attrs:{id:"partition-aware-memory-allocator-for-multi-tenant-gpus"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#partition-aware-memory-allocator-for-multi-tenant-gpus"}},[e._v("#")]),e._v(" Partition-Aware Memory Allocator for Multi-Tenant GPUs")]),e._v(" "),t("p",[t("strong",[e._v("Insight used.")]),e._v(" Crossing the partition boundary in Ampere doubles L2 hit latency (~212 → ~400 cy) and throttles single-SM bandwidth (39 → 26 GB s⁻¹) .")]),e._v(" "),t("p",[t("strong",[e._v("Idea.")]),e._v(" In a multi-application setting, modify the simulated CUDA malloc to prefer pages whose L2 slice lives on the same partition as the requesting SM set.")]),e._v(" "),t("p",[t("strong",[e._v("Evaluation.")]),e._v(" Run two co-located DL inference kernels. Track tail latency and fairness with vs. without partition-aware placement.")]),e._v(" "),t("h4",{attrs:{id:"sm-locality-driven-cache-compression"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#sm-locality-driven-cache-compression"}},[e._v("#")]),e._v(" SM-Locality-Driven Cache Compression")]),e._v(" "),t("p",[t("strong",[e._v("Insight used.")]),e._v(" SM-to-L2 latency is lowest when the slice is physically near the SM; but bandwidth uniformity means compressed lines mainly help latency, not BW.")]),e._v(" "),t("p",[t("strong",[e._v("Idea.")]),e._v(" Implement a simple line-level compressor in the L1. When compression ratio ≥ R, cache the line in the nearest L2 slice (distance calculated from the paper’s measured latency heat-map).")]),e._v(" "),t("p",[t("strong",[e._v("Evaluation.")]),e._v(" Compare average memory stall cycles of SPEC/GPU workloads with: (i) baseline uncompressed, (ii) random L2 placement of compressed data, (iii) locality-aware placement.")]),e._v(" "),t("h4",{attrs:{id:"dynamic-prefetch-throttling-for-irregular-accesses"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#dynamic-prefetch-throttling-for-irregular-accesses"}},[e._v("#")]),e._v(" Dynamic Prefetch Throttling for Irregular Accesses")]),e._v(" "),t("p",[t("strong",[e._v("Insight used.")]),e._v(" Only four SMs can saturate a single L2 slice; beyond that, latency not bandwidth is the bottleneck.")]),e._v(" "),t("p",[t("strong",[e._v("Idea.")]),e._v(" Add a prefetch controller that monitors per-slice queue depth; when > X, it throttles additional irregular prefetches from “far” SMs but allows those from “near” SMs.")]),e._v(" "),t("p",[t("strong",[e._v("Evaluation.")]),e._v(" Use irregular pointer-chase micro-benchmarks; plot IPC vs. prefetch accuracy/coverage.")]),e._v(" "),t("h4",{attrs:{id:"hierarchical-load-balancing-policies"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#hierarchical-load-balancing-policies"}},[e._v("#")]),e._v(" Hierarchical Load-Balancing Policies")]),e._v(" "),t("p",[t("strong",[e._v("Insight used.")]),e._v(" Some GPC-speed-up is “in space” (extra links) rather than “in time”; distributing SMs across more MPs yields 2.18× speed-up over packing them into one MP.")]),e._v(" "),t("p",[t("strong",[e._v("Idea.")]),e._v(" Build a run-time policy that (a) groups CTAs by data locality, then (b) assigns these groups to MPs in a way that maximises the number of distinct MP destinations seen by each GPC.")]),e._v(" "),t("p",[t("strong",[e._v("Evaluation.")]),e._v(" Stress-test with graph analytics and stencil mixes; report overall throughput and worst-case SM idle time.")]),e._v(" "),t("h4",{attrs:{id:"model-driven-interconnect-speed-up-exploration"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#model-driven-interconnect-speed-up-exploration"}},[e._v("#")]),e._v(" Model-Driven Interconnect Speed-up Exploration")]),e._v(" "),t("p",[t("strong",[e._v("Insight used.")]),e._v(" The paper quantifies TPC, GPC_local, GPC_global and (for H100) CPC speed-ups for reads vs. writes.")]),e._v(" "),t("p",[t("strong",[e._v("Idea.")]),e._v(" Parameterise these speed-ups in Accel-Sim and sweep them to find the knee point where extra NoC ports stop improving perf/area.")]),e._v(" "),t("p",[t("strong",[e._v("Evaluation.")]),e._v(" Produce Pareto curves (perf vs. simulated crossbar area/energy).")]),e._v(" "),t("h4",{attrs:{id:"compression-aware-reply-coalescing"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#compression-aware-reply-coalescing"}},[e._v("#")]),e._v(" Compression-Aware Reply Coalescing")]),e._v(" "),t("p",[t("strong",[e._v("Insight used.")]),e._v(" Reply traffic (128-byte cache lines) is the dominant consumer of NoC BW; input speed-up exists but is still limited for writes.")]),e._v(" "),t("p",[t("strong",[e._v("Idea.")]),e._v(" Compress replies on-the-fly (e.g., frequent-value) and coalesce multiple compressed lines into a single flit when returning to an SM group.")]),e._v(" "),t("p",[t("strong",[e._v("Evaluation.")]),e._v(" Instrument Accel-Sim’s interconnect queue; measure flit count reduction and end-to-end energy per memory op.")]),e._v(" "),t("hr"),e._v(" "),t("h2",{attrs:{id:"_2-53-2015-asymmetric-noc-architectures-for-gpu-systems"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-53-2015-asymmetric-noc-architectures-for-gpu-systems"}},[e._v("#")]),e._v(" 2. [53 2015] Asymmetric NoC Architectures for GPU Systems")]),e._v(" "),t("h3",{attrs:{id:"_1-asymmetric-channel-widths-matching-hardware-to-real-traffic"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-asymmetric-channel-widths-matching-hardware-to-real-traffic"}},[e._v("#")]),e._v(" 1. Asymmetric Channel Widths: Matching Hardware to Real Traffic")]),e._v(" "),t("p",[e._v("Observation: The paper found that traffic between L1 caches and the L2 cache is highly asymmetric.")]),e._v(" "),t("p",[t("strong",[e._v("L2-to-L1 traffic (data reads) is much heavier and more critical for performance than L1-to-L2 traffic (writes, invalidations).")])]),e._v(" "),t("p",[e._v('Design Change: Instead of using wide channels in both directions (symmetric), the "asym" designs use:')]),e._v(" "),t("p",[t("em",[e._v("A narrower channel for L1-to-L2 communication (e.g., 16x8 vs 22x8 bytes).")])]),e._v(" "),t("p",[t("em",[e._v("A wider channel for the critical L2-to-L1 path.")])]),e._v(" "),t("p",[e._v("Impact on EDP:")]),e._v(" "),t("ul",[t("li",[e._v("Massive Power Savings: Narrower channels mean fewer wires, smaller drivers, and less dynamic power. This directly reduces total power consumption by 37% for MeshX2-asym and 69% for CmeshX2-asym compared to their symmetric baselines.")]),e._v(" "),t("li",[e._v("Minimal Performance Cost: Since the L1-to-L2 path is less critical, narrowing it causes only a small performance drop (e.g., 92-93% of baseline mesh, 97% of baseline Cmesh). This small loss is offset by other benefits.\n🔋 Why this reduces EDP: EDP = Energy * (Delay)^2. By cutting energy (power) drastically while only slightly increasing delay (reducing performance), the overall EDP plummets.")])]),e._v(" "),t("h3",{attrs:{id:"_2-elimination-of-unused-links-reduced-router-radix"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-elimination-of-unused-links-reduced-router-radix"}},[e._v("#")]),e._v(" 2. Elimination of Unused Links & Reduced Router Radix")]),e._v(" "),t("p",[t("strong",[e._v("The authors made a second crucial observation: direct communication between L1 caches is rare in typical GPU workloads.")])]),e._v(" "),t("ul",[t("li",[e._v("Design Change: They completely removed the links that would allow direct L1-to-L1 communication. All inter-L1 data must now go through the L2 cache.\nImpact on EDP:")]),e._v(" "),t("li",[e._v("Reduced Static Power: Fewer physical wires mean lower static (leakage) power.")]),e._v(" "),t("li",[e._v("Simpler Routers: Removing these links significantly reduces the number of input/output ports (radix) on the routers. For example, router radix was reduced from 10x10 to 8x4. Simpler routers consume less area and power.")]),e._v(" "),t("li",[e._v("Less Congestion: Having two separate networks (one for each direction) reduces contention and arbitration latency within the network itself.\n🔧 Why this reduces EDP: This optimization further slashes power consumption without hurting performance, contributing heavily to the overall energy savings.")])]),e._v(" "),t("h3",{attrs:{id:"_3-exploiting-application-level-asymmetry-for-maximum-efficiency"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-exploiting-application-level-asymmetry-for-maximum-efficiency"}},[e._v("#")]),e._v(" 3. Exploiting Application-Level Asymmetry for Maximum Efficiency")]),e._v(" "),t("p",[e._v("The final piece is understanding why the above changes are so effective.")]),e._v(" "),t("p",[e._v("Performance is Bottlenecked by Critical Path:")]),e._v(" "),t("p",[t("strong",[e._v("The start of execution for a wavefront of threads depends on when its data arrives from the L2 cache.")])]),e._v(" "),t("p",[e._v("Therefore, L2-to-L1 latency is the critical path.")]),e._v(" "),t("ul",[t("li",[e._v("Non-Critical Paths Can Be Slowed Down: Delays in sending writebacks or control messages (L1-to-L2) have a much smaller impact on overall application throughput.")]),e._v(" "),t("li",[e._v("Optimization Strategy: The asymmetric design allows the system to:")]),e._v(" "),t("li",[e._v("Prioritize the Critical Path: Keep the L2-to-L1 path fast and high-bandwidth.")]),e._v(" "),t("li",[e._v("Downgrade the Non-Critical Path: Make the L1-to-L2 path narrower and slower, saving immense power.")])]),e._v(" "),t("p",[e._v("This creates an optimal trade-off: you get nearly all the performance of a fully provisioned symmetric network at a fraction of the energy cost.")])])}),[],!1,null,null,null);t.default=s.exports}}]);
(window.webpackJsonp=window.webpackJsonp||[]).push([[89],{543:function(e,t,a){"use strict";a.r(t);var r=a(9),s=Object(r.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h2",{attrs:{id:"riscv-vector-extension"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#riscv-vector-extension"}},[e._v("#")]),e._v(" RISCV Vector Extension")]),e._v(" "),t("h3",{attrs:{id:"registers"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#registers"}},[e._v("#")]),e._v(" Registers")]),e._v(" "),t("p",[t("a",{attrs:{href:"https://eupilot.eu/wp-content/uploads/2022/11/RISC-V-VectorExtension-1-1.pdf",target:"_blank",rel:"noopener noreferrer"}},[e._v("source"),t("OutboundLink")],1)]),e._v(" "),t("ul",[t("li",[e._v("V0-V31 32 vector registers")])]),e._v(" "),t("p",[e._v("VLEN: vector register length: 128, 256, 512, 1024")]),e._v(" "),t("p",[e._v("ELEN: element length 8,16,32,64")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://github.com/user-attachments/assets/74ba9d30-e9ed-450f-b2db-cd729d75ad21",alt:"image"}})]),e._v(" "),t("ul",[t("li",[e._v("vtype(vector type)\n"),t("ul",[t("li",[e._v("sew: standard element width. SEW determines how the vector register is subdivided — e.g., for SEW=32 and VLEN=256, a vector register can hold 8 elements.")]),e._v(" "),t("li",[e._v("lmul: Vector Register Group Multiplier. 1/8, 1/4, 1/2, 1, 2, 4, 8. LMUL > 1 means one logical vector spans multiple physical vector registers.")])])])]),e._v(" "),t("p",[t("img",{attrs:{src:"https://github.com/user-attachments/assets/8e74dffc-3f46-4740-a019-ba29fc6713ee",alt:"image"}})]),e._v(" "),t("hr"),e._v(" "),t("h2",{attrs:{id:"_1-ara-a-1-ghz-scalable-and-energy-efficient-risc-v-vector-processor-with-multi-precision-floating-point-support-in-22-nm-fd-soi"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-ara-a-1-ghz-scalable-and-energy-efficient-risc-v-vector-processor-with-multi-precision-floating-point-support-in-22-nm-fd-soi"}},[e._v("#")]),e._v(" 1. Ara: A 1 GHz+ Scalable and Energy-Efficient RISC-V Vector Processor with Multi-Precision Floating Point Support in 22 nm FD-SOI")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://github.com/user-attachments/assets/5f29511b-d741-415e-963d-910ccd9c429d",alt:"image"}})]),e._v(" "),t("p",[t("strong",[e._v("Sequencer")]),e._v(" solves structural hazard by delaying issue and "),t("em",[e._v("data hazard is just marked, will be solved by downstream")]),e._v(".\nit also keeps state of running function.")]),e._v(" "),t("p",[t("strong",[e._v("Slide unit")]),e._v(" (SLDU) responsible for vector extraction, vector shuffles and vector slides.")]),e._v(" "),t("p",[t("strong",[e._v("Vector load/store unit")]),e._v(":")]),e._v(" "),t("ul",[t("li",[e._v("unit-stride loads and stores")]),e._v(" "),t("li",[e._v("constant-stride memory operation")]),e._v(" "),t("li",[e._v("scatters and gathers")])]),e._v(" "),t("h3",{attrs:{id:"lane"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#lane"}},[e._v("#")]),e._v(" "),t("strong",[e._v("Lane")])]),e._v(" "),t("h4",{attrs:{id:"lane-sequencer"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#lane-sequencer"}},[e._v("#")]),e._v(" lane sequencer")]),e._v(" "),t("p",[e._v("Lane sequence solves data dependency by self-regulated process, through back pressure due to unvailable operands.")]),e._v(" "),t("h4",{attrs:{id:"vector-register-file"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vector-register-file"}},[e._v("#")]),e._v(" vector register file")]),e._v(" "),t("p",[t("strong",[e._v("In RISC-V’s vector extension, the predicated multiplyadd instruction is the worst case regarding throughput, reading four operands to produce one result.")])]),e._v(" "),t("p",[e._v("It is composed a set of single ported (1RW) banks.")]),e._v(" "),t("p",[e._v("And the width of each bank is constrained to the datapath width of each lane, 64 bits.")]),e._v(" "),t("p",[e._v("Register file consists eight banks to support 5 banks for predicated multiply-add operation.")]),e._v(" "),t("p",[e._v("The VRF (eight 64-bit wide 1RW banks) is replicated at each lane and all inter-lane communication is concentraed at the VLSU and SLDU.")]),e._v(" "),t("p",[e._v('To solve bank conflicts, this is vector registers are mapped into banks in "barber\'s pole" position.')]),e._v(" "),t("p",[t("img",{attrs:{src:"https://github.com/user-attachments/assets/4975f9e5-7c75-4d82-b8ea-a299be86b7d4",alt:"image"}})]),e._v(" "),t("h4",{attrs:{id:"operand-queues"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#operand-queues"}},[e._v("#")]),e._v(" operand queues")]),e._v(" "),t("p",[e._v("Operand queues between VRF and function unitss are to absorb banking conflicts.")]),e._v(" "),t("p",[e._v("and another operand queues between output ports of function unit and vector register file is to absorb bank conflicts on the write-back path to VRF.")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://github.com/user-attachments/assets/8810f5fd-0565-4db7-bbb0-6baa4e55efc9",alt:"image"}})]),e._v(" "),t("h4",{attrs:{id:"execution-units"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#execution-units"}},[e._v("#")]),e._v(" execution units")]),e._v(" "),t("p",[e._v("Each lane has three execution units, an integer ALU, an integer MUL, and an FPU, all of them operating on a 64-bit datapath.")]),e._v(" "),t("p",[e._v("MUL and FPU shares the same operand queue, so they cannot operate at the same time.")]),e._v(" "),t("p",[e._v("The three execution units have a 64 bit/cycle throughput, regardless of the data format of the computation. We developed our multi-precision ALU and MUL, both producing 1 × 64, 2 × 32, 4 × 16, and 8 × 8 bit signed or unsigned operands.")]),e._v(" "),t("p",[e._v("As the integer units, the FPU has a 64 bit/cycle throughput, i.e., one double precision, two single precision or four IEEE 754 half-precision floating point results per cycle.")]),e._v(" "),t("hr"),e._v(" "),t("h2",{attrs:{id:"_2-vitruvius-an-area-efficient-risc-v-decoupled-vector-coprocessor-for-high-performance-computing-applications"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-vitruvius-an-area-efficient-risc-v-decoupled-vector-coprocessor-for-high-performance-computing-applications"}},[e._v("#")]),e._v(" 2. Vitruvius: An Area-Efficient RISC-V Decoupled Vector Coprocessor for High Performance Computing Applications")]),e._v(" "),t("h3",{attrs:{id:"introduction"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#introduction"}},[e._v("#")]),e._v(" Introduction")]),e._v(" "),t("p",[t("strong",[e._v("Maximum Vector Length(MVL)")]),e._v(" 256 Double Precision(DP) elements or 256 * 64 = 16,384 bits.")]),e._v(" "),t("p",[e._v("If we set LMUL(vector register group multiplier) as 8, then the upper bound MVL would be 2,048 Double Precision(DP)-elements.")]),e._v(" "),t("h3",{attrs:{id:"interface"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#interface"}},[e._v("#")]),e._v(" Interface")]),e._v(" "),t("ul",[t("li",[e._v("Issue")]),e._v(" "),t("li",[e._v("Dispatch")]),e._v(" "),t("li",[e._v("Completed")]),e._v(" "),t("li",[e._v("Memop: Vitruvius does not any access to memory hierarchy.\n"),t("ul",[t("li",[e._v("If the request is completed, VPU will sent out sync_start and receive sync_end, sb_id and vstart_vlfof from Avispado.")])])]),e._v(" "),t("li",[e._v("Load: Avispado send a whole cacheline of 512 bits with seq_id to VPU.")]),e._v(" "),t("li",[e._v("Store: VPU send 512 bit data with flagged by a valid.")])]),e._v(" "),t("p",[e._v("The vector extension benefits the performanced by reduced instruction, reduced loop counts and control instructions.")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://github.com/user-attachments/assets/877e77a0-939a-400f-9e13-6c1179dd25f8",alt:"image"}})]),e._v(" "),t("h4",{attrs:{id:"vrf"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vrf"}},[e._v("#")]),e._v(" VRF")]),e._v(" "),t("p",[e._v("80kB")]),e._v(" "),t("p",[e._v("The eight-lane splits VRF into 10-kB slices, one such slice per lane.")]),e._v(" "),t("p",[t("strong",[e._v("Peak Performace")])]),e._v(" "),t("ul",[t("li",[e._v("one DP-fused Multiply-Add(FMA)  per cycle 3 read 1 write")]),e._v(" "),t("li",[e._v("one DP-memory-access per cycle  1 read/1 write")])]),e._v(" "),t("p",[e._v("To support 5 ports reading at same time, the VRF of 10-kB is instantiated 5* 2-kB 1RW SRAM bank in each lane.")]),e._v(" "),t("h4",{attrs:{id:"out-of-order-exectuion"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#out-of-order-exectuion"}},[e._v("#")]),e._v(" Out of order exectuion")]),e._v(" "),t("p",[e._v("Renaming stage eliminates the WAW and WAR dependencies.")]),e._v(" "),t("p",[e._v("After renaming, the instruction would be split into memory or arithmetic instruction queues.")]),e._v(" "),t("h4",{attrs:{id:"lane-interconnect"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#lane-interconnect"}},[e._v("#")]),e._v(" Lane Interconnect")]),e._v(" "),t("p",[e._v("This is for reduction permutation.")]),e._v(" "),t("h4",{attrs:{id:"overlapping"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#overlapping"}},[e._v("#")]),e._v(" Overlapping")]),e._v(" "),t("h4",{attrs:{id:"vector-lane"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vector-lane"}},[e._v("#")]),e._v(" Vector Lane")]),e._v(" "),t("p",[e._v("With input 512 bit cacheline and 8 lane, each lane will receive 64 bits, a DP-elements.")]),e._v(" "),t("p",[e._v("The first eight bytes are always in lane 0 and the next eight bytes are in lane1.")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://github.com/user-attachments/assets/40dbffb4-b886-412c-bb88-8a469622a4ce",alt:"image"}})]),e._v(" "),t("h4",{attrs:{id:"finite-state-machine-five-state-structure"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#finite-state-machine-five-state-structure"}},[e._v("#")]),e._v(" Finite State Machine (five-state structure)")]),e._v(" "),t("h4",{attrs:{id:"execution-wrapper"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#execution-wrapper"}},[e._v("#")]),e._v(" Execution Wrapper")]),e._v(" "),t("p",[e._v("For each lane, it features FPU and AL.")]),e._v(" "),t("p",[e._v("All the units in the vector lanes are fully pipelined (exceptsquare root and division) and have a throughput of 64-bit/cycle, working  in SIMD fashion when the element width is less than 64 bits.")]),e._v(" "),t("p",[e._v("The Floating Point Unit (FPU) sup ports all classes of operations, including FMA, division, square root, comparison, and other types like widening and narrowing operations.")]),e._v(" "),t("p",[e._v("Integer operations executed in the Arithmetic Logic Unit  (ALU) also range from the most common ones, like FMA, multiplication, addition, and bit manipulation, to others like narrowing, widening, and fixed point.")]),e._v(" "),t("p",[e._v("Additionally, it also supports all type of vector reduction operations specified by the RVV specifications.")]),e._v(" "),t("h4",{attrs:{id:"outstanding-features"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#outstanding-features"}},[e._v("#")]),e._v(" Outstanding Features")]),e._v(" "),t("ul",[t("li",[e._v("memory-to-arithmetic forwarding")]),e._v(" "),t("li",[e._v("vector-vector move(fast move) by register renaming")])])])}),[],!1,null,null,null);t.default=s.exports}}]);
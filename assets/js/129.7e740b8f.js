(window.webpackJsonp=window.webpackJsonp||[]).push([[129],{581:function(e,t,a){"use strict";a.r(t);var s=a(9),o=Object(s.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h2",{attrs:{id:"cuda-merge"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#cuda-merge"}},[e._v("#")]),e._v(" CUDA Merge")]),e._v(" "),t("p",[e._v("Difficulty: 👍 👍 👍 👍 👍")]),e._v(" "),t("p",[e._v("The merge algorithm is much more complex than matrix multiplication and sorting, maybe even more complex than prefix-sum reduction.")]),e._v(" "),t("p",[e._v("Lets illustrate how this works.")]),e._v(" "),t("p",[e._v("The problem:")]),e._v(" "),t("p",[e._v("given ordered array A and ordered array B, merge the array.")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://github.com/user-attachments/assets/1baf161d-efa3-49ae-80cc-9459cd84c2b2",alt:"image"}})]),e._v(" "),t("p",[e._v("This algorthm is output-centric.")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://github.com/user-attachments/assets/9d9a1702-dd03-4cdd-b2b6-7a5638d3cc8c",alt:"image"}})]),e._v(" "),t("p",[e._v("Each thread-block is responsible for merging a tile of C.")]),e._v(" "),t("p",[e._v("Each thread is responsible for merging several consective elements of C.")]),e._v(" "),t("p",[e._v("Since we want to use parallel algorthm to solve this problem, we want to divide and solve the C.")]),e._v(" "),t("p",[t("strong",[e._v("If given any position C, we could find its startpoint of A and startpoint of B, when we could just assign each thread with position")]),e._v(", by some magic algorithm like 😾:")]),e._v(" "),t("ul",[t("li",[e._v("thread0, C Pos 0, finds where to start in A and B by thread0 itself")]),e._v(" "),t("li",[e._v("thread1, C Pos 8, finds where to start in A and B by thread1 itself")]),e._v(" "),t("li",[e._v("thread2, C Pos 12, finds where to start in A and B by thread2 itself")]),e._v(" "),t("li",[e._v("thread3, C Pos 16, finds where to start in A and B by thread3 itself")])]),e._v(" "),t("p",[e._v("Then we could solve the question.")]),e._v(" "),t("p",[t("strong",[e._v("Another idea deserved to be mention is that since A and B are consective, we could load them into share memory, so threads could use memory coalescing to access them.")])]),e._v(" "),t("p",[e._v("Those above two idea are the core idea of merge.")]),e._v(" "),t("p",[e._v("Then, the only left question is how to implement the algorithm. 😾")]),e._v(" "),t("p",[e._v("It follows the basic idea that:")]),e._v(" "),t("ol",[t("li",[e._v("if we have two ordered array\na[i-1] a[i]")])]),e._v(" "),t("p",[e._v("b[j-1] b[j]")]),e._v(" "),t("p",[e._v("the start point we want to find for A and B must follows:")]),e._v(" "),t("p",[e._v("a[i-1] <= b[j]")]),e._v(" "),t("p",[e._v("b[j-1] < a[i]")]),e._v(" "),t("p",[e._v("Thus if we know the start point of A and B, we could just use binary search to gradually get the start of A and B")]),e._v(" "),t("ol",{attrs:{start:"2"}},[t("li")]),e._v(" "),t("p",[e._v("Another rule is if we want to calculate for C Pos X, elements before C contains number of I elements in A and number of j elements in B.")]),e._v(" "),t("p",[e._v("This helps to understand.")]),e._v(" "),t("p",[e._v("If each thread is assigned by 4 elements and for thread 2, it want to know where to start from A and B.")]),e._v(" "),t("p",[e._v("The expected position is 5th in A and 3th in B.")]),e._v(" "),t("p",[e._v("It follows the above two rules.")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://github.com/user-attachments/assets/6bd65c4c-6e1e-4850-9466-414d681c42f2",alt:"image"}})])])}),[],!1,null,null,null);t.default=o.exports}}]);
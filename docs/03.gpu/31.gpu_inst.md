---
title: GPU Insturctions
date: 2025-04-02
permalink: /pages/45890/
---

1. [20] Decoding CUDA Binary

---

## 1. [20] Decoding CUDA Binary

### Compiling Flow

When every thread in the warp has reached a re-convergence command - either a .S modifier or a SYNC instruction, 
depending on the architecture - it will wait until the thread warp reaches the instruction whose address is specified by the
SSY instruction, and then return to running in lock-step.

![image](https://github.com/user-attachments/assets/66319026-1b78-410c-a6c5-68d09375da76)

### Assemble Code
64 bits or 128 bits
![image](https://github.com/user-attachments/assets/86e4c66a-1b8f-4b18-8efd-bdb40638b80d)

### Load/Store Instruction and Control Flow of Divergence
![image](https://github.com/user-attachments/assets/6c3891a8-c1ee-4eef-9526-febbd597188a)

### Compile-Time Scheduling
As of Compute Capability 3.0, *instruction scheduling is handled by the compiler* rather than by the hardware.

On this architecture every 8−th instruction, rather than being a real instruction, is a set of scheduling codes inserted by the compiler.

These scheduling codes dictate the minimum number of cycles that the thread must wait between every two consecutive instructions in the following seven instructions in order to satisfy dependence constraints.

Starting with Compute Capability 5.0, NVIDIA moved even more control logic away from the hardware, saving power and space.

Thus instruction-level barrier has been added to the scheduling codes generated by the compiler.

The scheduling codes on Compute Capabilities 5.x and 6.x occur in place of every fourth instruction.

As of Compute Capability 7.0, **they are embedded into each individual instruction**, rather than controlling larger blocks of instructions.

#### Instruction with Operand

![image](https://github.com/user-attachments/assets/c12c2fae-dd53-420a-96f8-e05615ef0035)


Although instructions are of fixed length, NVIDIA’s instruction sets lack the relative simplicity of a RISC architecture.

It includes complicated instructions such as multiplication-and-addition, multi-function operation that performs trigonometric functions including sine and cosine, and so on.

Although we can make generalizations about which bits are used for which components of the instruction, there are few consistent rules across different instructions.

Check PSETP, it has 3 source operands.
![image](https://github.com/user-attachments/assets/b38e7590-f494-45a8-a029-643a7cdf7941)

![image](https://github.com/user-attachments/assets/54cd8f74-c1bc-4496-b175-8214972bef0c)


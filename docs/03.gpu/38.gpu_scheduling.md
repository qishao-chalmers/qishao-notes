---
title: GPU Multiworkload scheduling
date: 2025-09-16
permalink: /pages/45898/
---
1. [164] GSLICE: Controlled Spatial Sharing of GPUs for a Scalable Inference Platform ‚Äî Comprehensive Summary & Analysis

---

## **1. GSLICE: Controlled Spatial Sharing of GPUs for a Scalable Inference Platform ‚Äî Comprehensive Summary & Analysis**
*Summarized by Qwen*

### **1. Problem Statement: The GPU Inference Bottleneck**

Modern GPUs (e.g., NVIDIA V100) offer immense computational power (~125 TFLOPS) and memory bandwidth (~900 GBps). However, most Deep Neural Network (DNN) inference models (e.g., ResNet-50, VGG-19) are computationally lightweight in comparison and cannot fully saturate this hardware.

*   **Traditional Solutions Fail:**
    *   **Temporal Sharing (Time-Slicing):** Runs one model at a time ‚Üí Low utilization, low throughput.
    *   **Batching:** Improves throughput but increases latency ‚Üí Violates Service Level Objectives (SLOs) for real-time apps.
    *   **Default CUDA MPS (Multi-Process Service):** Allows concurrent execution but provides **uncontrolled spatial sharing** ‚Üí Heavy models monopolize the GPU, starving lighter ones ‚Üí Unpredictable performance.
    *   **Static GPU% in MPS:** Static allocation ‚Üí Wastes resources when workload is light or starves models when demand spikes.

> ‚úÖ **Core Challenge**: Achieve **high GPU utilization**, **low latency (SLO compliance)**, **performance isolation**, and **scalability** simultaneously across diverse, concurrent inference functions (IFs).


### **2. GSLICE: The Solution ‚Äî Intelligent, Dynamic Spatial Multiplexing**

GSLICE is a **DPDK-based, framework-agnostic inference platform** that overcomes these limitations by introducing **controlled, adaptive, and isolated spatial sharing** of the GPU via enhanced CUDA MPS.

#### **Key Innovations**

| Innovation | Description | Why It Matters |
| :--- | :--- | :--- |
| **Self-Tuning GPU Resource Allocation** | Dynamically adjusts each IF‚Äôs GPU % based on real-time metrics: <br> ‚Ä¢ `Residual Latency Capacity = SLO - Observed Latency`<br> ‚Ä¢ `Residual Throughput Capacity = Achieved Throughput - Request Arrival Rate`<br> ‚Ä¢ **Logic**: Increase GPU% if either metric is negative; decrease if both are positive and large (>5%). | Replaces static, wasteful provisioning with intelligent, feedback-driven resource management. Ensures every IF gets ‚Äújust enough‚Äù to meet its SLO and demand. |
| **Max-Min Fairness Algorithm** | When reallocating resources, GSLICE prioritizes the IF with the *lowest* current GPU% relative to its need. | Prevents starvation of lighter or less demanding models. Guarantees fairness while maximizing aggregate system throughput. |
| **Shadow IF + Overlapped Execution** | For every active IF, GSLICE maintains a **shadow (hot-standby) IF** on the same CPU core. When GPU% needs adjustment:<br> 1. Configure shadow IF with new GPU%.<br> 2. Load model onto GPU on shadow.<br> 3. Perform seamless switchover (< 100 ¬µs) from primary to shadow IF.<br> 4. Terminate old primary IF. | Solves the critical problem of **~2‚Äì15s restart overhead** in CUDA MPS. Enables dynamic re-provisioning with **near-zero downtime**, making adaptation practical. |
| **Self-Learning Adaptive Batching (SLAB)** | Dynamically adjusts batch size based on observed latency, arrival rate, and SLO headroom. Uses EWMA for smoothing. | Balances the trade-off between batching‚Äôs throughput gains and latency costs. Converges to optimal batch size **10x faster** than systems like Clipper. |
| **Parameter Sharing Across IFs** | Model weights (the largest component of GPU memory) are loaded **once** onto the GPU. Multiple instances of the *same* model share these identical parameters. | Reduces per-IF GPU memory footprint by 20-50%. Enables multiplexing **5‚Äì54% more IFs** on the same GPU. Dramatically reduces model load times (8‚Äì10x faster). |
| **Zero-Copy Data Transfer** | Uses DPDK‚Äôs pinned memory and GPU DMA to scatter-gather network packets directly into GPU memory, bypassing the CPU. | Eliminates costly CPU data copy overheads, especially critical for high-throughput streaming data. |


### **3. The Critical Architectural Choice: Why MPS > Streams**

This is where GSLICE makes a **foundational, deliberate, and highly impactful decision**.

#### **The Two Paths to Spatial Sharing**

| Feature | CUDA Streams | CUDA MPS |
| :--- | :--- | :--- |
| **Scope** | Within a single process. | Across multiple processes. |
| **Mechanism** | Multiple command queues within one app. Kernels from different streams can overlap *if* they don‚Äôt compete for the same resources. | Multiple independent applications (processes) run concurrently on the same GPU. Each has its own context. |
| **Resource Control** | No built-in mechanism to limit compute/memory usage per stream. | Can enforce **GPU% limits** (SM allocation) per process via environment variables. |
| **Isolation** | ‚ùå Poor. Streams from the same app can interfere. One slow kernel blocks others. | ‚úÖ Good. Processes are isolated by design. Resource limits provide hard boundaries. |
| **Use Case Fit for Inference** | Mixing different models? Impossible. Only suitable for batching *within* one model. | Perfect. Enables running AlexNet, ResNet-50, and VGG-19 as separate processes on one GPU. |

#### **GSLICE‚Äôs Experimental Findings: Streams Are Not the Answer**

The authors rigorously tested both approaches:

1.  **Streams Don't Enable True Heterogeneous Multiplexing**:
    *   Experiments showed that when running **ResNet-50 and AlexNet concurrently using streams**, their kernels **did not overlap meaningfully** (Figure 6).
    *   The heavier ResNet-50 kernels dominated the SMs, forcing AlexNet to wait. This was effectively **time-sharing disguised as spatial sharing**.
    *   Result: Increased latency, no real throughput gain, and poor isolation.

2.  **Streams Harm Latency**:
    *   Adding more streams beyond 2 consistently increased latency without improving throughput for most models (Figure 5a).
    *   Even for Alexnet, which saw some throughput gain with more streams, latency still increased significantly.
    *   The overhead of managing many streams and context switches negated the benefits.

3.  **MPS with Resource Limits Is the Right Tool**:
    *   Figure 7 demonstrates the key insight: By running AlexNet and ResNet-50 as **separate MPS processes**, each limited to a fixed GPU% (e.g., 40% and 60%), their kernels **could execute concurrently without interference**.
    *   The GPU's SMs were partitioned, ensuring each model had guaranteed access to its allocated compute units.
    *   This provided true **performance isolation** ‚Äî the latency of one model was unaffected by the other, as long as its allocated GPU% was above its "knee point".

> üö´ **Conclusion from the Paper**:  
> *‚ÄúStreams are problematic while multiplexing models with unequal compute requirement... streams do not provide any meaningful overlap... resulting in increased inference task completion time... Therefore, in GSLICE we prefer using MPS with resource provisioning instead of CUDA streams, whenever possible.‚Äù*

#### **Why This Decision Was Revolutionary**

Choosing MPS over streams wasn't just a technical preference ‚Äî it was an **architectural commitment to isolation and control**.

-   **Streams** optimize for *parallelism within a single application*.
-   **MPS with limits** optimizes for *fair, multi-tenant, heterogeneous resource sharing* ‚Äî the exact problem cloud inference platforms face.

By choosing MPS, GSLICE could leverage NVIDIA‚Äôs built-in mechanism for **resource partitioning** (GPU%) and build its self-tuning logic *on top of it*, rather than fighting against the inherent limitations of streams. This allowed them to deliver **guaranteed SLOs** ‚Äî something streams fundamentally cannot provide in a mixed-model environment.


### **4. The Foundational Insight: The "Knee Point"**

Through extensive profiling of models (AlexNet, ResNet-50, VGG-19, GNMT, Jasper), the authors made a profound discovery:

<img width="564" height="544" alt="image" src="https://github.com/user-attachments/assets/c08c68d8-075d-4272-bc88-410b6f7cb533" />


> ‚úÖ **Every DNN model has a "knee point"** ‚Äî a specific percentage of GPU resources (e.g., 60% for ResNet-50, 70% for VGG-19) beyond which increasing allocation yields only **diminishing returns** in throughput or latency improvement.

#### **Why This Changes Everything**

| Traditional Assumption | GSLICE's Discovery |
|------------------------|--------------------|
| Give each model 100% GPU to maximize its performance. | Even the heaviest models plateau at ~70% GPU. |
| Static allocation: ‚ÄúWe‚Äôll give VGG-19 80%, ResNet-50 20%.‚Äù | The optimal allocation is **model-specific**, **non-linear**, and **not intuitive**. |
| Resource waste is inevitable. | You can **save 30‚Äì40% GPU per model** without hurting performance. |

**The Impact:**
-   **Massive Efficiency Gain**: If you run 5 models on one GPU, and each only needs 60% instead of 100%, you‚Äôre effectively saving **200% worth of GPU capacity**.
-   **Enables Multiplexing**: Without knowing the knee point, spatial sharing would be guesswork. With it, you know exactly how much ‚Äúheadroom‚Äù each model has ‚Äî making controlled multiplexing *scientific*, not heuristic.
-   **Foundation for Self-Tuning**: The knee point isn‚Äôt just a number ‚Äî it‚Äôs the **baseline demand** used by GSLICE‚Äôs self-tuning algorithm to determine if an IF is over- or under-provisioned.

> ‚úÖ **Think of it like this**:  
> You wouldn‚Äôt give a sedan the full engine power of a Formula 1 car ‚Äî even if it could handle it. The ‚Äúknee point‚Äù tells you *exactly* how much engine power each car needs to reach its top speed ‚Äî no more, no less.


### **5. The Engineering Masterpiece: Shadow IF**

#### **The Problem**
In CUDA MPS, changing a process‚Äôs GPU% requires **restarting the entire process**. Restarting a PyTorch/TensorFlow/TensorRT inference process takes **2‚Äì15 seconds** ‚Äî completely unacceptable for real-time systems.

**Result:** Dynamic resource allocation was a theoretical dream.

#### **GSLICE‚Äôs Solution: Shadow IF + Overlapped Execution**

Here‚Äôs the genius:

| Step | What Happens |
|------|--------------|
| **1. Active IF** | Running normally, serving requests, using 30% GPU. |
| **2. Shadow IF** | A *hot standby* instance running on the same CPU core, with identical buffers, framework, and code ‚Äî **but NOT accessing GPU**. Zero overhead. |
| **3. Need to Increase GPU%?** | GSLICE configures the *shadow* IF with the new target (e.g., 70%). It begins loading the model weights onto the GPU‚Ä¶ **while the active IF keeps serving requests**. |
| **4. Switchover** | When the shadow IF is ready, the IF Manager does a near-instantaneous (<100¬µs) handoff: <br> - Stops the active IF after its current batch. <br> - Promotes the shadow IF to active. <br> - Terminates the old active IF. |
| **5. Result** | GPU% changed from 30% ‚Üí 70%. **No downtime. No dropped requests. SLO intact.** |

#### **Why This Is So Impressive**

| Feature | Why It Matters |
|--------|----------------|
| **Zero-Downtime** | Achieves what was thought impossible: dynamic reconfiguration of GPU resources without service interruption. |
| **Hidden Latency** | Masks the 2‚Äì15s model load time by overlapping it with live traffic. |
| **Minimal Overhead** | Shadow IF uses only CPU memory and cores ‚Äî no extra GPU, no network, no data copies. |
| **Scalable** | Can be applied to any ML framework (PyTorch, TF, TensorRT) with minimal changes (<30 lines). |
| **Elegant Simplicity** | No kernel-level hacking. No CUDA driver modifications. Just smart software orchestration. |

> ‚úÖ **Think of it like upgrading a jet engine mid-flight:**  
> You don‚Äôt land the plane. You have a second, identical engine already spinning up on the wing. At the perfect moment, you flip the switch ‚Äî and the plane continues flying, now with 2x thrust.

This is **systems engineering at its finest**: solving a hardware limitation with pure software ingenuity.

### **6. Synergy: The Triad of Brilliance**

These three innovations don't just coexist ‚Äî they **amplify each other**:

1.  **Knee Point** tells you **how much** GPU each model *needs*.
2.  **Shadow IF** lets you **dynamically give it that amount**, instantly and safely.
3.  **MPS with Resource Limits** provides the **underlying, controllable infrastructure** that makes #1 and #2 possible.

Together, they enable **true elasticity** for GPU inference:
-   A sudden spike in image requests? ‚Üí GSLICE detects latency pressure ‚Üí increases VGG-19‚Äôs GPU% from 60% ‚Üí 75% via shadow IF ‚Üí SLO maintained.
-   Traffic drops? ‚Üí Reduces GPU% ‚Üí frees capacity for a new IF.
-   New model added? ‚Üí Load its weights once ‚Üí share parameters ‚Üí spin up shadow IF ‚Üí deploy with zero delay.


### **7. Architecture Overview**

<img width="645" height="439" alt="image" src="https://github.com/user-attachments/assets/b83bca76-6759-41f4-9902-a6a1daa6fafd" />

*   **IF Manager**: DPDK process handling network I/O and coordinating IF lifecycle.
*   **libml**: Lightweight C/C++ library providing core services (batching, zero-copy, resource mgmt) abstracted from ML frameworks.
*   **Orchestrator**: Manages creation/destruction of IFs.
*   **Shadow IFs**: Hot-standby instances enabling zero-downtime re-provisioning.
*   **Supports**: PyTorch, TensorFlow, TensorRT, CNTK, MXNet, Darknet (minimal changes required).

### **9. Conclusion: A Paradigm Shift**

GSLICE is not merely an incremental improvement‚Äîit represents a **paradigm shift** in GPU inference infrastructure.

It successfully solves the long-standing trilemma:
> **High Utilization** + **Low Latency (SLO Compliance)** + **Performance Isolation**

By combining **self-tuning resource allocation**, **zero-downtime re-provisioning**, **adaptive batching**, **parameter sharing**, and **zero-copy I/O**, GSLICE achieves unprecedented levels of efficiency and scalability. It transforms the GPU from a static, underutilized asset into a **dynamic, intelligent, multi-tenant, high-performance computing engine** capable of serving hundreds of diverse, real-time inference applications concurrently.

Its impact lies not only in its performance numbers but in proving that **intelligent, software-defined control** can unlock the full potential of commodity hardware for the next generation of cloud AI services.



### ‚úÖ **Final Takeaway**

> **The Knee Point** revealed a hidden truth about DNN efficiency ‚Äî **less is more**.  
> **The Shadow IF** solved a seemingly unsolvable systems problem ‚Äî **zero-downtime reconfiguration**.  
> **The MPS > Streams Choice** was the foundational architectural decision that made all of this possible ‚Äî **true isolation for heterogeneous workloads**.

---

These three elements together form a masterpiece of systems research: elegant, practical, transformative, and deeply insightful.

<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Understanding GPGPU-SIM 2 Instruction Execution | CPU &amp; GPU Microarch. Qi Shao</title>
    <meta name="generator" content="VuePress 1.8.0">
    <link rel="stylesheet" href="custom.css">
    <script language="javascript" type="text/javascript" src="/qishao-notes/js/pgmanor-self.js"></script>
    <meta name="description" content="Computer System">
    <meta name="google-site-verification" content="66w5U9NY5gJWu7iBtHKMbhpXkV94jy31L_RHbvrZZzY">
    <meta name="keywords" content="Hitqishao,golang,vue,go-web,go-admin,go-ldap-admin">
    <meta name="theme-color" content="#11a8cd">
    <meta name="referrer" content="no-referrer-when-downgrade">
    
    <link rel="preload" href="/qishao-notes/assets/css/0.styles.922e50b3.css" as="style"><link rel="preload" href="/qishao-notes/assets/js/app.6e252b53.js" as="script"><link rel="preload" href="/qishao-notes/assets/js/2.75973713.js" as="script"><link rel="preload" href="/qishao-notes/assets/js/43.7b76fbd7.js" as="script"><link rel="prefetch" href="/qishao-notes/assets/js/10.ff60f5f4.js"><link rel="prefetch" href="/qishao-notes/assets/js/11.35356818.js"><link rel="prefetch" href="/qishao-notes/assets/js/12.9dd6ac7e.js"><link rel="prefetch" href="/qishao-notes/assets/js/13.96e9fb44.js"><link rel="prefetch" href="/qishao-notes/assets/js/14.12c35a25.js"><link rel="prefetch" href="/qishao-notes/assets/js/15.301a02ce.js"><link rel="prefetch" href="/qishao-notes/assets/js/16.1a1639a9.js"><link rel="prefetch" href="/qishao-notes/assets/js/17.24801ac6.js"><link rel="prefetch" href="/qishao-notes/assets/js/18.2ebec85b.js"><link rel="prefetch" href="/qishao-notes/assets/js/19.aa8ac1ae.js"><link rel="prefetch" href="/qishao-notes/assets/js/20.535c58a2.js"><link rel="prefetch" href="/qishao-notes/assets/js/21.b5ba1720.js"><link rel="prefetch" href="/qishao-notes/assets/js/22.24e23aee.js"><link rel="prefetch" href="/qishao-notes/assets/js/23.00322b09.js"><link rel="prefetch" href="/qishao-notes/assets/js/24.ae95a93e.js"><link rel="prefetch" href="/qishao-notes/assets/js/25.017bb7ac.js"><link rel="prefetch" href="/qishao-notes/assets/js/26.9a920fc3.js"><link rel="prefetch" href="/qishao-notes/assets/js/27.e8d36ebd.js"><link rel="prefetch" href="/qishao-notes/assets/js/28.e3478362.js"><link rel="prefetch" href="/qishao-notes/assets/js/29.761f6df6.js"><link rel="prefetch" href="/qishao-notes/assets/js/3.4a0dc4e2.js"><link rel="prefetch" href="/qishao-notes/assets/js/30.10591c6a.js"><link rel="prefetch" href="/qishao-notes/assets/js/31.dca72edd.js"><link rel="prefetch" href="/qishao-notes/assets/js/32.d525b9e3.js"><link rel="prefetch" href="/qishao-notes/assets/js/33.6f40dca0.js"><link rel="prefetch" href="/qishao-notes/assets/js/34.f548ba82.js"><link rel="prefetch" href="/qishao-notes/assets/js/35.92874369.js"><link rel="prefetch" href="/qishao-notes/assets/js/36.53fa01a5.js"><link rel="prefetch" href="/qishao-notes/assets/js/37.c757368f.js"><link rel="prefetch" href="/qishao-notes/assets/js/38.2f88a515.js"><link rel="prefetch" href="/qishao-notes/assets/js/39.d672ebba.js"><link rel="prefetch" href="/qishao-notes/assets/js/4.424759af.js"><link rel="prefetch" href="/qishao-notes/assets/js/40.96895abc.js"><link rel="prefetch" href="/qishao-notes/assets/js/41.218e197a.js"><link rel="prefetch" href="/qishao-notes/assets/js/42.add63d64.js"><link rel="prefetch" href="/qishao-notes/assets/js/44.4289179a.js"><link rel="prefetch" href="/qishao-notes/assets/js/45.e4f4449f.js"><link rel="prefetch" href="/qishao-notes/assets/js/46.3f4ac4ff.js"><link rel="prefetch" href="/qishao-notes/assets/js/47.887747b0.js"><link rel="prefetch" href="/qishao-notes/assets/js/48.7da5e37f.js"><link rel="prefetch" href="/qishao-notes/assets/js/49.91c71314.js"><link rel="prefetch" href="/qishao-notes/assets/js/5.d619f2db.js"><link rel="prefetch" href="/qishao-notes/assets/js/50.16abc842.js"><link rel="prefetch" href="/qishao-notes/assets/js/51.6a034420.js"><link rel="prefetch" href="/qishao-notes/assets/js/52.781dc793.js"><link rel="prefetch" href="/qishao-notes/assets/js/53.efce5544.js"><link rel="prefetch" href="/qishao-notes/assets/js/54.e531f5d4.js"><link rel="prefetch" href="/qishao-notes/assets/js/55.e1f70246.js"><link rel="prefetch" href="/qishao-notes/assets/js/56.229696df.js"><link rel="prefetch" href="/qishao-notes/assets/js/57.63e5be1c.js"><link rel="prefetch" href="/qishao-notes/assets/js/58.3492e2ef.js"><link rel="prefetch" href="/qishao-notes/assets/js/59.966f70e5.js"><link rel="prefetch" href="/qishao-notes/assets/js/6.938d7909.js"><link rel="prefetch" href="/qishao-notes/assets/js/60.276d0f0b.js"><link rel="prefetch" href="/qishao-notes/assets/js/61.4750466b.js"><link rel="prefetch" href="/qishao-notes/assets/js/62.3cd65ea4.js"><link rel="prefetch" href="/qishao-notes/assets/js/63.e80938e4.js"><link rel="prefetch" href="/qishao-notes/assets/js/64.bd9fce37.js"><link rel="prefetch" href="/qishao-notes/assets/js/65.ab150561.js"><link rel="prefetch" href="/qishao-notes/assets/js/66.ec998751.js"><link rel="prefetch" href="/qishao-notes/assets/js/67.20c9e5ec.js"><link rel="prefetch" href="/qishao-notes/assets/js/68.a5140b99.js"><link rel="prefetch" href="/qishao-notes/assets/js/69.0465df04.js"><link rel="prefetch" href="/qishao-notes/assets/js/7.c7e2f84d.js"><link rel="prefetch" href="/qishao-notes/assets/js/70.57db6db5.js"><link rel="prefetch" href="/qishao-notes/assets/js/71.0757da7d.js"><link rel="prefetch" href="/qishao-notes/assets/js/72.a46b2f32.js"><link rel="prefetch" href="/qishao-notes/assets/js/73.cfd4e03b.js"><link rel="prefetch" href="/qishao-notes/assets/js/74.df3cddda.js"><link rel="prefetch" href="/qishao-notes/assets/js/75.6880a5e4.js"><link rel="prefetch" href="/qishao-notes/assets/js/76.5b27e2ac.js"><link rel="prefetch" href="/qishao-notes/assets/js/77.81586051.js"><link rel="prefetch" href="/qishao-notes/assets/js/78.abe86742.js"><link rel="prefetch" href="/qishao-notes/assets/js/79.e53d761c.js"><link rel="prefetch" href="/qishao-notes/assets/js/8.9d9bbbd6.js"><link rel="prefetch" href="/qishao-notes/assets/js/80.e4ceb363.js"><link rel="prefetch" href="/qishao-notes/assets/js/9.95b204c9.js">
    <link rel="stylesheet" href="/qishao-notes/assets/css/0.styles.922e50b3.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/qishao-notes/" class="home-link router-link-active"><!----> <span class="site-name">CPU &amp; GPU Microarch. Qi Shao</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/qishao-notes/" class="nav-link">Home</a></div><div class="nav-item"><a href="/qishao-notes/gpu/" class="nav-link">gpu</a></div><div class="nav-item"><a href="/qishao-notes/cpu/" class="nav-link">cpu</a></div><div class="nav-item"><a href="/qishao-notes/llm/" class="nav-link">ml&amp;llm</a></div><div class="nav-item"><a href="/qishao-notes/compiler/" class="nav-link">compiler</a></div><div class="nav-item"><a href="/qishao-notes/hbm/" class="nav-link">hbm</a></div><div class="nav-item"><a href="/qishao-notes/unix/" class="nav-link">unix</a></div><div class="nav-item"><a href="https://blog.csdn.net/hit_shaoqi" target="_blank" rel="noopener noreferrer" class="nav-link external">
  CSDN
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <a href="https://github.com/hitqshao/qishao-notes" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><!----> <nav class="nav-links"><div class="nav-item"><a href="/qishao-notes/" class="nav-link">Home</a></div><div class="nav-item"><a href="/qishao-notes/gpu/" class="nav-link">gpu</a></div><div class="nav-item"><a href="/qishao-notes/cpu/" class="nav-link">cpu</a></div><div class="nav-item"><a href="/qishao-notes/llm/" class="nav-link">ml&amp;llm</a></div><div class="nav-item"><a href="/qishao-notes/compiler/" class="nav-link">compiler</a></div><div class="nav-item"><a href="/qishao-notes/hbm/" class="nav-link">hbm</a></div><div class="nav-item"><a href="/qishao-notes/unix/" class="nav-link">unix</a></div><div class="nav-item"><a href="https://blog.csdn.net/hit_shaoqi" target="_blank" rel="noopener noreferrer" class="nav-link external">
  CSDN
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <a href="https://github.com/hitqshao/qishao-notes" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><a href="/qishao-notes/pages/cc7034/" class="sidebar-link">Operand Collector</a></li><li><a href="/qishao-notes/pages/2476ae/" class="sidebar-link">GPU WARP Scheduler</a></li><li><a href="/qishao-notes/pages/14769f/" class="sidebar-link">Precision Exception</a></li><li><a href="/qishao-notes/pages/44771e/" class="sidebar-link">Unified Memory Paper List</a></li><li><a href="/qishao-notes/pages/44871e/" class="sidebar-link">TensorCore Paper List</a></li><li><a href="/qishao-notes/pages/45871e/" class="sidebar-link">Memory Behaviour Paper List</a></li><li><a href="/qishao-notes/pages/45871f/" class="sidebar-link">GPU Virtualization Paper List</a></li><li><a href="/qishao-notes/pages/458720/" class="sidebar-link">Large Language Model Paper List</a></li><li><a href="/qishao-notes/pages/458721/" class="sidebar-link">GPU Simulator</a></li><li><a href="/qishao-notes/pages/458722/" class="sidebar-link">Architectural Survey</a></li><li><a href="/qishao-notes/pages/458724/" class="sidebar-link">Harnessing Integrated CPU-GPU System Memory for HPC a first look into Grace Hopper</a></li><li><a href="/qishao-notes/pages/458725/" class="sidebar-link">Understanding GPGPU-SIM 1 How to get Instruction</a></li><li><a href="/qishao-notes/pages/458726/" aria-current="page" class="active sidebar-link">Understanding GPGPU-SIM 2 Instruction Execution</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/qishao-notes/pages/458727/" class="sidebar-link">Understanding GPGPU-SIM 3 How is the simulation started</a></li><li><a href="/qishao-notes/pages/45872/" class="sidebar-link">Understanding GPGPU-SIM 4 Microarchitecture</a></li><li><a href="/qishao-notes/pages/45874/" class="sidebar-link">Understanding GPGPU-SIM 5  Memory Interface</a></li><li><a href="/qishao-notes/pages/45873/" class="sidebar-link">Warp Related Memory Optimization</a></li><li><a href="/qishao-notes/pages/45875/" class="sidebar-link">GPU Cache Coherency</a></li><li><a href="/qishao-notes/pages/45876/" class="sidebar-link">GPU Cache &amp; Memory Hirerarchy</a></li><li><a href="/qishao-notes/pages/45877/" class="sidebar-link">GPU TLB</a></li><li><a href="/qishao-notes/pages/45878/" class="sidebar-link">GPU Page Table Walk</a></li><li><a href="/qishao-notes/pages/45879/" class="sidebar-link">GPU Cache's Papers</a></li><li><a href="/qishao-notes/pages/45880/" class="sidebar-link">GPU WARP Mangement Papers</a></li><li><a href="/qishao-notes/pages/45882/" class="sidebar-link">GPU Unified Memory Innovations</a></li><li><a href="/qishao-notes/pages/45883/" class="sidebar-link">GPU MultiTask</a></li><li><a href="/qishao-notes/pages/45885/" class="sidebar-link">GPU Paper with Code</a></li><li><a href="/qishao-notes/pages/47871e/" class="sidebar-link">TO READ</a></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-06225672><div class="articleInfo" data-v-06225672><ul class="breadcrumbs" data-v-06225672><li data-v-06225672><a href="/qishao-notes/" title="首页" class="iconfont icon-home router-link-active" data-v-06225672></a></li> <li data-v-06225672><a href="/qishao-notes/gpu/#gpu" data-v-06225672>gpu</a></li></ul> <div class="info" data-v-06225672><div title="作者" class="author iconfont icon-touxiang" data-v-06225672><a href="https://github.com/hitqshao" target="_blank" title="作者" class="beLink" data-v-06225672>hitqishao</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-06225672><a href="javascript:;" data-v-06225672>2024-08-13</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">目录</div> <div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABH1JREFUSA3tVl1oHFUUPmdmd2ltklqbpJDiNnXFmgbFktho7YMPNiJSSZM0+CAYSkUELVhM6YuwIPpgoOKDqOBDC0XE2CQoNtQXBUFTTcCi+Wlh1V2TQExsUzcltd3M9Tt3ZjZzZ2fT+OJTL8yeM+eee757fmeJbq//KQL8X3DUSFOcfr7cRsRtxNQMWueeVzOkaITIGqQHNg5y8+jNW9ldM7A6nTpAjuolUikAwq7CE3WcM2RRDz+XGVgN3FptU/aUSlvq9Pa3iZ1+sgAqJyyAFqkipd9dqiwHF3P65YycLWc/6sqGrvoEoIp6DOFaX5h6+dnfjkWprwqsPk0dUGq5vySwDImC10KxFHgGL1SWoc92O3eVht09qdXNH11I2SsTsJYqMWzihqGMi+A+Garf3BAuuLI5oGlULyNfyB/HYNujwktOfRrMr5t77NmevqaUopx0grnKAyvVpmwUDB4x6FPXuGvYLTDwWsejwgtgkYKPqRJg8SV6xaiZ3ZTppGneS4yfH5/66fZSDHv+QZci/+h5c5UHtpy67JUqGppM0sh0Nc1dW6/N1W5Yoqat8/TU/VnadmdeW2PLLSyh0cvxBs3KbqTmwYPpxN4do/mzE8nEpvX/UMu2Wbp74zUAK5q6WkHns7V0eWkdPbPzd3rxkTGybadYySumVzhcaJFbs5UrEkQ/+CK8gF5dnh/6ciIZ73gwQ927L1IitoxKLXYP3SjYdOrHHfTZhRRlFyrorafPk20B3HPD1y2G3qKZME5Jcf3t/HUC13/8tSd++vqFveMUTwAUxSUFI1QekR1+bIze3D9MF2aq6cPvG72CgnldWCFqyRw3lwH8ZMerjTD9ElRO7Gv44wNpC90aASqGfVlz/Rx17srQ57/UU26hkhQqUB7dBR71WmzQhHUnblGmVOEw0jhbV1n9OlXUDCIRGaNV5Jp43N516fN7JmnTHdfp7Hgy0luO4aMhtkLL8Bi3bUWYvzh5Mn1dTxrL6QmGuRhGL/TiTTxRoEdTszSaq9GR0NGA3KdkOz3hqSV3MIDhQ5IVX/Ivx3umBti2es2h4eZby7x8br1rkf7Mo90AqC8aQ3sJeNzqFRu+vSANAQe3PL7l0HGOAdwDCeZYvNKeoZp1Qfs6Aipndh86HmFRi0LAnEO47wsqM6cdfjh3jBPUzhZy7nvlUfFsamED1VQt6aISHVymXZ/B2aCtIG8AI8xfobj2d3en1wWVhOeHELKmLQ1s211s88comkv4UCwWyF787mJdYXtNfhKAXVqnKTq8QZvGAGGOfaTo5pGZ/PwbUCr5+DPr/1J92JNHr9aOl/F3iI5+O1nfybsGxoimvZ3ViWSluDITw3P37mypheDIPY0tw7+O/5ApbkYw+zpfaUVu32Pi98+defdUhEpZkRFq0aqyNh9FuL9hpYbEm6iwi0z2REd09ZmyENEbuhjDWzKvZXTqKYaBIr3tt5kuPtQBZFvEUwHt60vfCNu41XsksH9Ij1BMMz1Y0OOunHNShFIP5868g5zeXmuLwL9T4b6Q2+KejgAAAABJRU5ErkJggg==">Understanding GPGPU-SIM 2 Instruction Execution<!----></h1> <!----> <div class="theme-vdoing-content content__default"><ul><li>libcuda
<ul><li>cuda_runtime_api.cc</li></ul></li> <li>src
<ul><li>abstract_hardware_model.h/cpp</li> <li>gpgpusim_entrypoint.h/cpp</li> <li>stream_manager.h/cpp</li> <li>cuda-sim
<ul><li>cuda-sim.h/cc</li> <li>memory.h/cc</li> <li>opcode.h/def</li> <li>ptx_loader.h/cc</li> <li>ptx.y\</li> <li>ptx_parser.h/cc</li> <li>ptx_ir.h/cc</li> <li>ptx_sim.h/cc</li></ul></li> <li>gpgpu-sim
<ul><li>gpgpu-sim.h/cc</li> <li>shader.h/shader.cc</li> <li>mem_fetch.h/cc</li> <li>stack.h/cc</li> <li>addrdec.h/cc</li> <li>dram.h/cc</li> <li>traffic_breakdown.h/cc</li></ul></li></ul></li></ul> <h3 id="how-do-cuda-instructions-get-executed"><a href="#how-do-cuda-instructions-get-executed" class="header-anchor">#</a> How do CUDA instructions get executed ?</h3> <h4 id="instruction-level"><a href="#instruction-level" class="header-anchor">#</a> Instruction Level</h4> <p>In opcodes.def, it defines hook for each type of instruction.</p> <p>In instruction.cc, it implements the detail of each function.
If this is a Load instruction, mem-&gt;read() is exectued.</p> <details><summary>Code</summary> <div class="language- line-numbers-mode"><pre class="language-text"><code>// @@@@@@ opcodes.def
OP_DEF(LD_OP,ld_impl,&quot;ld&quot;,1,5)
OP_DEF(ST_OP,st_impl,&quot;st&quot;,0,5)

// @@@@@@ instructions.cc
void ld_exec( const ptx_instruction *pI, ptx_thread_info *thread ) 
{ 
   const operand_info &amp;dst = pI-&gt;dst();
   const operand_info &amp;src1 = pI-&gt;src1();
   ...
   mem-&gt;read(addr,size/8,&amp;data.s64);
}

void ld_impl( const ptx_instruction *pI, ptx_thread_info *thread ) 
{
   ld_exec(pI,thread);
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div></details> <h4 id="abstract-level"><a href="#abstract-level" class="header-anchor">#</a> Abstract Level</h4> <p>The abstract core calls execute_warp_inst_t, which will execute each thread in the warp.</p> <p>As to each instruction, it will call a &quot;DEFINE&quot; macro, which will invoke function, described in previous Section.</p> <details><summary>Code</summary> <div class="language- line-numbers-mode"><pre class="language-text"><code>// @@@@@@ abstract_hardware_model.cc

void core_t::execute_warp_inst_t(warp_inst_t &amp;inst, unsigned warpId)
{
    for ( unsigned t=0; t &lt; m_warp_size; t++ ) {
        if( inst.active(t) ) {
            if(warpId==(unsigned (-1)))
                warpId = inst.warp_id();
            unsigned tid=m_warp_size*warpId+t;
            m_thread[tid]-&gt;ptx_exec_inst(inst,t);
            
            //virtual function
            checkExecutionStatusAndUpdate(inst,t,tid);
        }
    } 
}

// @@@@@@ cuda-sim.cc
void ptx_thread_info::ptx_exec_inst( warp_inst_t &amp;inst, unsigned lane_id)
{
      ...
      switch ( pI-&gt;get_opcode() ) {
      #define OP_DEF(OP,FUNC,STR,DST,CLASSIFICATION) case OP: FUNC(pI,this); op_classification = CLASSIFICATION; break;
      ...
      #include &quot;opcodes.def&quot;
      #undef OP_DEF
      default: printf( &quot;Execution error: Invalid opcode (0x%x)\n&quot;, pI-&gt;get_opcode() ); break;
      }
}

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br></div></div></details> <h4 id="detail-gpu-mode"><a href="#detail-gpu-mode" class="header-anchor">#</a> Detail GPU Mode</h4> <p>In detail GPU, programmed in shader.cc, instruction is executed at issue time.</p> <p>This is reasonable, as long as the latency and bandwidth is modeled correctly, it is accurate.</p> <details><summary>Code</summary> <div class="language- line-numbers-mode"><pre class="language-text"><code>// @@@@@@ shader.cc
void shader_core_ctx::issue_warp( register_set&amp; pipe_reg_set, const warp_inst_t* next_inst, const active_mask_t &amp;active_mask, unsigned warp_id )
{
    ...
    func_exec_inst( **pipe_reg );
}

void shader_core_ctx::func_exec_inst( warp_inst_t &amp;inst )
{
    execute_warp_inst_t(inst);
    // !!!!!! Notice that as to memory access instruction, it will generate memory access
    if( inst.is_load() || inst.is_store() )
        inst.generate_mem_accesses();
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div></details> <p>Then we can go further, how is <em>issue_warp</em> called?</p> <p>In shader.cc, for each cycle, it will check is the status of for each warp.</p> <p>As to each warp, it will check whether the first instruction in the instruction buffer, after checking scoreboard, if this is no hazard and issue width is not saturated, the warp could be issued.</p> <details><summary>Code</summary> <div class="language- line-numbers-mode"><pre class="language-text"><code>// @@@@@@ shader.cc
void scheduler_unit::cycle()
{
    SCHED_DPRINTF( &quot;scheduler_unit::cycle()\n&quot; );
    bool valid_inst = false;  // there was one warp with a valid instruction to issue (didn't require flush due to control hazard)
    bool ready_inst = false;  // of the valid instructions, there was one not waiting for pending register writes
    bool issued_inst = false; // of these we issued one

    for ( std::vector&lt; shd_warp_t* &gt;::const_iterator iter = m_next_cycle_prioritized_warps.begin();
          iter != m_next_cycle_prioritized_warps.end();
          iter++ ) {
        // Don't consider warps that are not yet valid
        if ( (*iter) == NULL || (*iter)-&gt;done_exit() ) {
            continue;
        }
        while( !warp(warp_id).waiting() &amp;&amp; !warp(warp_id).ibuffer_empty() ... &amp;&amp; (checked &lt;= issued) &amp;&amp; (issued &lt; max_issue) ) {
         const warp_inst_t *pI = warp(warp_id).ibuffer_next_inst();
         ...
         if ( (pI-&gt;op == LOAD_OP) || (pI-&gt;op == STORE_OP) || (pI-&gt;op == MEMORY_BARRIER_OP) ) {
             if( m_mem_out-&gt;has_free() ) {
                 m_shader-&gt;issue_warp(*m_mem_out,pI,active_mask,warp_id);
             }
         } else {
             
         }
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br></div></div></details> <p>In the above code, u can see the <em>m_shader-&gt;issue_warp()</em> .
Underneath the <em>issue_warp</em>, it is <em>func_exec_inst</em>, as shown in the following code.</p> <details><summary>Code</summary> <div class="language- line-numbers-mode"><pre class="language-text"><code>// @@@@@@ shader.cc

void shader_core_ctx::func_exec_inst( warp_inst_t &amp;inst )
{
    execute_warp_inst_t(inst);
    if( inst.is_load() || inst.is_store() )
        inst.generate_mem_accesses();
}

void shader_core_ctx::issue_warp( register_set&amp; pipe_reg_set, const warp_inst_t* next_inst, const active_mask_t &amp;active_mask, unsigned warp_id )
{
    warp_inst_t** pipe_reg = pipe_reg_set.get_free();
    assert(pipe_reg);

    m_warp[warp_id].ibuffer_free();
    assert(next_inst-&gt;valid());
    **pipe_reg = *next_inst; // static instruction information
    (*pipe_reg)-&gt;issue( active_mask, warp_id, gpu_tot_sim_cycle + gpu_sim_cycle, m_warp[warp_id].get_dynamic_warp_id() ); // dynamic instruction information
    m_stats-&gt;shader_cycle_distro[2+(*pipe_reg)-&gt;active_count()]++;
    func_exec_inst( **pipe_reg );
    if( next_inst-&gt;op == BARRIER_OP ){
        m_warp[warp_id].store_info_of_last_inst_at_barrier(*pipe_reg);
        m_barriers.warp_reaches_barrier(m_warp[warp_id].get_cta_id(),warp_id,const_cast&lt;warp_inst_t*&gt; (next_inst));

    }else if( next_inst-&gt;op == MEMORY_BARRIER_OP ){
        m_warp[warp_id].set_membar();
    }

    updateSIMTStack(warp_id,*pipe_reg);
    m_scoreboard-&gt;reserveRegisters(*pipe_reg);
    m_warp[warp_id].set_next_pc(next_inst-&gt;pc + next_inst-&gt;isize);
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br></div></div></details> <h4 id="register-hazard"><a href="#register-hazard" class="header-anchor">#</a> Register Hazard</h4> <p>It seems like gpgpu-sim does not use register dependency wakeup, like ROB, which contains a register ID that if dependency instruction has executed, the result transfer through bypassnet work and wakeup pending instructions.</p> <p>In gpgpu-sim, in the writeback stage, it will release its target registers in scoreboard.
</p><details><summary>Code</summary><p></p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// @@@@@@ shader.cc
void shader_core_ctx::writeback()
{
    warp_inst_t** preg = m_pipeline_reg[EX_WB].get_ready();
    warp_inst_t* pipe_reg = (preg==NULL)? NULL:*preg;
    while( preg and !pipe_reg-&gt;empty()) {
        m_scoreboard-&gt;releaseRegisters( pipe_reg );
        warp_inst_complete(*pipe_reg);
    }
}

// @@@@@@ scoreboard.cc
// Release target registers for an instruction
void Scoreboard::releaseRegisters(const class warp_inst_t *inst) 
{
    for( unsigned r=0; r &lt; 4; r++) {
        if(inst-&gt;out[r] &gt; 0) {
            releaseRegister(inst-&gt;warp_id(), inst-&gt;out[r]);
        }
    }
}

// It can be seen that in this function, there is no ready or pending status. Only bookkeeping.
// Unmark register as write-pending
void Scoreboard::releaseRegister(unsigned wid, unsigned regnum) 
{
      reg_table[wid].erase(regnum);
}

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br></div></div></details> <p>So the scoreboard will maintains all pending registers. Once it is written back, the register will be released.</p> <p>If another instruction is about to issue, it will check whether the register it reads or writes matches with any of the registes.
</p><details><summary>Code</summary><p></p> <div class="language- line-numbers-mode"><pre class="language-text"><code>/** 
 * Checks to see if registers used by an instruction are reserved in the scoreboard
 *  
 * @return 
 * true if WAW or RAW hazard (no WAR since in-order issue)
 **/ 
bool Scoreboard::checkCollision( unsigned wid, const class inst_t *inst ) const
{
	// Get list of all input and output registers
	std::set&lt;int&gt; inst_regs;

	// from 0 to 3
	if(inst-&gt;out[0] &gt; 0) inst_regs.insert(inst-&gt;out[0]);

	// from 0 to 3
	if(inst-&gt;in[0] &gt; 0) inst_regs.insert(inst-&gt;in[0]);

	if(inst-&gt;pred &gt; 0) inst_regs.insert(inst-&gt;pred);
	if(inst-&gt;ar1 &gt; 0) inst_regs.insert(inst-&gt;ar1);
	if(inst-&gt;ar2 &gt; 0) inst_regs.insert(inst-&gt;ar2);

	// Check for collision, get the intersection of reserved registers and instruction registers
	std::set&lt;int&gt;::const_iterator it2;
	for ( it2=inst_regs.begin() ; it2 != inst_regs.end(); it2++ )
		if(reg_table[wid].find(*it2) != reg_table[wid].end()) {
			return true;
	}
	return false;
}

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br></div></div></details> <h4 id="function-gpu-mode"><a href="#function-gpu-mode" class="header-anchor">#</a> Function GPU Mode</h4> <p><a href="https://hitqshao.github.io/qishao-notes/pages/458725/" target="_blank" rel="noopener noreferrer">function mode<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> is described in previous blog.</p></div></div> <!----> <div class="page-edit"><div class="edit-link"><a href="https://github.com/hitqshao/qishao-notes/edit/main/docs/03.gpu/13.gpgpusim.md" target="_blank" rel="noopener noreferrer">帮助我们改善此页面</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">2024/10/30, 23:59:20</span></div></div> <div class="page-nav-wapper"><div class="page-nav-centre-wrap"><a href="/qishao-notes/pages/458725/" class="page-nav-centre page-nav-centre-prev"><div class="tooltip">Understanding GPGPU-SIM 1 How to get Instruction</div></a> <a href="/qishao-notes/pages/458727/" class="page-nav-centre page-nav-centre-next"><div class="tooltip">Understanding GPGPU-SIM 3 How is the simulation started</div></a></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/qishao-notes/pages/458725/" class="prev">Understanding GPGPU-SIM 1 How to get Instruction</a></span> <span class="next"><a href="/qishao-notes/pages/458727/">Understanding GPGPU-SIM 3 How is the simulation started</a>→
      </span></p></div></div></div> <!----></main></div> <div class="footer"><div class="icons"><a href="https://github.com/hitqshao" title="GitHub" target="_blank" class="iconfont icon-github"></a><a href="mailto:hitqshao@163.com" title="发邮件" target="_blank" class="iconfont icon-youjian"></a><a href="https://gitee.com/hitqshao" title="Gitee" target="_blank" class="iconfont icon-gitee"></a></div> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2022-2024
    <span>Eryajf | <a href="https://github.com/hitqshao/qishao-notes/blob/main/LICENSE" target="_blank">MIT License</a></span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <!----> <!----> <!----></div><div class="global-ui"><!----></div></div>
    <script src="/qishao-notes/assets/js/app.6e252b53.js" defer></script><script src="/qishao-notes/assets/js/2.75973713.js" defer></script><script src="/qishao-notes/assets/js/43.7b76fbd7.js" defer></script>
  </body>
</html>
